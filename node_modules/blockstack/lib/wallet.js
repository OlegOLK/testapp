"use strict";

exports.__esModule = true;
exports.BlockstackWallet = void 0;

var _crypto = _interopRequireWildcard(require("crypto"));

var _bitcoinjsLib = _interopRequireWildcard(require("bitcoinjs-lib"));

var _bip = _interopRequireDefault(require("bip39"));

var _bip2 = _interopRequireDefault(require("bip32"));

var _utils = require("./utils");

var _wallet = require("./encryption/wallet");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

const APPS_NODE_INDEX = 0;
const IDENTITY_KEYCHAIN = 888;
const BLOCKSTACK_ON_BITCOIN = 0;
const BITCOIN_BIP_44_PURPOSE = 44;
const BITCOIN_COIN_TYPE = 0;
const BITCOIN_ACCOUNT_INDEX = 0;
const EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';
const CHANGE_ADDRESS = 'CHANGE_ADDRESS';

function hashCode(string) {
  let hash = 0;
  if (string.length === 0) return hash;

  for (let i = 0; i < string.length; i++) {
    const character = string.charCodeAt(i);
    hash = (hash << 5) - hash + character;
    hash &= hash;
  }

  return hash & 0x7fffffff;
}

function getNodePrivateKey(node) {
  return (0, _utils.ecPairToHexString)(_bitcoinjsLib.ECPair.fromPrivateKey(node.privateKey));
}

function getNodePublicKey(node) {
  return node.publicKey.toString('hex');
}
/**
 * The BlockstackWallet class manages the hierarchical derivation
 *  paths for a standard blockstack client wallet. This includes paths
 *  for bitcoin payment address, blockstack identity addresses, blockstack
 *  application specific addresses.
 *  @private
 */


class BlockstackWallet {
  constructor(rootNode) {
    this.rootNode = rootNode;
  }

  toBase58() {
    return this.rootNode.toBase58();
  }
  /**
   * Initialize a blockstack wallet from a seed buffer
   * @param {Buffer} seed - the input seed for initializing the root node
   *  of the hierarchical wallet
   * @return {BlockstackWallet} the constructed wallet
   */


  static fromSeedBuffer(seed) {
    return new BlockstackWallet(_bip2.default.fromSeed(seed));
  }
  /**
   * Initialize a blockstack wallet from a base58 string
   * @param {string} keychain - the Base58 string used to initialize
   *  the root node of the hierarchical wallet
   * @return {BlockstackWallet} the constructed wallet
   */


  static fromBase58(keychain) {
    return new BlockstackWallet(_bip2.default.fromBase58(keychain));
  }
  /**
   * Initialize a blockstack wallet from an encrypted phrase & password. Throws
   * if the password is incorrect. Supports all formats of Blockstack phrases.
   * @param {string} data - The encrypted phrase as a hex-encoded string
   * @param {string} password - The plain password
   * @return {Promise<BlockstackWallet>} the constructed wallet
   */


  static fromEncryptedMnemonic(data, password) {
    return (0, _wallet.decryptMnemonic)(data, password).then(mnemonic => {
      const seed = _bip.default.mnemonicToSeed(mnemonic);

      return new BlockstackWallet(_bip2.default.fromSeed(seed));
    }).catch(err => {
      if (err.message && err.message.startsWith('bad header;')) {
        throw new Error('Incorrect password');
      } else {
        throw err;
      }
    });
  }
  /**
   * Generate a BIP-39 12 word mnemonic
   * @return {Promise<string>} space-separated 12 word phrase
   */


  static generateMnemonic() {
    return _bip.default.generateMnemonic(128, _crypto.randomBytes);
  }
  /**
   * Encrypt a mnemonic phrase with a password
   * @param {string} mnemonic - Raw mnemonic phrase
   * @param {string} password - Password to encrypt mnemonic with
   * @return {Promise<string>} Hex-encoded encrypted mnemonic
   */


  static async encryptMnemonic(mnemonic, password) {
    const encryptedBuffer = await (0, _wallet.encryptMnemonic)(mnemonic, password);
    return encryptedBuffer.toString('hex');
  }

  getIdentityPrivateKeychain() {
    return this.rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);
  }

  getBitcoinPrivateKeychain() {
    return this.rootNode.deriveHardened(BITCOIN_BIP_44_PURPOSE).deriveHardened(BITCOIN_COIN_TYPE).deriveHardened(BITCOIN_ACCOUNT_INDEX);
  }

  getBitcoinNode(addressIndex, chainType = EXTERNAL_ADDRESS) {
    return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);
  }

  getIdentityAddressNode(identityIndex) {
    const identityPrivateKeychain = this.getIdentityPrivateKeychain();
    return identityPrivateKeychain.deriveHardened(identityIndex);
  }

  static getAppsNode(identityNode) {
    return identityNode.deriveHardened(APPS_NODE_INDEX);
  }
  /**
   * Get a salt for use with creating application specific addresses
   * @return {String} the salt
   */


  getIdentitySalt() {
    const identityPrivateKeychain = this.getIdentityPrivateKeychain();
    const publicKeyHex = getNodePublicKey(identityPrivateKeychain);
    return _crypto.default.createHash('sha256').update(publicKeyHex).digest('hex');
  }
  /**
   * Get a bitcoin receive address at a given index
   * @param {number} addressIndex - the index of the address
   * @return {String} address
   */


  getBitcoinAddress(addressIndex) {
    return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));
  }
  /**
   * Get the private key hex-string for a given bitcoin receive address
   * @param {number} addressIndex - the index of the address
   * @return {String} the hex-string. this will be either 64
   * characters long to denote an uncompressed bitcoin address, or 66
   * characters long for a compressed bitcoin address.
   */


  getBitcoinPrivateKey(addressIndex) {
    return getNodePrivateKey(this.getBitcoinNode(addressIndex));
  }
  /**
   * Get the root node for the bitcoin public keychain
   * @return {String} base58-encoding of the public node
   */


  getBitcoinPublicKeychain() {
    return this.getBitcoinPrivateKeychain().neutered();
  }
  /**
   * Get the root node for the identity public keychain
   * @return {String} base58-encoding of the public node
   */


  getIdentityPublicKeychain() {
    return this.getIdentityPrivateKeychain().neutered();
  }

  static getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {
    let chain;

    if (chainType === EXTERNAL_ADDRESS) {
      chain = 0;
    } else if (chainType === CHANGE_ADDRESS) {
      chain = 1;
    } else {
      throw new Error('Invalid chain type');
    }

    const keychain = _bip2.default.fromBase58(keychainBase58);

    return keychain.derive(chain).derive(addressIndex);
  }
  /**
   * Get a bitcoin address given a base-58 encoded bitcoin node
   * (usually called the account node)
   * @param {String} keychainBase58 - base58-encoding of the node
   * @param {number} addressIndex - index of the address to get
   * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a
   * "receive" address) or 'CHANGE_ADDRESS'
   * @return {String} the address
   */


  static getAddressFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {
    return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet.getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));
  }
  /**
   * Get a ECDSA private key hex-string for an application-specific
   *  address.
   * @param {String} appsNodeKey - the base58-encoded private key for
   * applications node (the `appsNodeKey` return in getIdentityKeyPair())
   * @param {String} salt - a string, used to salt the
   * application-specific addresses
   * @param {String} appDomain - the appDomain to generate a key for
   * @return {String} the private key hex-string. this will be a 64
   * character string
   */


  static getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {
    const hash = _crypto.default.createHash('sha256').update(`${appDomain}${salt}`).digest('hex');

    const appIndex = hashCode(hash);

    const appNode = _bip2.default.fromBase58(appsNodeKey).deriveHardened(appIndex);

    return getNodePrivateKey(appNode).slice(0, 64);
  }

  static getAddressFromBIP32Node(node) {
    return _bitcoinjsLib.default.payments.p2pkh({
      pubkey: node.publicKey
    }).address;
  }
  /**
   * Get a ECDSA private key hex-string for an application-specific
   *  address.
   * @param {String} appsNodeKey - the base58-encoded private key for
   * applications node (the `appsNodeKey` return in getIdentityKeyPair())
   * @param {String} salt - a string, used to salt the
   * application-specific addresses
   * @param {String} appDomain - the appDomain to generate a key for
   * @return {String} the private key hex-string. this will be a 64
   * character string
   */


  static getAppPrivateKey(appsNodeKey, salt, appDomain) {
    const hash = _crypto.default.createHash('sha256').update(`${appDomain}${salt}`).digest('hex');

    const appIndexHexes = []; // note: there's hardcoded numbers here, precisely because I want this
    //   code to be very specific to the derivation paths we expect.

    if (hash.length !== 64) {
      throw new Error(`Unexpected app-domain hash length of ${hash.length}`);
    }

    for (let i = 0; i < 11; i++) {
      // split the hash into 3-byte chunks
      // because child nodes can only be up to 2^31,
      // and we shouldn't deal in partial bytes.
      appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));
    }

    let appNode = _bip2.default.fromBase58(appsNodeKey);

    appIndexHexes.forEach(hex => {
      if (hex.length > 6) {
        throw new Error('Invalid hex string length');
      }

      appNode = appNode.deriveHardened(parseInt(hex, 16));
    });
    return getNodePrivateKey(appNode).slice(0, 64);
  }
  /**
   * Get the keypair information for a given identity index. This
   * information is used to obtain the private key for an identity address
   * and derive application specific keys for that address.
   * @param {number} addressIndex - the identity index
   * @param {boolean} alwaysUncompressed - if true, always return a
   *   private-key hex string corresponding to the uncompressed address
   * @return {Object} an IdentityKeyPair type object with keys:
   *   .key {String} - the private key hex-string
   *   .keyID {String} - the public key hex-string
   *   .address {String} - the identity address
   *   .appsNodeKey {String} - the base-58 encoding of the applications node
   *   .salt {String} - the salt used for creating app-specific addresses
   */


  getIdentityKeyPair(addressIndex, alwaysUncompressed = false) {
    const identityNode = this.getIdentityAddressNode(addressIndex);
    const address = BlockstackWallet.getAddressFromBIP32Node(identityNode);
    let identityKey = getNodePrivateKey(identityNode);

    if (alwaysUncompressed && identityKey.length === 66) {
      identityKey = identityKey.slice(0, 64);
    }

    const identityKeyID = getNodePublicKey(identityNode);
    const appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();
    const salt = this.getIdentitySalt();
    const keyPair = {
      key: identityKey,
      keyID: identityKeyID,
      address,
      appsNodeKey,
      salt
    };
    return keyPair;
  }

}

exports.BlockstackWallet = BlockstackWallet;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy93YWxsZXQuanMiXSwibmFtZXMiOlsiQVBQU19OT0RFX0lOREVYIiwiSURFTlRJVFlfS0VZQ0hBSU4iLCJCTE9DS1NUQUNLX09OX0JJVENPSU4iLCJCSVRDT0lOX0JJUF80NF9QVVJQT1NFIiwiQklUQ09JTl9DT0lOX1RZUEUiLCJCSVRDT0lOX0FDQ09VTlRfSU5ERVgiLCJFWFRFUk5BTF9BRERSRVNTIiwiQ0hBTkdFX0FERFJFU1MiLCJoYXNoQ29kZSIsInN0cmluZyIsImhhc2giLCJsZW5ndGgiLCJpIiwiY2hhcmFjdGVyIiwiY2hhckNvZGVBdCIsImdldE5vZGVQcml2YXRlS2V5Iiwibm9kZSIsIkVDUGFpciIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImdldE5vZGVQdWJsaWNLZXkiLCJwdWJsaWNLZXkiLCJ0b1N0cmluZyIsIkJsb2Nrc3RhY2tXYWxsZXQiLCJjb25zdHJ1Y3RvciIsInJvb3ROb2RlIiwidG9CYXNlNTgiLCJmcm9tU2VlZEJ1ZmZlciIsInNlZWQiLCJiaXAzMiIsImZyb21TZWVkIiwiZnJvbUJhc2U1OCIsImtleWNoYWluIiwiZnJvbUVuY3J5cHRlZE1uZW1vbmljIiwiZGF0YSIsInBhc3N3b3JkIiwidGhlbiIsIm1uZW1vbmljIiwiYmlwMzkiLCJtbmVtb25pY1RvU2VlZCIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsInN0YXJ0c1dpdGgiLCJFcnJvciIsImdlbmVyYXRlTW5lbW9uaWMiLCJyYW5kb21CeXRlcyIsImVuY3J5cHRNbmVtb25pYyIsImVuY3J5cHRlZEJ1ZmZlciIsImdldElkZW50aXR5UHJpdmF0ZUtleWNoYWluIiwiZGVyaXZlSGFyZGVuZWQiLCJnZXRCaXRjb2luUHJpdmF0ZUtleWNoYWluIiwiZ2V0Qml0Y29pbk5vZGUiLCJhZGRyZXNzSW5kZXgiLCJjaGFpblR5cGUiLCJnZXROb2RlRnJvbUJpdGNvaW5LZXljaGFpbiIsImdldElkZW50aXR5QWRkcmVzc05vZGUiLCJpZGVudGl0eUluZGV4IiwiaWRlbnRpdHlQcml2YXRlS2V5Y2hhaW4iLCJnZXRBcHBzTm9kZSIsImlkZW50aXR5Tm9kZSIsImdldElkZW50aXR5U2FsdCIsInB1YmxpY0tleUhleCIsImNyeXB0byIsImNyZWF0ZUhhc2giLCJ1cGRhdGUiLCJkaWdlc3QiLCJnZXRCaXRjb2luQWRkcmVzcyIsImdldEFkZHJlc3NGcm9tQklQMzJOb2RlIiwiZ2V0Qml0Y29pblByaXZhdGVLZXkiLCJnZXRCaXRjb2luUHVibGljS2V5Y2hhaW4iLCJuZXV0ZXJlZCIsImdldElkZW50aXR5UHVibGljS2V5Y2hhaW4iLCJrZXljaGFpbkJhc2U1OCIsImNoYWluIiwiZGVyaXZlIiwiZ2V0QWRkcmVzc0Zyb21CaXRjb2luS2V5Y2hhaW4iLCJnZXRMZWdhY3lBcHBQcml2YXRlS2V5IiwiYXBwc05vZGVLZXkiLCJzYWx0IiwiYXBwRG9tYWluIiwiYXBwSW5kZXgiLCJhcHBOb2RlIiwic2xpY2UiLCJiaXRjb2luIiwicGF5bWVudHMiLCJwMnBraCIsInB1YmtleSIsImFkZHJlc3MiLCJnZXRBcHBQcml2YXRlS2V5IiwiYXBwSW5kZXhIZXhlcyIsInB1c2giLCJmb3JFYWNoIiwiaGV4IiwicGFyc2VJbnQiLCJnZXRJZGVudGl0eUtleVBhaXIiLCJhbHdheXNVbmNvbXByZXNzZWQiLCJpZGVudGl0eUtleSIsImlkZW50aXR5S2V5SUQiLCJrZXlQYWlyIiwia2V5Iiwia2V5SUQiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7OztBQUVBLE1BQU1BLGVBQWUsR0FBRyxDQUF4QjtBQUNBLE1BQU1DLGlCQUFpQixHQUFHLEdBQTFCO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsQ0FBOUI7QUFFQSxNQUFNQyxzQkFBc0IsR0FBRyxFQUEvQjtBQUNBLE1BQU1DLGlCQUFpQixHQUFHLENBQTFCO0FBQ0EsTUFBTUMscUJBQXFCLEdBQUcsQ0FBOUI7QUFFQSxNQUFNQyxnQkFBZ0IsR0FBRyxrQkFBekI7QUFDQSxNQUFN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QUFDQSxRQUFJb0Msa0JBQWtCLElBQUlDLFdBQVcsQ0FBQ3RGLE1BQVosS0FBdUIsRUFBakQsRUFBcUQ7QUFDbkRzRixNQUFBQSxXQUFXLEdBQUdBLFdBQVcsQ0FBQ2QsS0FBWixDQUFrQixDQUFsQixFQUFxQixFQUFyQixDQUFkO0FBQ0Q7O0FBRUQsVUFBTWUsYUFBYSxHQUFHOUUsZ0JBQWdCLENBQUN3QyxZQUFELENBQXRDO0FBQ0EsVUFBTWtCLFdBQVcsR0FBR3ZELGdCQUFnQixDQUFDb0MsV0FBakIsQ0FBNkJDLFlBQTdCLEVBQTJDbEMsUUFBM0MsRUFBcEI7QUFDQSxVQUFNcUQsSUFBSSxHQUFHLEtBQUtsQixlQUFMLEVBQWI7QUFDQSxVQUFNc0MsT0FBTyxHQUFHO0FBQ2RDLE1BQUFBLEdBQUcsRUFBRUgsV0FEUztBQUVkSSxNQUFBQSxLQUFLLEVBQUVILGFBRk87QUFHZFYsTUFBQUEsT0FIYztBQUlkVixNQUFBQSxXQUpjO0FBS2RDLE1BQUFBO0FBTGMsS0FBaEI7QUFPQSxXQUFPb0IsT0FBUDtBQUNEOztBQXJSMkIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuaW1wb3J0IGNyeXB0bywgeyByYW5kb21CeXRlcyB9IGZyb20gJ2NyeXB0bydcbmltcG9ydCBiaXRjb2luLCB7IEVDUGFpciB9IGZyb20gJ2JpdGNvaW5qcy1saWInXG5pbXBvcnQgYmlwMzkgZnJvbSAnYmlwMzknXG5pbXBvcnQgYmlwMzIgZnJvbSAnYmlwMzInXG5pbXBvcnQgdHlwZSBCSVAzMiBmcm9tICdiaXAzMidcbmltcG9ydCB7IGVjUGFpclRvSGV4U3RyaW5nIH0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7IGVuY3J5cHRNbmVtb25pYywgZGVjcnlwdE1uZW1vbmljIH0gZnJvbSAnLi9lbmNyeXB0aW9uL3dhbGxldCdcblxuY29uc3QgQVBQU19OT0RFX0lOREVYID0gMFxuY29uc3QgSURFTlRJVFlfS0VZQ0hBSU4gPSA4ODhcbmNvbnN0IEJMT0NLU1RBQ0tfT05fQklUQ09JTiA9IDBcblxuY29uc3QgQklUQ09JTl9CSVBfNDRfUFVSUE9TRSA9IDQ0XG5jb25zdCBCSVRDT0lOX0NPSU5fVFlQRSA9IDBcbmNvbnN0IEJJVENPSU5fQUNDT1VOVF9JTkRFWCA9IDBcblxuY29uc3QgRVhURVJOQUxfQUREUkVTUyA9ICdFWFRFUk5BTF9BRERSRVNTJ1xuY29uc3QgQ0hBTkdFX0FERFJFU1MgPSAnQ0hBTkdFX0FERFJFU1MnXG5cbmV4cG9ydCB0eXBlIElkZW50aXR5S2V5UGFpciA9IHtcbiAga2V5OiBzdHJpbmcsXG4gIGtleUlEOiBzdHJpbmcsXG4gIGFkZHJlc3M6IHN0cmluZyxcbiAgYXBwc05vZGVLZXk6IHN0cmluZyxcbiAgc2FsdDogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGhhc2hDb2RlKHN0cmluZykge1xuICBsZXQgaGFzaCA9IDBcbiAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHJldHVybiBoYXNoXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2hhcmFjdGVyID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hhcmFjdGVyXG4gICAgaGFzaCAmPSBoYXNoXG4gIH1cbiAgcmV0dXJuIGhhc2ggJiAweDdmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGdldE5vZGVQcml2YXRlS2V5KG5vZGU6IEJJUDMyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVjUGFpclRvSGV4U3RyaW5nKEVDUGFpci5mcm9tUHJpdmF0ZUtleShub2RlLnByaXZhdGVLZXkpKVxufVxuXG5mdW5jdGlvbiBnZXROb2RlUHVibGljS2V5KG5vZGU6IEJJUDMyKTogc3RyaW5nIHtcbiAgcmV0dXJuIG5vZGUucHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKVxufVxuXG4vKipcbiAqIFRoZSBCbG9ja3N0YWNrV2FsbGV0IGNsYXNzIG1hbmFnZXMgdGhlIGhpZXJhcmNoaWNhbCBkZXJpdmF0aW9uXG4gKiAgcGF0aHMgZm9yIGEgc3RhbmRhcmQgYmxvY2tzdGFjayBjbGllbnQgd2FsbGV0LiBUaGlzIGluY2x1ZGVzIHBhdGhzXG4gKiAgZm9yIGJpdGNvaW4gcGF5bWVudCBhZGRyZXNzLCBibG9ja3N0YWNrIGlkZW50aXR5IGFkZHJlc3NlcywgYmxvY2tzdGFja1xuICogIGFwcGxpY2F0aW9uIHNwZWNpZmljIGFkZHJlc3Nlcy5cbiAqICBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgQmxvY2tzdGFja1dhbGxldCB7XG4gIHJvb3ROb2RlOiBCSVAzMlxuXG4gIGNvbnN0cnVjdG9yKHJvb3ROb2RlOiBCSVAzMikge1xuICAgIHRoaXMucm9vdE5vZGUgPSByb290Tm9kZVxuICB9XG5cbiAgdG9CYXNlNTgoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5yb290Tm9kZS50b0Jhc2U1OCgpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIGJsb2Nrc3RhY2sgd2FsbGV0IGZyb20gYSBzZWVkIGJ1ZmZlclxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2VlZCAtIHRoZSBpbnB1dCBzZWVkIGZvciBpbml0aWFsaXppbmcgdGhlIHJvb3Qgbm9kZVxuICAgKiAgb2YgdGhlIGhpZXJhcmNoaWNhbCB3YWxsZXRcbiAgICogQHJldHVybiB7QmxvY2tzdGFja1dhbGxldH0gdGhlIGNvbnN0cnVjdGVkIHdhbGxldFxuICAgKi9cbiAgc3RhdGljIGZyb21TZWVkQnVmZmVyKHNlZWQ6IEJ1ZmZlcik6IEJsb2Nrc3RhY2tXYWxsZXQge1xuICAgIHJldHVybiBuZXcgQmxvY2tzdGFja1dhbGxldChiaXAzMi5mcm9tU2VlZChzZWVkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgYmxvY2tzdGFjayB3YWxsZXQgZnJvbSBhIGJhc2U1OCBzdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleWNoYWluIC0gdGhlIEJhc2U1OCBzdHJpbmcgdXNlZCB0byBpbml0aWFsaXplXG4gICAqICB0aGUgcm9vdCBub2RlIG9mIHRoZSBoaWVyYXJjaGljYWwgd2FsbGV0XG4gICAqIEByZXR1cm4ge0Jsb2Nrc3RhY2tXYWxsZXR9IHRoZSBjb25zdHJ1Y3RlZCB3YWxsZXRcbiAgICovXG4gIHN0YXRpYyBmcm9tQmFzZTU4KGtleWNoYWluOiBzdHJpbmcpOiBCbG9ja3N0YWNrV2FsbGV0IHtcbiAgICByZXR1cm4gbmV3IEJsb2Nrc3RhY2tXYWxsZXQoYmlwMzIuZnJvbUJhc2U1OChrZXljaGFpbikpXG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIGJsb2Nrc3RhY2sgd2FsbGV0IGZyb20gYW4gZW5jcnlwdGVkIHBocmFzZSAmIHBhc3N3b3JkLiBUaHJvd3NcbiAgICogaWYgdGhlIHBhc3N3b3JkIGlzIGluY29ycmVjdC4gU3VwcG9ydHMgYWxsIGZvcm1hdHMgb2YgQmxvY2tzdGFjayBwaHJhc2VzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBlbmNyeXB0ZWQgcGhyYXNlIGFzIGEgaGV4LWVuY29kZWQgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSBwbGFpbiBwYXNzd29yZFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2Nrc3RhY2tXYWxsZXQ+fSB0aGUgY29uc3RydWN0ZWQgd2FsbGV0XG4gICAqL1xuICBzdGF0aWMgZnJvbUVuY3J5cHRlZE1uZW1vbmljKGRhdGE6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykge1xuICAgIHJldHVybiBkZWNyeXB0TW5lbW9uaWMoZGF0YSwgcGFzc3dvcmQpXG4gICAgICAudGhlbigobW5lbW9uaWMpID0+IHtcbiAgICAgICAgY29uc3Qgc2VlZCA9IGJpcDM5Lm1uZW1vbmljVG9TZWVkKG1uZW1vbmljKVxuICAgICAgICByZXR1cm4gbmV3IEJsb2Nrc3RhY2tXYWxsZXQoYmlwMzIuZnJvbVNlZWQoc2VlZCkpXG4gICAgICB9KVxuICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLnN0YXJ0c1dpdGgoJ2JhZCBoZWFkZXI7JykpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBwYXNzd29yZCcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBCSVAtMzkgMTIgd29yZCBtbmVtb25pY1xuICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59IHNwYWNlLXNlcGFyYXRlZCAxMiB3b3JkIHBocmFzZVxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlTW5lbW9uaWMoKSB7XG4gICAgcmV0dXJuIGJpcDM5LmdlbmVyYXRlTW5lbW9uaWMoMTI4LCByYW5kb21CeXRlcylcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0IGEgbW5lbW9uaWMgcGhyYXNlIHdpdGggYSBwYXNzd29yZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbW5lbW9uaWMgLSBSYXcgbW5lbW9uaWMgcGhyYXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFBhc3N3b3JkIHRvIGVuY3J5cHQgbW5lbW9uaWMgd2l0aFxuICAgKiBAcmV0dXJuIHtQcm9taXNlPHN0cmluZz59IEhleC1lbmNvZGVkIGVuY3J5cHRlZCBtbmVtb25pY1xuICAgKi9cbiAgc3RhdGljIGFzeW5jIGVuY3J5cHRNbmVtb25pYyhtbmVtb25pYzogc3RyaW5nLCBwYXNzd29yZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZW5jcnlwdGVkQnVmZmVyID0gYXdhaXQgZW5jcnlwdE1uZW1vbmljKG1uZW1vbmljLCBwYXNzd29yZClcbiAgICByZXR1cm4gZW5jcnlwdGVkQnVmZmVyLnRvU3RyaW5nKCdoZXgnKVxuICB9XG5cbiAgZ2V0SWRlbnRpdHlQcml2YXRlS2V5Y2hhaW4oKTogQklQMzIge1xuICAgIHJldHVybiB0aGlzLnJvb3ROb2RlXG4gICAgICAuZGVyaXZlSGFyZGVuZWQoSURFTlRJVFlfS0VZQ0hBSU4pXG4gICAgICAuZGVyaXZlSGFyZGVuZWQoQkxPQ0tTVEFDS19PTl9CSVRDT0lOKVxuICB9XG5cbiAgZ2V0Qml0Y29pblByaXZhdGVLZXljaGFpbigpOiBCSVAzMiB7XG4gICAgcmV0dXJuIHRoaXMucm9vdE5vZGVcbiAgICAgIC5kZXJpdmVIYXJkZW5lZChCSVRDT0lOX0JJUF80NF9QVVJQT1NFKVxuICAgICAgLmRlcml2ZUhhcmRlbmVkKEJJVENPSU5fQ09JTl9UWVBFKVxuICAgICAgLmRlcml2ZUhhcmRlbmVkKEJJVENPSU5fQUNDT1VOVF9JTkRFWClcbiAgfVxuXG4gIGdldEJpdGNvaW5Ob2RlKGFkZHJlc3NJbmRleDogbnVtYmVyLCBjaGFpblR5cGU6IHN0cmluZyA9IEVYVEVSTkFMX0FERFJFU1MpOiBCSVAzMiB7XG4gICAgcmV0dXJuIEJsb2Nrc3RhY2tXYWxsZXQuZ2V0Tm9kZUZyb21CaXRjb2luS2V5Y2hhaW4oXG4gICAgICB0aGlzLmdldEJpdGNvaW5Qcml2YXRlS2V5Y2hhaW4oKS50b0Jhc2U1OCgpLFxuICAgICAgYWRkcmVzc0luZGV4LFxuICAgICAgY2hhaW5UeXBlXG4gICAgKVxuICB9XG5cbiAgZ2V0SWRlbnRpdHlBZGRyZXNzTm9kZShpZGVudGl0eUluZGV4OiBudW1iZXIpOiBCSVAzMiB7XG4gICAgY29uc3QgaWRlbnRpdHlQcml2YXRlS2V5Y2hhaW4gPSB0aGlzLmdldElkZW50aXR5UHJpdmF0ZUtleWNoYWluKClcbiAgICByZXR1cm4gaWRlbnRpdHlQcml2YXRlS2V5Y2hhaW4uZGVyaXZlSGFyZGVuZWQoaWRlbnRpdHlJbmRleClcbiAgfVxuXG4gIHN0YXRpYyBnZXRBcHBzTm9kZShpZGVudGl0eU5vZGU6IEJJUDMyKTogQklQMzIge1xuICAgIHJldHVybiBpZGVudGl0eU5vZGUuZGVyaXZlSGFyZGVuZWQoQVBQU19OT0RFX0lOREVYKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIHNhbHQgZm9yIHVzZSB3aXRoIGNyZWF0aW5nIGFwcGxpY2F0aW9uIHNwZWNpZmljIGFkZHJlc3Nlc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBzYWx0XG4gICAqL1xuICBnZXRJZGVudGl0eVNhbHQoKTogc3RyaW5nIHtcbiAgICBjb25zdCBpZGVudGl0eVByaXZhdGVLZXljaGFpbiA9IHRoaXMuZ2V0SWRlbnRpdHlQcml2YXRlS2V5Y2hhaW4oKVxuICAgIGNvbnN0IHB1YmxpY0tleUhleCA9IGdldE5vZGVQdWJsaWNLZXkoaWRlbnRpdHlQcml2YXRlS2V5Y2hhaW4pXG4gICAgcmV0dXJuIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUocHVibGljS2V5SGV4KS5kaWdlc3QoJ2hleCcpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYml0Y29pbiByZWNlaXZlIGFkZHJlc3MgYXQgYSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gYWRkcmVzc0luZGV4IC0gdGhlIGluZGV4IG9mIHRoZSBhZGRyZXNzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gYWRkcmVzc1xuICAgKi9cbiAgZ2V0Qml0Y29pbkFkZHJlc3MoYWRkcmVzc0luZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBCbG9ja3N0YWNrV2FsbGV0LmdldEFkZHJlc3NGcm9tQklQMzJOb2RlKHRoaXMuZ2V0Qml0Y29pbk5vZGUoYWRkcmVzc0luZGV4KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaXZhdGUga2V5IGhleC1zdHJpbmcgZm9yIGEgZ2l2ZW4gYml0Y29pbiByZWNlaXZlIGFkZHJlc3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFkZHJlc3NJbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgYWRkcmVzc1xuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBoZXgtc3RyaW5nLiB0aGlzIHdpbGwgYmUgZWl0aGVyIDY0XG4gICAqIGNoYXJhY3RlcnMgbG9uZyB0byBkZW5vdGUgYW4gdW5jb21wcmVzc2VkIGJpdGNvaW4gYWRkcmVzcywgb3IgNjZcbiAgICogY2hhcmFjdGVycyBsb25nIGZvciBhIGNvbXByZXNzZWQgYml0Y29pbiBhZGRyZXNzLlxuICAgKi9cbiAgZ2V0Qml0Y29pblByaXZhdGVLZXkoYWRkcmVzc0luZGV4OiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBnZXROb2RlUHJpdmF0ZUtleSh0aGlzLmdldEJpdGNvaW5Ob2RlKGFkZHJlc3NJbmRleCkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByb290IG5vZGUgZm9yIHRoZSBiaXRjb2luIHB1YmxpYyBrZXljaGFpblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U1OC1lbmNvZGluZyBvZiB0aGUgcHVibGljIG5vZGVcbiAgICovXG4gIGdldEJpdGNvaW5QdWJsaWNLZXljaGFpbigpOiBCSVAzMiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Qml0Y29pblByaXZhdGVLZXljaGFpbigpLm5ldXRlcmVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJvb3Qgbm9kZSBmb3IgdGhlIGlkZW50aXR5IHB1YmxpYyBrZXljaGFpblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U1OC1lbmNvZGluZyBvZiB0aGUgcHVibGljIG5vZGVcbiAgICovXG4gIGdldElkZW50aXR5UHVibGljS2V5Y2hhaW4oKTogQklQMzIge1xuICAgIHJldHVybiB0aGlzLmdldElkZW50aXR5UHJpdmF0ZUtleWNoYWluKCkubmV1dGVyZWQoKVxuICB9XG5cbiAgc3RhdGljIGdldE5vZGVGcm9tQml0Y29pbktleWNoYWluKFxuICAgIGtleWNoYWluQmFzZTU4OiBzdHJpbmcsXG4gICAgYWRkcmVzc0luZGV4OiBudW1iZXIsXG4gICAgY2hhaW5UeXBlOiBzdHJpbmcgPSBFWFRFUk5BTF9BRERSRVNTXG4gICk6IEJJUDMyIHtcbiAgICBsZXQgY2hhaW5cbiAgICBpZiAoY2hhaW5UeXBlID09PSBFWFRFUk5BTF9BRERSRVNTKSB7XG4gICAgICBjaGFpbiA9IDBcbiAgICB9IGVsc2UgaWYgKGNoYWluVHlwZSA9PT0gQ0hBTkdFX0FERFJFU1MpIHtcbiAgICAgIGNoYWluID0gMVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hhaW4gdHlwZScpXG4gICAgfVxuICAgIGNvbnN0IGtleWNoYWluID0gYmlwMzIuZnJvbUJhc2U1OChrZXljaGFpbkJhc2U1OClcblxuICAgIHJldHVybiBrZXljaGFpbi5kZXJpdmUoY2hhaW4pLmRlcml2ZShhZGRyZXNzSW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgYml0Y29pbiBhZGRyZXNzIGdpdmVuIGEgYmFzZS01OCBlbmNvZGVkIGJpdGNvaW4gbm9kZVxuICAgKiAodXN1YWxseSBjYWxsZWQgdGhlIGFjY291bnQgbm9kZSlcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleWNoYWluQmFzZTU4IC0gYmFzZTU4LWVuY29kaW5nIG9mIHRoZSBub2RlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRyZXNzSW5kZXggLSBpbmRleCBvZiB0aGUgYWRkcmVzcyB0byBnZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNoYWluVHlwZSAtIGVpdGhlciAnRVhURVJOQUxfQUREUkVTUycgKGZvciBhXG4gICAqIFwicmVjZWl2ZVwiIGFkZHJlc3MpIG9yICdDSEFOR0VfQUREUkVTUydcbiAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgYWRkcmVzc1xuICAgKi9cbiAgc3RhdGljIGdldEFkZHJlc3NGcm9tQml0Y29pbktleWNoYWluKGtleWNoYWluQmFzZTU4OiBzdHJpbmcsIGFkZHJlc3NJbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5UeXBlOiBzdHJpbmcgPSBFWFRFUk5BTF9BRERSRVNTKTogc3RyaW5nIHtcbiAgICByZXR1cm4gQmxvY2tzdGFja1dhbGxldC5nZXRBZGRyZXNzRnJvbUJJUDMyTm9kZShCbG9ja3N0YWNrV2FsbGV0XG4gICAgICAuZ2V0Tm9kZUZyb21CaXRjb2luS2V5Y2hhaW4oa2V5Y2hhaW5CYXNlNTgsIGFkZHJlc3NJbmRleCwgY2hhaW5UeXBlKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBFQ0RTQSBwcml2YXRlIGtleSBoZXgtc3RyaW5nIGZvciBhbiBhcHBsaWNhdGlvbi1zcGVjaWZpY1xuICAgKiAgYWRkcmVzcy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwcHNOb2RlS2V5IC0gdGhlIGJhc2U1OC1lbmNvZGVkIHByaXZhdGUga2V5IGZvclxuICAgKiBhcHBsaWNhdGlvbnMgbm9kZSAodGhlIGBhcHBzTm9kZUtleWAgcmV0dXJuIGluIGdldElkZW50aXR5S2V5UGFpcigpKVxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2FsdCAtIGEgc3RyaW5nLCB1c2VkIHRvIHNhbHQgdGhlXG4gICAqIGFwcGxpY2F0aW9uLXNwZWNpZmljIGFkZHJlc3Nlc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwRG9tYWluIC0gdGhlIGFwcERvbWFpbiB0byBnZW5lcmF0ZSBhIGtleSBmb3JcbiAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcHJpdmF0ZSBrZXkgaGV4LXN0cmluZy4gdGhpcyB3aWxsIGJlIGEgNjRcbiAgICogY2hhcmFjdGVyIHN0cmluZ1xuICAgKi9cbiAgc3RhdGljIGdldExlZ2FjeUFwcFByaXZhdGVLZXkoYXBwc05vZGVLZXk6IHN0cmluZywgc2FsdDogc3RyaW5nLCBhcHBEb21haW46IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgaGFzaCA9IGNyeXB0b1xuICAgICAgLmNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAudXBkYXRlKGAke2FwcERvbWFpbn0ke3NhbHR9YClcbiAgICAgIC5kaWdlc3QoJ2hleCcpXG4gICAgY29uc3QgYXBwSW5kZXggPSBoYXNoQ29kZShoYXNoKVxuICAgIGNvbnN0IGFwcE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGFwcHNOb2RlS2V5KS5kZXJpdmVIYXJkZW5lZChhcHBJbmRleClcbiAgICByZXR1cm4gZ2V0Tm9kZVByaXZhdGVLZXkoYXBwTm9kZSkuc2xpY2UoMCwgNjQpXG4gIH1cblxuICBzdGF0aWMgZ2V0QWRkcmVzc0Zyb21CSVAzMk5vZGUobm9kZTogQklQMzIpIHtcbiAgICByZXR1cm4gYml0Y29pbi5wYXltZW50cy5wMnBraCh7IHB1YmtleTogbm9kZS5wdWJsaWNLZXkgfSkuYWRkcmVzc1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIEVDRFNBIHByaXZhdGUga2V5IGhleC1zdHJpbmcgZm9yIGFuIGFwcGxpY2F0aW9uLXNwZWNpZmljXG4gICAqICBhZGRyZXNzLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXBwc05vZGVLZXkgLSB0aGUgYmFzZTU4LWVuY29kZWQgcHJpdmF0ZSBrZXkgZm9yXG4gICAqIGFwcGxpY2F0aW9ucyBub2RlICh0aGUgYGFwcHNOb2RlS2V5YCByZXR1cm4gaW4gZ2V0SWRlbnRpdHlLZXlQYWlyKCkpXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzYWx0IC0gYSBzdHJpbmcsIHVzZWQgdG8gc2FsdCB0aGVcbiAgICogYXBwbGljYXRpb24tc3BlY2lmaWMgYWRkcmVzc2VzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBEb21haW4gLSB0aGUgYXBwRG9tYWluIHRvIGdlbmVyYXRlIGEga2V5IGZvclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwcml2YXRlIGtleSBoZXgtc3RyaW5nLiB0aGlzIHdpbGwgYmUgYSA2NFxuICAgKiBjaGFyYWN0ZXIgc3RyaW5nXG4gICAqL1xuICBzdGF0aWMgZ2V0QXBwUHJpdmF0ZUtleShhcHBzTm9kZUtleTogc3RyaW5nLCBzYWx0OiBzdHJpbmcsIGFwcERvbWFpbjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBoYXNoID0gY3J5cHRvXG4gICAgICAuY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoYCR7YXBwRG9tYWlufSR7c2FsdH1gKVxuICAgICAgLmRpZ2VzdCgnaGV4JylcbiAgICBjb25zdCBhcHBJbmRleEhleGVzID0gW11cbiAgICAvLyBub3RlOiB0aGVyZSdzIGhhcmRjb2RlZCBudW1iZXJzIGhlcmUsIHByZWNpc2VseSBiZWNhdXNlIEkgd2FudCB0aGlzXG4gICAgLy8gICBjb2RlIHRvIGJlIHZlcnkgc3BlY2lmaWMgdG8gdGhlIGRlcml2YXRpb24gcGF0aHMgd2UgZXhwZWN0LlxuICAgIGlmIChoYXNoLmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBhcHAtZG9tYWluIGhhc2ggbGVuZ3RoIG9mICR7aGFzaC5sZW5ndGh9YClcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMTsgaSsrKSB7IC8vIHNwbGl0IHRoZSBoYXNoIGludG8gMy1ieXRlIGNodW5rc1xuICAgICAgLy8gYmVjYXVzZSBjaGlsZCBub2RlcyBjYW4gb25seSBiZSB1cCB0byAyXjMxLFxuICAgICAgLy8gYW5kIHdlIHNob3VsZG4ndCBkZWFsIGluIHBhcnRpYWwgYnl0ZXMuXG4gICAgICBhcHBJbmRleEhleGVzLnB1c2goaGFzaC5zbGljZShpICogNiwgaSAqIDYgKyA2KSlcbiAgICB9XG4gICAgbGV0IGFwcE5vZGUgPSBiaXAzMi5mcm9tQmFzZTU4KGFwcHNOb2RlS2V5KVxuICAgIGFwcEluZGV4SGV4ZXMuZm9yRWFjaCgoaGV4KSA9PiB7XG4gICAgICBpZiAoaGV4Lmxlbmd0aCA+IDYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcgbGVuZ3RoJylcbiAgICAgIH1cbiAgICAgIGFwcE5vZGUgPSBhcHBOb2RlLmRlcml2ZUhhcmRlbmVkKHBhcnNlSW50KGhleCwgMTYpKVxuICAgIH0pXG4gICAgcmV0dXJuIGdldE5vZGVQcml2YXRlS2V5KGFwcE5vZGUpLnNsaWNlKDAsIDY0KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUga2V5cGFpciBpbmZvcm1hdGlvbiBmb3IgYSBnaXZlbiBpZGVudGl0eSBpbmRleC4gVGhpc1xuICAgKiBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvIG9idGFpbiB0aGUgcHJpdmF0ZSBrZXkgZm9yIGFuIGlkZW50aXR5IGFkZHJlc3NcbiAgICogYW5kIGRlcml2ZSBhcHBsaWNhdGlvbiBzcGVjaWZpYyBrZXlzIGZvciB0aGF0IGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhZGRyZXNzSW5kZXggLSB0aGUgaWRlbnRpdHkgaW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFufSBhbHdheXNVbmNvbXByZXNzZWQgLSBpZiB0cnVlLCBhbHdheXMgcmV0dXJuIGFcbiAgICogICBwcml2YXRlLWtleSBoZXggc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHVuY29tcHJlc3NlZCBhZGRyZXNzXG4gICAqIEByZXR1cm4ge09iamVjdH0gYW4gSWRlbnRpdHlLZXlQYWlyIHR5cGUgb2JqZWN0IHdpdGgga2V5czpcbiAgICogICAua2V5IHtTdHJpbmd9IC0gdGhlIHByaXZhdGUga2V5IGhleC1zdHJpbmdcbiAgICogICAua2V5SUQge1N0cmluZ30gLSB0aGUgcHVibGljIGtleSBoZXgtc3RyaW5nXG4gICAqICAgLmFkZHJlc3Mge1N0cmluZ30gLSB0aGUgaWRlbnRpdHkgYWRkcmVzc1xuICAgKiAgIC5hcHBzTm9kZUtleSB7U3RyaW5nfSAtIHRoZSBiYXNlLTU4IGVuY29kaW5nIG9mIHRoZSBhcHBsaWNhdGlvbnMgbm9kZVxuICAgKiAgIC5zYWx0IHtTdHJpbmd9IC0gdGhlIHNhbHQgdXNlZCBmb3IgY3JlYXRpbmcgYXBwLXNwZWNpZmljIGFkZHJlc3Nlc1xuICAgKi9cbiAgZ2V0SWRlbnRpdHlLZXlQYWlyKGFkZHJlc3NJbmRleDogbnVtYmVyLCBhbHdheXNVbmNvbXByZXNzZWQ6ID9ib29sZWFuID0gZmFsc2UpOiBJZGVudGl0eUtleVBhaXIge1xuICAgIGNvbnN0IGlkZW50aXR5Tm9kZSA9IHRoaXMuZ2V0SWRlbnRpdHlBZGRyZXNzTm9kZShhZGRyZXNzSW5kZXgpXG5cbiAgICBjb25zdCBhZGRyZXNzID0gQmxvY2tzdGFja1dhbGxldC5nZXRBZGRyZXNzRnJvbUJJUDMyTm9kZShpZGVudGl0eU5vZGUpXG4gICAgbGV0IGlkZW50aXR5S2V5ID0gZ2V0Tm9kZVByaXZhdGVLZXkoaWRlbnRpdHlOb2RlKVxuICAgIGlmIChhbHdheXNVbmNvbXByZXNzZWQgJiYgaWRlbnRpdHlLZXkubGVuZ3RoID09PSA2Nikge1xuICAgICAgaWRlbnRpdHlLZXkgPSBpZGVudGl0eUtleS5zbGljZSgwLCA2NClcbiAgICB9XG5cbiAgICBjb25zdCBpZGVudGl0eUtleUlEID0gZ2V0Tm9kZVB1YmxpY0tleShpZGVudGl0eU5vZGUpXG4gICAgY29uc3QgYXBwc05vZGVLZXkgPSBCbG9ja3N0YWNrV2FsbGV0LmdldEFwcHNOb2RlKGlkZW50aXR5Tm9kZSkudG9CYXNlNTgoKVxuICAgIGNvbnN0IHNhbHQgPSB0aGlzLmdldElkZW50aXR5U2FsdCgpXG4gICAgY29uc3Qga2V5UGFpciA9IHtcbiAgICAgIGtleTogaWRlbnRpdHlLZXksXG4gICAgICBrZXlJRDogaWRlbnRpdHlLZXlJRCxcbiAgICAgIGFkZHJlc3MsXG4gICAgICBhcHBzTm9kZUtleSxcbiAgICAgIHNhbHRcbiAgICB9XG4gICAgcmV0dXJuIGtleVBhaXJcbiAgfVxufVxuIl19