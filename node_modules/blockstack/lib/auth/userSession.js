"use strict";

exports.__esModule = true;
exports.UserSession = void 0;

var _queryString = _interopRequireDefault(require("query-string"));

var _appConfig = require("./appConfig");

var _sessionStore = require("./sessionStore");

var _authApp = require("./authApp");

var _authMessages = require("./authMessages");

var _storage = require("../storage");

var _utils = require("../utils");

var _errors = require("../errors");

var _logger = require("../logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Represents an instance of a signed in user for a particular app.
 *
 * A signed in user has access to two major pieces of information
 * about the user, the user's private key for that app and the location
 * of the user's gaia storage bucket for the app.
 *
 * A user can be signed in either directly through the interactive
 * sign in process or by directly providing the app private key.
 * @type {UserSession}
 */
class UserSession {
  constructor(options) {
    let runningInBrowser = true;

    if (typeof window === 'undefined') {
      _logger.Logger.debug('UserSession: not running in browser');

      runningInBrowser = false;
    }

    if (options && options.appConfig) {
      this.appConfig = options.appConfig;
    } else if (runningInBrowser) {
      this.appConfig = new _appConfig.AppConfig();
    } else {
      throw new _errors.MissingParameterError('You need to specify options.appConfig');
    }

    if (options && options.sessionStore) {
      this.store = options.sessionStore;
    } else if (runningInBrowser) {
      if (options) {
        this.store = new _sessionStore.LocalStorageStore(options.sessionOptions);
      } else {
        this.store = new _sessionStore.LocalStorageStore();
      }
    } else if (options) {
      this.store = new _sessionStore.InstanceDataStore(options.sessionOptions);
    } else {
      this.store = new _sessionStore.InstanceDataStore();
    }
  }
  /* AUTHENTICATION */

  /**
   * Generates an authentication request and redirects the user to the Blockstack
   * browser to approve the sign in request.
   *
   * Please note that this requires that the web browser properly handles the
   * `blockstack:` URL protocol handler.
   *
   * Most applications should use this
   * method for sign in unless they require more fine grained control over how the
   * authentication request is generated. If your app falls into this category,
   * use `generateAndStoreTransitKey`, `makeAuthRequest`,
   * and `redirectToSignInWithAuthRequest` to build your own sign in process.
   *
   * @return {void}
   */


  redirectToSignIn() {
    return (0, _authApp.redirectToSignInImpl)(this);
  }
  /**
   * Redirects the user to the Blockstack browser to approve the sign in request
   * given.
   *
   * The user is redirected to the authenticator URL specified in the `AppConfig`
   * if the `blockstack:` protocol handler is not detected.
   * Please note that the protocol handler detection
   * does not work on all browsers.
   * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
   * @return {void}
   */


  redirectToSignInWithAuthRequest(authRequest) {
    return (0, _authApp.redirectToSignInWithAuthRequestImpl)(this, authRequest);
  }
  /**
   * Generates an authentication request that can be sent to the Blockstack
   * browser for the user to approve sign in. This authentication request can
   * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`
   * method.
   *
   * *Note: This method should only be used if you want to roll your own authentication
   * flow. Typically you'd use `redirectToSignIn` which takes care of this
   * under the hood.*
   * @param {string} transitKey - hex-encoded transit key
   * @param {Number} expiresAt - the time at which this request is no longer valid
   * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.
   * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported
   * by special authenticators.
   * @return {String} the authentication request
   * @private
   */


  makeAuthRequest(transitKey, expiresAt = (0, _utils.nextHour)().getTime(), extraParams = {}) {
    const appConfig = this.appConfig;

    if (!appConfig) {
      throw new _errors.InvalidStateError('Missing AppConfig');
    }

    const redirectURI = appConfig.redirectURI();
    const manifestURI = appConfig.manifestURI();
    const scopes = appConfig.scopes;
    const appDomain = appConfig.appDomain;
    return (0, _authMessages.makeAuthRequestImpl)(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);
  }
  /**
   * Generates a ECDSA keypair to
   * use as the ephemeral app transit private key
   * and store in the session
   * @return {String} the hex encoded private key
   *
   */


  generateAndStoreTransitKey() {
    const sessionData = this.store.getSessionData();
    const transitKey = (0, _authMessages.generateTransitKey)();
    sessionData.transitKey = transitKey;
    this.store.setSessionData(sessionData);
    return transitKey;
  }
  /**
   * Retrieve the authentication token from the URL query
   * @return {String} the authentication token if it exists otherwise `null`
   */


  getAuthResponseToken() {
    const queryDict = _queryString.default.parse(location.search);

    return queryDict.authResponse ? queryDict.authResponse : '';
  }
  /**
   * Check if there is a authentication request that hasn't been handled.
   * @return {Boolean} `true` if there is a pending sign in, otherwise `false`
   */


  isSignInPending() {
    return !!this.getAuthResponseToken();
  }
  /**
   * Check if a user is currently signed in.
   * @return {Boolean} `true` if the user is signed in, `false` if not.
   */


  isUserSignedIn() {
    return !!this.store.getSessionData().userData;
  }
  /**
   * Try to process any pending sign in request by returning a `Promise` that resolves
   * to the user data object if the sign in succeeds.
   *
   * @param {String} authResponseToken - the signed authentication response token
   * @return {Promise} that resolves to the user data object if successful and rejects
   * if handling the sign in request fails or there was no pending sign in request.
   */


  handlePendingSignIn(authResponseToken = this.getAuthResponseToken()) {
    return (0, _authApp.handlePendingSignInImpl)(this, authResponseToken);
  }
  /**
   * Retrieves the user data object. The user's profile is stored in the key `profile`.
   * @return {Object} User data object.
   */


  loadUserData() {
    return (0, _authApp.loadUserDataImpl)(this);
  }
  /**
   * Sign the user out
   * @return {void}
   */


  signUserOut() {
    this.store.deleteSessionData();
  } //
  //
  // /* PROFILES */
  // extractProfile
  // wrapProfileToken
  // signProfileToken
  // verifyProfileToken
  // validateProofs
  // lookupProfile

  /* STORAGE */

  /**
   * Encrypts the data provided with the app public key.
   * @param {String|Buffer} content - data to encrypt
   * @param {Object} [options=null] - options object
   * @param {String} options.publicKey - the hex string of the ECDSA public
   * key to use for encryption. If not provided, will use user's appPrivateKey.
   * @return {String} Stringified ciphertext object
   */


  encryptContent(content, options) {
    return (0, _storage.encryptContentImpl)(this, content, options);
  }
  /**
   * Decrypts data encrypted with `encryptContent` with the
   * transit private key.
   * @param {String|Buffer} content - encrypted content.
   * @param {Object} [options=null] - options object
   * @param {String} options.privateKey - the hex string of the ECDSA private
   * key to use for decryption. If not provided, will use user's appPrivateKey.
   * @return {String|Buffer} decrypted content.
   */


  decryptContent(content, options) {
    return (0, _storage.decryptContentImpl)(this, content, options);
  }
  /**
   * Stores the data provided in the app's data store to to the file specified.
   * @param {String} path - the path to store the data in
   * @param {String|Buffer} content - the data to store in the file
   * @param {Object} [options=null] - options object
   * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app private key
   *                                                  or the provided public key
   * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with
   *                                         the app private key
   * @return {Promise} that resolves if the operation succeed and rejects
   * if it failed
   */


  putFile(path, content, options) {
    return (0, _storage.putFileImpl)(this, path, content, options);
  }
  /**
   * Retrieves the specified file from the app's data store.
   * @param {String} path - the path to the file to read
   * @param {Object} [options=null] - options object
   * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key
   * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
   * @param {Boolean} options.verify - Whether the content should be verified, only to be used
   * when `putFile` was set to `sign = true`
   * @param {String} options.app - the app to lookup for multi-player storage -
   * defaults to current origin
   * @param {String} [options.zoneFileLookupURL=null] - The URL
   * to use for zonefile lookup. If falsey, this will use the
   * blockstack.js's getNameInfo function instead.
   * @returns {Promise} that resolves to the raw data in the file
   * or rejects with an error
   */


  getFile(path, options) {
    return (0, _storage.getFileImpl)(this, path, options);
  }
  /**
   * Get the URL for reading a file from an app's data store.
   * @param {String} path - the path to the file to read
   * @param {Object} [options=null] - options object
   * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
   * @param {String} options.app - the app to lookup for multi-player storage -
   * defaults to current origin
   * @param {String} [options.zoneFileLookupURL=null] - The URL
   * to use for zonefile lookup. If falsey, this will use the
   * blockstack.js's getNameInfo function instead.
   * @returns {Promise<string>} that resolves to the URL or rejects with an error
   */


  getFileUrl(path, options) {
    return (0, _storage.getFileUrlImpl)(this, path, options);
  }
  /**
   * List the set of files in this application's Gaia storage bucket.
   * @param {function} callback - a callback to invoke on each named file that
   * returns `true` to continue the listing operation or `false` to end it
   * @return {Promise} that resolves to the number of files listed
   */


  listFiles(callback) {
    return (0, _storage.listFilesImpl)(this, callback);
  }
  /**
   * Deletes the specified file from the app's data store. Currently not implemented.
   * @param {String} path - the path to the file to delete
   * @returns {Promise} that resolves when the file has been removed
   * or rejects with an error
   * @private
   */


  deleteFile(path) {
    Promise.reject(new Error(`Delete of ${path} not supported by gaia hubs`));
  }

}

exports.UserSession = UserSession;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdXRoL3VzZXJTZXNzaW9uLmpzIl0sIm5hbWVzIjpbIlVzZXJTZXNzaW9uIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwicnVubmluZ0luQnJvd3NlciIsIndpbmRvdyIsIkxvZ2dlciIsImRlYnVnIiwiYXBwQ29uZmlnIiwiQXBwQ29uZmlnIiwiTWlzc2luZ1BhcmFtZXRlckVycm9yIiwic2Vzc2lvblN0b3JlIiwic3RvcmUiLCJMb2NhbFN0b3JhZ2VTdG9yZSIsInNlc3Npb25PcHRpb25zIiwiSW5zdGFuY2VEYXRhU3RvcmUiLCJyZWRpcmVjdFRvU2lnbkluIiwicmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdCIsImF1dGhSZXF1ZXN0IiwibWFrZUF1dGhSZXF1ZXN0IiwidHJhbnNpdEtleSIsImV4cGlyZXNBdCIsImdldFRpbWUiLCJleHRyYVBhcmFtcyIsIkludmFsaWRTdGF0ZUVycm9yIiwicmVkaXJlY3RVUkkiLCJtYW5pZmVzdFVSSSIsInNjb3BlcyIsImFwcERvbWFpbiIsImdlbmVyYXRlQW5kU3RvcmVUcmFuc2l0S2V5Iiwic2Vzc2lvbkRhdGEiLCJnZXRTZXNzaW9uRGF0YSIsInNldFNlc3Npb25EYXRhIiwiZ2V0QXV0aFJlc3BvbnNlVG9rZW4iLCJxdWVyeURpY3QiLCJxdWVyeVN0cmluZyIsInBhcnNlIiwibG9jYXRpb24iLCJzZWFyY2giLCJhdXRoUmVzcG9uc2UiLCJpc1NpZ25JblBlbmRpbmciLCJpc1VzZXJTaWduZWRJbiIsInVzZXJEYXRhIiwiaGFuZGxlUGVuZGluZ1NpZ25JbiIsImF1dGhSZXNwb25zZVRva2VuIiwibG9hZFVzZXJEYXRhIiwic2lnblVzZXJPdXQiLCJkZWxldGVTZXNzaW9uRGF0YSIsImVuY3J5cHRDb250ZW50IiwiY29udGVudCIsImRlY3J5cHRDb250ZW50IiwicHV0RmlsZSIsInBhdGgiLCJnZXRGaWxlIiwiZ2V0RmlsZVVybCIsImxpc3RGaWxlcyIsImNhbGxiYWNrIiwiZGVsZXRl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bEIsRUFBb0Q7QUFDaEUsV0FBTyxpQ0FBbUIsSUFBbkIsRUFBeUI4QyxPQUF6QixFQUFrQzlDLE9BQWxDLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7OztBQVlBZ0QsRUFBQUEsT0FBTyxDQUFDQyxJQUFELEVBQWVILE9BQWYsRUFBeUM5QyxPQUF6QyxFQUFtRTtBQUN4RSxXQUFPLDBCQUFZLElBQVosRUFBa0JpRCxJQUFsQixFQUF3QkgsT0FBeEIsRUFBaUM5QyxPQUFqQyxDQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBa0QsRUFBQUEsT0FBTyxDQUFDRCxJQUFELEVBQWVqRCxPQUFmLEVBTUY7QUFDSCxXQUFPLDBCQUFZLElBQVosRUFBa0JpRCxJQUFsQixFQUF3QmpELE9BQXhCLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7OztBQVlBbUQsRUFBQUEsVUFBVSxDQUFDRixJQUFELEVBQWVqRCxPQUFmLEVBSVU7QUFDbEIsV0FBTyw2QkFBZSxJQUFmLEVBQXFCaUQsSUFBckIsRUFBMkJqRCxPQUEzQixDQUFQO0FBQ0Q7QUFFRDs7Ozs7Ozs7QUFNQW9ELEVBQUFBLFNBQVMsQ0FBQ0MsUUFBRCxFQUF3RDtBQUMvRCxXQUFPLDRCQUFjLElBQWQsRUFBb0JBLFFBQXBCLENBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7QUFPQUMsRUFBQUEsVUFBVSxDQUFDTCxJQUFELEVBQWU7QUFDdkJNLElBQUFBLE9BQU8sQ0FBQ0MsTUFBUixDQUFlLElBQUlDLEtBQUosQ0FBVyxhQUFZUixJQUFLLDZCQUE1QixDQUFmO0FBQ0Q7O0FBeFNzQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5pbXBvcnQgcXVlcnlTdHJpbmcgZnJvbSAncXVlcnktc3RyaW5nJ1xuaW1wb3J0IHsgQXBwQ29uZmlnIH0gZnJvbSAnLi9hcHBDb25maWcnXG5pbXBvcnQgdHlwZSB7IFNlc3Npb25PcHRpb25zIH0gZnJvbSAnLi9zZXNzaW9uRGF0YSdcbmltcG9ydCB7XG4gIExvY2FsU3RvcmFnZVN0b3JlLFxuICBTZXNzaW9uRGF0YVN0b3JlLFxuICBJbnN0YW5jZURhdGFTdG9yZVxufSBmcm9tICcuL3Nlc3Npb25TdG9yZSdcbmltcG9ydCB7XG4gIHJlZGlyZWN0VG9TaWduSW5JbXBsLFxuICByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0SW1wbCxcbiAgaGFuZGxlUGVuZGluZ1NpZ25JbkltcGwsXG4gIGxvYWRVc2VyRGF0YUltcGxcbn0gZnJvbSAnLi9hdXRoQXBwJ1xuXG5pbXBvcnQge1xuICBtYWtlQXV0aFJlcXVlc3RJbXBsLFxuICBnZW5lcmF0ZVRyYW5zaXRLZXlcbn0gZnJvbSAnLi9hdXRoTWVzc2FnZXMnXG5cbmltcG9ydCB7XG4gIGRlY3J5cHRDb250ZW50SW1wbCxcbiAgZW5jcnlwdENvbnRlbnRJbXBsLFxuICBnZXRGaWxlSW1wbCxcbiAgcHV0RmlsZUltcGwsXG4gIGxpc3RGaWxlc0ltcGwsXG4gIGdldEZpbGVVcmxJbXBsXG59IGZyb20gJy4uL3N0b3JhZ2UnXG5cbmltcG9ydCB0eXBlIHtcbiAgUHV0RmlsZU9wdGlvbnNcbn0gZnJvbSAnLi4vc3RvcmFnZSdcblxuaW1wb3J0IHtcbiAgbmV4dEhvdXJcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQge1xuICBNaXNzaW5nUGFyYW1ldGVyRXJyb3IsXG4gIEludmFsaWRTdGF0ZUVycm9yXG59IGZyb20gJy4uL2Vycm9ycydcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gJy4uL2xvZ2dlcidcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIGEgc2lnbmVkIGluIHVzZXIgZm9yIGEgcGFydGljdWxhciBhcHAuXG4gKlxuICogQSBzaWduZWQgaW4gdXNlciBoYXMgYWNjZXNzIHRvIHR3byBtYWpvciBwaWVjZXMgb2YgaW5mb3JtYXRpb25cbiAqIGFib3V0IHRoZSB1c2VyLCB0aGUgdXNlcidzIHByaXZhdGUga2V5IGZvciB0aGF0IGFwcCBhbmQgdGhlIGxvY2F0aW9uXG4gKiBvZiB0aGUgdXNlcidzIGdhaWEgc3RvcmFnZSBidWNrZXQgZm9yIHRoZSBhcHAuXG4gKlxuICogQSB1c2VyIGNhbiBiZSBzaWduZWQgaW4gZWl0aGVyIGRpcmVjdGx5IHRocm91Z2ggdGhlIGludGVyYWN0aXZlXG4gKiBzaWduIGluIHByb2Nlc3Mgb3IgYnkgZGlyZWN0bHkgcHJvdmlkaW5nIHRoZSBhcHAgcHJpdmF0ZSBrZXkuXG4gKiBAdHlwZSB7VXNlclNlc3Npb259XG4gKi9cbmV4cG9ydCBjbGFzcyBVc2VyU2Vzc2lvbiB7XG4gIGFwcENvbmZpZzogQXBwQ29uZmlnXG5cbiAgc3RvcmU6IFNlc3Npb25EYXRhU3RvcmVcblxuICBjb25zdHJ1Y3RvcihvcHRpb25zPzoge2FwcENvbmZpZz86IEFwcENvbmZpZyxcbiAgICBzZXNzaW9uU3RvcmU/OiBTZXNzaW9uRGF0YVN0b3JlLFxuICAgIHNlc3Npb25PcHRpb25zPzogU2Vzc2lvbk9wdGlvbnMgfSkge1xuICAgIGxldCBydW5uaW5nSW5Ccm93c2VyID0gdHJ1ZVxuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBMb2dnZXIuZGVidWcoJ1VzZXJTZXNzaW9uOiBub3QgcnVubmluZyBpbiBicm93c2VyJylcbiAgICAgIHJ1bm5pbmdJbkJyb3dzZXIgPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYXBwQ29uZmlnKSB7XG4gICAgICB0aGlzLmFwcENvbmZpZyA9IG9wdGlvbnMuYXBwQ29uZmlnXG4gICAgfSBlbHNlIGlmIChydW5uaW5nSW5Ccm93c2VyKSB7XG4gICAgICB0aGlzLmFwcENvbmZpZyA9IG5ldyBBcHBDb25maWcoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdZb3UgbmVlZCB0byBzcGVjaWZ5IG9wdGlvbnMuYXBwQ29uZmlnJylcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnNlc3Npb25TdG9yZSkge1xuICAgICAgdGhpcy5zdG9yZSA9IG9wdGlvbnMuc2Vzc2lvblN0b3JlXG4gICAgfSBlbHNlIGlmIChydW5uaW5nSW5Ccm93c2VyKSB7XG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IExvY2FsU3RvcmFnZVN0b3JlKG9wdGlvbnMuc2Vzc2lvbk9wdGlvbnMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JlID0gbmV3IExvY2FsU3RvcmFnZVN0b3JlKClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc3RvcmUgPSBuZXcgSW5zdGFuY2VEYXRhU3RvcmUob3B0aW9ucy5zZXNzaW9uT3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdG9yZSA9IG5ldyBJbnN0YW5jZURhdGFTdG9yZSgpXG4gICAgfVxuICB9XG5cbiAgLyogQVVUSEVOVElDQVRJT04gKi9cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgYW5kIHJlZGlyZWN0cyB0aGUgdXNlciB0byB0aGUgQmxvY2tzdGFja1xuICAgKiBicm93c2VyIHRvIGFwcHJvdmUgdGhlIHNpZ24gaW4gcmVxdWVzdC5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHRoYXQgdGhlIHdlYiBicm93c2VyIHByb3Blcmx5IGhhbmRsZXMgdGhlXG4gICAqIGBibG9ja3N0YWNrOmAgVVJMIHByb3RvY29sIGhhbmRsZXIuXG4gICAqXG4gICAqIE1vc3QgYXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhpc1xuICAgKiBtZXRob2QgZm9yIHNpZ24gaW4gdW5sZXNzIHRoZXkgcmVxdWlyZSBtb3JlIGZpbmUgZ3JhaW5lZCBjb250cm9sIG92ZXIgaG93IHRoZVxuICAgKiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGlzIGdlbmVyYXRlZC4gSWYgeW91ciBhcHAgZmFsbHMgaW50byB0aGlzIGNhdGVnb3J5LFxuICAgKiB1c2UgYGdlbmVyYXRlQW5kU3RvcmVUcmFuc2l0S2V5YCwgYG1ha2VBdXRoUmVxdWVzdGAsXG4gICAqIGFuZCBgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdGAgdG8gYnVpbGQgeW91ciBvd24gc2lnbiBpbiBwcm9jZXNzLlxuICAgKlxuICAgKiBAcmV0dXJuIHt2b2lkfVxuICAgKi9cbiAgcmVkaXJlY3RUb1NpZ25JbigpIHtcbiAgICByZXR1cm4gcmVkaXJlY3RUb1NpZ25JbkltcGwodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWRpcmVjdHMgdGhlIHVzZXIgdG8gdGhlIEJsb2Nrc3RhY2sgYnJvd3NlciB0byBhcHByb3ZlIHRoZSBzaWduIGluIHJlcXVlc3RcbiAgICogZ2l2ZW4uXG4gICAqXG4gICAqIFRoZSB1c2VyIGlzIHJlZGlyZWN0ZWQgdG8gdGhlIGF1dGhlbnRpY2F0b3IgVVJMIHNwZWNpZmllZCBpbiB0aGUgYEFwcENvbmZpZ2BcbiAgICogaWYgdGhlIGBibG9ja3N0YWNrOmAgcHJvdG9jb2wgaGFuZGxlciBpcyBub3QgZGV0ZWN0ZWQuXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIHByb3RvY29sIGhhbmRsZXIgZGV0ZWN0aW9uXG4gICAqIGRvZXMgbm90IHdvcmsgb24gYWxsIGJyb3dzZXJzLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGF1dGhSZXF1ZXN0IC0gdGhlIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgZ2VuZXJhdGVkIGJ5IGBtYWtlQXV0aFJlcXVlc3RgXG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0KGF1dGhSZXF1ZXN0OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdEltcGwodGhpcywgYXV0aFJlcXVlc3QpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgdGhhdCBjYW4gYmUgc2VudCB0byB0aGUgQmxvY2tzdGFja1xuICAgKiBicm93c2VyIGZvciB0aGUgdXNlciB0byBhcHByb3ZlIHNpZ24gaW4uIFRoaXMgYXV0aGVudGljYXRpb24gcmVxdWVzdCBjYW5cbiAgICogdGhlbiBiZSB1c2VkIGZvciBzaWduIGluIGJ5IHBhc3NpbmcgaXQgdG8gdGhlIGByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0YFxuICAgKiBtZXRob2QuXG4gICAqXG4gICAqICpOb3RlOiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIHJvbGwgeW91ciBvd24gYXV0aGVudGljYXRpb25cbiAgICogZmxvdy4gVHlwaWNhbGx5IHlvdSdkIHVzZSBgcmVkaXJlY3RUb1NpZ25JbmAgd2hpY2ggdGFrZXMgY2FyZSBvZiB0aGlzXG4gICAqIHVuZGVyIHRoZSBob29kLipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zaXRLZXkgLSBoZXgtZW5jb2RlZCB0cmFuc2l0IGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gZXhwaXJlc0F0IC0gdGhlIHRpbWUgYXQgd2hpY2ggdGhpcyByZXF1ZXN0IGlzIG5vIGxvbmdlciB2YWxpZFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmFQYXJhbXMgLSBBbnkgZXh0cmEgcGFyYW1ldGVycyB5b3UnZCBsaWtlIHRvIHBhc3MgdG8gdGhlIGF1dGhlbnRpY2F0b3IuXG4gICAqIFVzZSB0aGlzIHRvIHBhc3Mgb3B0aW9ucyB0aGF0IGFyZW4ndCBwYXJ0IG9mIHRoZSBCbG9ja3N0YWNrIGF1dGggc3BlYywgYnV0IG1pZ2h0IGJlIHN1cHBvcnRlZFxuICAgKiBieSBzcGVjaWFsIGF1dGhlbnRpY2F0b3JzLlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtYWtlQXV0aFJlcXVlc3QodHJhbnNpdEtleTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBudW1iZXIgPSBuZXh0SG91cigpLmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiBPYmplY3QgPSB7fSk6IHN0cmluZyB7XG4gICAgY29uc3QgYXBwQ29uZmlnID0gdGhpcy5hcHBDb25maWdcblxuICAgIGlmICghYXBwQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlRXJyb3IoJ01pc3NpbmcgQXBwQ29uZmlnJylcbiAgICB9XG4gICAgY29uc3QgcmVkaXJlY3RVUkkgPSBhcHBDb25maWcucmVkaXJlY3RVUkkoKVxuICAgIGNvbnN0IG1hbmlmZXN0VVJJID0gYXBwQ29uZmlnLm1hbmlmZXN0VVJJKClcbiAgICBjb25zdCBzY29wZXMgPSBhcHBDb25maWcuc2NvcGVzXG4gICAgY29uc3QgYXBwRG9tYWluID0gYXBwQ29uZmlnLmFwcERvbWFpblxuICAgIHJldHVybiBtYWtlQXV0aFJlcXVlc3RJbXBsKHRyYW5zaXRLZXksIHJlZGlyZWN0VVJJLCBtYW5pZmVzdFVSSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZXMsIGFwcERvbWFpbiwgZXhwaXJlc0F0LCBleHRyYVBhcmFtcylcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBFQ0RTQSBrZXlwYWlyIHRvXG4gICAqIHVzZSBhcyB0aGUgZXBoZW1lcmFsIGFwcCB0cmFuc2l0IHByaXZhdGUga2V5XG4gICAqIGFuZCBzdG9yZSBpbiB0aGUgc2Vzc2lvblxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBoZXggZW5jb2RlZCBwcml2YXRlIGtleVxuICAgKlxuICAgKi9cbiAgZ2VuZXJhdGVBbmRTdG9yZVRyYW5zaXRLZXkoKTogc3RyaW5nIHtcbiAgICBjb25zdCBzZXNzaW9uRGF0YSA9IHRoaXMuc3RvcmUuZ2V0U2Vzc2lvbkRhdGEoKVxuICAgIGNvbnN0IHRyYW5zaXRLZXkgPSBnZW5lcmF0ZVRyYW5zaXRLZXkoKVxuICAgIHNlc3Npb25EYXRhLnRyYW5zaXRLZXkgPSB0cmFuc2l0S2V5XG4gICAgdGhpcy5zdG9yZS5zZXRTZXNzaW9uRGF0YShzZXNzaW9uRGF0YSlcbiAgICByZXR1cm4gdHJhbnNpdEtleVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiBmcm9tIHRoZSBVUkwgcXVlcnlcbiAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgYXV0aGVudGljYXRpb24gdG9rZW4gaWYgaXQgZXhpc3RzIG90aGVyd2lzZSBgbnVsbGBcbiAgICovXG4gIGdldEF1dGhSZXNwb25zZVRva2VuKCk6IHN0cmluZyB7XG4gICAgY29uc3QgcXVlcnlEaWN0ID0gcXVlcnlTdHJpbmcucGFyc2UobG9jYXRpb24uc2VhcmNoKVxuICAgIHJldHVybiBxdWVyeURpY3QuYXV0aFJlc3BvbnNlID8gcXVlcnlEaWN0LmF1dGhSZXNwb25zZSA6ICcnXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlcmUgaXMgYSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IHRoYXQgaGFzbid0IGJlZW4gaGFuZGxlZC5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZXJlIGlzIGEgcGVuZGluZyBzaWduIGluLCBvdGhlcndpc2UgYGZhbHNlYFxuICAgKi9cbiAgaXNTaWduSW5QZW5kaW5nKCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0QXV0aFJlc3BvbnNlVG9rZW4oKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdXNlciBpcyBjdXJyZW50bHkgc2lnbmVkIGluLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHVzZXIgaXMgc2lnbmVkIGluLCBgZmFsc2VgIGlmIG5vdC5cbiAgICovXG4gIGlzVXNlclNpZ25lZEluKCkge1xuICAgIHJldHVybiAhIXRoaXMuc3RvcmUuZ2V0U2Vzc2lvbkRhdGEoKS51c2VyRGF0YVxuICB9XG5cbiAgLyoqXG4gICAqIFRyeSB0byBwcm9jZXNzIGFueSBwZW5kaW5nIHNpZ24gaW4gcmVxdWVzdCBieSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlc1xuICAgKiB0byB0aGUgdXNlciBkYXRhIG9iamVjdCBpZiB0aGUgc2lnbiBpbiBzdWNjZWVkcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF1dGhSZXNwb25zZVRva2VuIC0gdGhlIHNpZ25lZCBhdXRoZW50aWNhdGlvbiByZXNwb25zZSB0b2tlblxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHRvIHRoZSB1c2VyIGRhdGEgb2JqZWN0IGlmIHN1Y2Nlc3NmdWwgYW5kIHJlamVjdHNcbiAgICogaWYgaGFuZGxpbmcgdGhlIHNpZ24gaW4gcmVxdWVzdCBmYWlscyBvciB0aGVyZSB3YXMgbm8gcGVuZGluZyBzaWduIGluIHJlcXVlc3QuXG4gICAqL1xuICBoYW5kbGVQZW5kaW5nU2lnbkluKGF1dGhSZXNwb25zZVRva2VuOiBzdHJpbmcgPSB0aGlzLmdldEF1dGhSZXNwb25zZVRva2VuKCkpIHtcbiAgICByZXR1cm4gaGFuZGxlUGVuZGluZ1NpZ25JbkltcGwodGhpcywgYXV0aFJlc3BvbnNlVG9rZW4pXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgb2JqZWN0LiBUaGUgdXNlcidzIHByb2ZpbGUgaXMgc3RvcmVkIGluIHRoZSBrZXkgYHByb2ZpbGVgLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFVzZXIgZGF0YSBvYmplY3QuXG4gICAqL1xuICBsb2FkVXNlckRhdGEoKSB7XG4gICAgcmV0dXJuIGxvYWRVc2VyRGF0YUltcGwodGhpcylcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNpZ24gdGhlIHVzZXIgb3V0XG4gICAqIEByZXR1cm4ge3ZvaWR9XG4gICAqL1xuICBzaWduVXNlck91dCgpIHtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZVNlc3Npb25EYXRhKClcbiAgfVxuXG4gIC8vXG4gIC8vXG4gIC8vIC8qIFBST0ZJTEVTICovXG4gIC8vIGV4dHJhY3RQcm9maWxlXG4gIC8vIHdyYXBQcm9maWxlVG9rZW5cbiAgLy8gc2lnblByb2ZpbGVUb2tlblxuICAvLyB2ZXJpZnlQcm9maWxlVG9rZW5cbiAgLy8gdmFsaWRhdGVQcm9vZnNcbiAgLy8gbG9va3VwUHJvZmlsZVxuXG5cbiAgLyogU1RPUkFHRSAqL1xuXG4gIC8qKlxuICAgKiBFbmNyeXB0cyB0aGUgZGF0YSBwcm92aWRlZCB3aXRoIHRoZSBhcHAgcHVibGljIGtleS5cbiAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBjb250ZW50IC0gZGF0YSB0byBlbmNyeXB0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz1udWxsXSAtIG9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnB1YmxpY0tleSAtIHRoZSBoZXggc3RyaW5nIG9mIHRoZSBFQ0RTQSBwdWJsaWNcbiAgICoga2V5IHRvIHVzZSBmb3IgZW5jcnlwdGlvbi4gSWYgbm90IHByb3ZpZGVkLCB3aWxsIHVzZSB1c2VyJ3MgYXBwUHJpdmF0ZUtleS5cbiAgICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmdpZmllZCBjaXBoZXJ0ZXh0IG9iamVjdFxuICAgKi9cbiAgZW5jcnlwdENvbnRlbnQoY29udGVudDogc3RyaW5nIHwgQnVmZmVyLFxuICAgICAgICAgICAgICAgICBvcHRpb25zPzoge3B1YmxpY0tleT86IHN0cmluZ30pIHtcbiAgICByZXR1cm4gZW5jcnlwdENvbnRlbnRJbXBsKHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogRGVjcnlwdHMgZGF0YSBlbmNyeXB0ZWQgd2l0aCBgZW5jcnlwdENvbnRlbnRgIHdpdGggdGhlXG4gICAqIHRyYW5zaXQgcHJpdmF0ZSBrZXkuXG4gICAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gY29udGVudCAtIGVuY3J5cHRlZCBjb250ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9bnVsbF0gLSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcml2YXRlS2V5IC0gdGhlIGhleCBzdHJpbmcgb2YgdGhlIEVDRFNBIHByaXZhdGVcbiAgICoga2V5IHRvIHVzZSBmb3IgZGVjcnlwdGlvbi4gSWYgbm90IHByb3ZpZGVkLCB3aWxsIHVzZSB1c2VyJ3MgYXBwUHJpdmF0ZUtleS5cbiAgICogQHJldHVybiB7U3RyaW5nfEJ1ZmZlcn0gZGVjcnlwdGVkIGNvbnRlbnQuXG4gICAqL1xuICBkZWNyeXB0Q29udGVudChjb250ZW50OiBzdHJpbmcsIG9wdGlvbnM/OiB7cHJpdmF0ZUtleT86ID9zdHJpbmd9KSB7XG4gICAgcmV0dXJuIGRlY3J5cHRDb250ZW50SW1wbCh0aGlzLCBjb250ZW50LCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIFN0b3JlcyB0aGUgZGF0YSBwcm92aWRlZCBpbiB0aGUgYXBwJ3MgZGF0YSBzdG9yZSB0byB0byB0aGUgZmlsZSBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gc3RvcmUgdGhlIGRhdGEgaW5cbiAgICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBjb250ZW50IC0gdGhlIGRhdGEgdG8gc3RvcmUgaW4gdGhlIGZpbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPW51bGxdIC0gb3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuZW5jcnlwdD10cnVlXSAtIGVuY3J5cHQgdGhlIGRhdGEgd2l0aCB0aGUgYXBwIHByaXZhdGUga2V5XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB0aGUgcHJvdmlkZWQgcHVibGljIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNpZ249ZmFsc2VdIC0gc2lnbiB0aGUgZGF0YSB1c2luZyBFQ0RTQSBvbiBTSEEyNTYgaGFzaGVzIHdpdGhcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBhcHAgcHJpdmF0ZSBrZXlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyBpZiB0aGUgb3BlcmF0aW9uIHN1Y2NlZWQgYW5kIHJlamVjdHNcbiAgICogaWYgaXQgZmFpbGVkXG4gICAqL1xuICBwdXRGaWxlKHBhdGg6IHN0cmluZywgY29udGVudDogc3RyaW5nIHwgQnVmZmVyLCBvcHRpb25zPzogUHV0RmlsZU9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHV0RmlsZUltcGwodGhpcywgcGF0aCwgY29udGVudCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIHNwZWNpZmllZCBmaWxlIGZyb20gdGhlIGFwcCdzIGRhdGEgc3RvcmUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9bnVsbF0gLSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlY3J5cHQ9dHJ1ZV0gLSB0cnkgdG8gZGVjcnlwdCB0aGUgZGF0YSB3aXRoIHRoZSBhcHAgcHJpdmF0ZSBrZXlcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMudXNlcm5hbWUgLSB0aGUgQmxvY2tzdGFjayBJRCB0byBsb29rdXAgZm9yIG11bHRpLXBsYXllciBzdG9yYWdlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy52ZXJpZnkgLSBXaGV0aGVyIHRoZSBjb250ZW50IHNob3VsZCBiZSB2ZXJpZmllZCwgb25seSB0byBiZSB1c2VkXG4gICAqIHdoZW4gYHB1dEZpbGVgIHdhcyBzZXQgdG8gYHNpZ24gPSB0cnVlYFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5hcHAgLSB0aGUgYXBwIHRvIGxvb2t1cCBmb3IgbXVsdGktcGxheWVyIHN0b3JhZ2UgLVxuICAgKiBkZWZhdWx0cyB0byBjdXJyZW50IG9yaWdpblxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuem9uZUZpbGVMb29rdXBVUkw9bnVsbF0gLSBUaGUgVVJMXG4gICAqIHRvIHVzZSBmb3Igem9uZWZpbGUgbG9va3VwLiBJZiBmYWxzZXksIHRoaXMgd2lsbCB1c2UgdGhlXG4gICAqIGJsb2Nrc3RhY2suanMncyBnZXROYW1lSW5mbyBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB0byB0aGUgcmF3IGRhdGEgaW4gdGhlIGZpbGVcbiAgICogb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG4gICAqL1xuICBnZXRGaWxlKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IHtcbiAgICAgIGRlY3J5cHQ/OiBib29sZWFuLFxuICAgICAgdmVyaWZ5PzogYm9vbGVhbixcbiAgICAgIHVzZXJuYW1lPzogc3RyaW5nLFxuICAgICAgYXBwPzogc3RyaW5nLFxuICAgICAgem9uZUZpbGVMb29rdXBVUkw/OiA/c3RyaW5nXG4gICAgfSkge1xuICAgIHJldHVybiBnZXRGaWxlSW1wbCh0aGlzLCBwYXRoLCBvcHRpb25zKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgVVJMIGZvciByZWFkaW5nIGEgZmlsZSBmcm9tIGFuIGFwcCdzIGRhdGEgc3RvcmUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9bnVsbF0gLSBvcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51c2VybmFtZSAtIHRoZSBCbG9ja3N0YWNrIElEIHRvIGxvb2t1cCBmb3IgbXVsdGktcGxheWVyIHN0b3JhZ2VcbiAgICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBwIC0gdGhlIGFwcCB0byBsb29rdXAgZm9yIG11bHRpLXBsYXllciBzdG9yYWdlIC1cbiAgICogZGVmYXVsdHMgdG8gY3VycmVudCBvcmlnaW5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnpvbmVGaWxlTG9va3VwVVJMPW51bGxdIC0gVGhlIFVSTFxuICAgKiB0byB1c2UgZm9yIHpvbmVmaWxlIGxvb2t1cC4gSWYgZmFsc2V5LCB0aGlzIHdpbGwgdXNlIHRoZVxuICAgKiBibG9ja3N0YWNrLmpzJ3MgZ2V0TmFtZUluZm8gZnVuY3Rpb24gaW5zdGVhZC5cbiAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gdGhhdCByZXNvbHZlcyB0byB0aGUgVVJMIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuICAgKi9cbiAgZ2V0RmlsZVVybChwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7XG4gICAgdXNlcm5hbWU/OiBzdHJpbmcsXG4gICAgYXBwPzogc3RyaW5nLFxuICAgIHpvbmVGaWxlTG9va3VwVVJMPzogP3N0cmluZ1xuICB9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gZ2V0RmlsZVVybEltcGwodGhpcywgcGF0aCwgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBMaXN0IHRoZSBzZXQgb2YgZmlsZXMgaW4gdGhpcyBhcHBsaWNhdGlvbidzIEdhaWEgc3RvcmFnZSBidWNrZXQuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gYSBjYWxsYmFjayB0byBpbnZva2Ugb24gZWFjaCBuYW1lZCBmaWxlIHRoYXRcbiAgICogcmV0dXJucyBgdHJ1ZWAgdG8gY29udGludWUgdGhlIGxpc3Rpbmcgb3BlcmF0aW9uIG9yIGBmYWxzZWAgdG8gZW5kIGl0XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBmaWxlcyBsaXN0ZWRcbiAgICovXG4gIGxpc3RGaWxlcyhjYWxsYmFjazogKG5hbWU6IHN0cmluZykgPT4gYm9vbGVhbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBsaXN0RmlsZXNJbXBsKHRoaXMsIGNhbGxiYWNrKVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGhlIHNwZWNpZmllZCBmaWxlIGZyb20gdGhlIGFwcCdzIGRhdGEgc3RvcmUuIEN1cnJlbnRseSBub3QgaW1wbGVtZW50ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gZGVsZXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGZpbGUgaGFzIGJlZW4gcmVtb3ZlZFxuICAgKiBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlbGV0ZUZpbGUocGF0aDogc3RyaW5nKSB7XG4gICAgUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBEZWxldGUgb2YgJHtwYXRofSBub3Qgc3VwcG9ydGVkIGJ5IGdhaWEgaHVic2ApKVxuICB9XG59XG4iXX0=