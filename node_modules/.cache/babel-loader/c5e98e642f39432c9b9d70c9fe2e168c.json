{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.generateTransitKey = generateTransitKey;\nexports.makeAuthRequestImpl = makeAuthRequestImpl;\nexports.encryptPrivateKey = encryptPrivateKey;\nexports.decryptPrivateKey = decryptPrivateKey;\nexports.makeAuthResponse = makeAuthResponse;\n\nrequire(\"cross-fetch/polyfill\");\n\nvar _jsontokens = require(\"jsontokens\");\n\nvar _index = require(\"../index\");\n\nvar _ec = require(\"../encryption/ec\");\n\nvar _logger = require(\"../logger\");\n\nvar VERSION = '1.3.1';\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n */\n\nfunction generateTransitKey() {\n  var transitKey = (0, _index.makeECPrivateKey)();\n  return transitKey;\n}\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n * @private\n */\n\n\nfunction makeAuthRequestImpl(transitPrivateKey, redirectURI, manifestURI, scopes) {\n  var appDomain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : window.location.origin;\n  var expiresAt = arguments.length > 5 ? arguments[5] : undefined;\n  var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n\n  /* Create the payload */\n  var payload = Object.assign({}, extraParams, {\n    jti: (0, _index.makeUUID4)(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000),\n    // JWT times are in seconds\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes: scopes\n  });\n\n  _logger.Logger.info(\"blockstack.js: generating v\".concat(VERSION, \" auth request\"));\n  /* Convert the private key to a public key to an issuer */\n\n\n  var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(transitPrivateKey);\n\n  payload.public_keys = [publicKey];\n  var address = (0, _index.publicKeyToAddress)(publicKey);\n  payload.iss = (0, _index.makeDIDFromAddress)(address);\n  /* Sign and return the token */\n\n  var tokenSigner = new _jsontokens.TokenSigner('ES256k', transitPrivateKey);\n  var token = tokenSigner.sign(payload);\n  return token;\n}\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n */\n\n\nfunction encryptPrivateKey(publicKey, privateKey) {\n  var encryptedObj = (0, _ec.encryptECIES)(publicKey, privateKey);\n  var encryptedJSON = JSON.stringify(encryptedObj);\n  return new Buffer(encryptedJSON).toString('hex');\n}\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n */\n\n\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n  var unhexedString = new Buffer(hexedEncrypted, 'hex').toString();\n  var encryptedObj = JSON.parse(unhexedString);\n  var decrypted = (0, _ec.decryptECIES)(privateKey, encryptedObj);\n\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n */\n\n\nfunction makeAuthResponse(privateKey) {\n  var profile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var username = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var metadata = arguments.length > 3 ? arguments[3] : undefined;\n  var coreToken = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n  var appPrivateKey = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  var expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : (0, _index.nextMonth)().getTime();\n  var transitPublicKey = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;\n  var hubUrl = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;\n  var blockstackAPIUrl = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;\n  var associationToken = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : null;\n\n  /* Convert the private key to a public key to an issuer */\n  var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(privateKey);\n\n  var address = (0, _index.publicKeyToAddress)(publicKey);\n  /* See if we should encrypt with the transit key */\n\n  var privateKeyPayload = appPrivateKey;\n  var coreTokenPayload = coreToken;\n  var additionalProperties = {};\n\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    _logger.Logger.info(\"blockstack.js: generating v\".concat(VERSION, \" auth response\"));\n\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n\n    additionalProperties = {\n      email: metadata.email ? metadata.email : null,\n      profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n      hubUrl: hubUrl,\n      blockstackAPIUrl: blockstackAPIUrl,\n      associationToken: associationToken,\n      version: VERSION\n    };\n  } else {\n    _logger.Logger.info('blockstack.js: generating legacy auth response');\n  }\n  /* Create the payload */\n\n\n  var payload = Object.assign({}, {\n    jti: (0, _index.makeUUID4)(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    // JWT times are in seconds\n    exp: Math.floor(expiresAt / 1000),\n    // JWT times are in seconds\n    iss: (0, _index.makeDIDFromAddress)(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    profile: profile,\n    username: username,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  /* Sign and return the token */\n\n  var tokenSigner = new _jsontokens.TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}","map":null,"metadata":{},"sourceType":"script"}