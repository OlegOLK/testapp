{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.hash160 = hash160;\nexports.hash128 = hash128;\nexports.estimateTXBytes = estimateTXBytes;\nexports.sumOutputValues = sumOutputValues;\nexports.decodeB40 = decodeB40;\nexports.addUTXOsToFund = addUTXOsToFund;\nexports.signInputs = signInputs;\nexports.DUST_MINIMUM = void 0;\n\nvar _bitcoinjsLib = _interopRequireDefault(require(\"bitcoinjs-lib\"));\n\nvar _ripemd = _interopRequireDefault(require(\"ripemd160\"));\n\nvar _bigi = _interopRequireDefault(require(\"bigi\"));\n\nvar _errors = require(\"../errors\");\n\nvar _signers = require(\"./signers\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar DUST_MINIMUM = 5500;\nexports.DUST_MINIMUM = DUST_MINIMUM;\n\nfunction hash160(buff) {\n  var sha256 = _bitcoinjsLib.default.crypto.sha256(buff);\n\n  return new _ripemd.default().update(sha256).digest();\n}\n\nfunction hash128(buff) {\n  return Buffer.from(_bitcoinjsLib.default.crypto.sha256(buff).slice(0, 16));\n} // COPIED FROM coinselect, because 1 byte matters sometimes.\n// baseline estimates, used to improve performance\n\n\nvar TX_EMPTY_SIZE = 4 + 1 + 1 + 4;\nvar TX_INPUT_BASE = 32 + 4 + 1 + 4;\nvar TX_INPUT_PUBKEYHASH = 107;\nvar TX_OUTPUT_BASE = 8 + 1;\nvar TX_OUTPUT_PUBKEYHASH = 25;\n\nfunction inputBytes(input) {\n  if (input && input.script && input.script.length > 0) {\n    return TX_INPUT_BASE + input.script.length;\n  } else {\n    return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;\n  }\n}\n\nfunction outputBytes(output) {\n  if (output && output.script && output.script.length > 0) {\n    return TX_OUTPUT_BASE + output.script.length;\n  } else {\n    return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;\n  }\n}\n\nfunction transactionBytes(inputs, outputs) {\n  return TX_EMPTY_SIZE + inputs.reduce(function (a, x) {\n    return a + inputBytes(x);\n  }, 0) + outputs.reduce(function (a, x) {\n    return a + outputBytes(x);\n  }, 0);\n} //\n\n\nfunction estimateTXBytes(txIn, additionalInputs, additionalOutputs) {\n  var innerTx = txIn;\n\n  if (txIn instanceof _bitcoinjsLib.default.TransactionBuilder) {\n    innerTx = txIn.__tx;\n  }\n\n  var dummyInputs = new Array(additionalInputs);\n  dummyInputs.fill(null);\n  var dummyOutputs = new Array(additionalOutputs);\n  dummyOutputs.fill(null);\n  var inputs = [].concat(innerTx.ins, dummyInputs);\n  var outputs = [].concat(innerTx.outs, dummyOutputs);\n  return transactionBytes(inputs, outputs);\n}\n\nfunction sumOutputValues(txIn) {\n  var innerTx = txIn;\n\n  if (txIn instanceof _bitcoinjsLib.default.TransactionBuilder) {\n    innerTx = txIn.__tx;\n  }\n\n  return innerTx.outs.reduce(function (agg, x) {\n    return agg + x.value;\n  }, 0);\n}\n\nfunction decodeB40(input) {\n  // treat input as a base40 integer, and output a hex encoding\n  // of that integer.\n  //\n  //   for each digit of the string, find its location in `characters`\n  //    to get the value of the digit, then multiply by 40^(-index in input)\n  // e.g.,\n  // the 'right-most' character has value: (digit-value) * 40^0\n  //  the next character has value: (digit-value) * 40^1\n  //\n  // hence, we reverse the characters first, and use the index\n  //  to compute the value of each digit, then sum\n  var characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';\n\n  var base = _bigi.default.valueOf(40);\n\n  var inputDigits = input.split('').reverse();\n  var digitValues = inputDigits.map(function (character, exponent) {\n    return _bigi.default.valueOf(characters.indexOf(character)).multiply(base.pow(_bigi.default.valueOf(exponent)));\n  });\n  var sum = digitValues.reduce(function (agg, cur) {\n    return agg.add(cur);\n  }, _bigi.default.ZERO);\n  return sum.toHex();\n}\n/**\n * Adds UTXOs to fund a transaction\n * @param {TransactionBuilder} txBuilderIn - a transaction builder object to add the inputs to. this\n *    object is _always_ mutated. If not enough UTXOs exist to fund, the tx builder object\n *    will still contain as many inputs as could be found.\n * @param {Array<{value: number, tx_hash: string, tx_output_n}>} utxos - the utxo set for the\n *    payer's address.\n * @param {number} amountToFund - the amount of satoshis to fund in the transaction. the payer's\n *    utxos will be included to fund up to this amount of *output* and the corresponding *fees*\n *    for those additional inputs\n * @param {number} feeRate - the satoshis/byte fee rate to use for fee calculation\n * @param {boolean} fundNewFees - if true, this function will fund `amountToFund` and any new fees\n *    associated with including the new inputs.\n *    if false, this function will fund _at most_ `amountToFund`\n * @returns {number} - the amount of leftover change (in satoshis)\n * @private\n */\n\n\nfunction addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate) {\n  var fundNewFees = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n  if (utxos.length === 0) {\n    throw new _errors.NotEnoughFundsError(amountToFund);\n  } // how much are we increasing fees by adding an input ?\n\n\n  var newFees = feeRate * (estimateTXBytes(txBuilderIn, 1, 0) - estimateTXBytes(txBuilderIn, 0, 0));\n  var utxoThreshhold = amountToFund;\n\n  if (fundNewFees) {\n    utxoThreshhold += newFees;\n  }\n\n  var goodUtxos = utxos.filter(function (utxo) {\n    return utxo.value >= utxoThreshhold;\n  });\n\n  if (goodUtxos.length > 0) {\n    goodUtxos.sort(function (a, b) {\n      return a.value - b.value;\n    });\n    var selected = goodUtxos[0];\n    var change = selected.value - amountToFund;\n\n    if (fundNewFees) {\n      change -= newFees;\n    }\n\n    txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);\n    return change;\n  } else {\n    utxos.sort(function (a, b) {\n      return b.value - a.value;\n    });\n    var largest = utxos[0];\n\n    if (newFees >= largest.value) {\n      throw new _errors.NotEnoughFundsError(amountToFund);\n    }\n\n    txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);\n    var remainToFund = amountToFund - largest.value;\n\n    if (fundNewFees) {\n      remainToFund += newFees;\n    }\n\n    return addUTXOsToFund(txBuilderIn, utxos.slice(1), remainToFund, feeRate, fundNewFees);\n  }\n}\n\nfunction signInputs(txB, defaultSigner, otherSigners) {\n  var signerArray = txB.__tx.ins.map(function () {\n    return defaultSigner;\n  });\n\n  if (otherSigners) {\n    otherSigners.forEach(function (signerPair) {\n      signerArray[signerPair.index] = signerPair.signer;\n    });\n  }\n\n  var signingPromise = Promise.resolve();\n\n  var _loop = function _loop(i) {\n    signingPromise = signingPromise.then(function () {\n      return signerArray[i].signTransaction(txB, i);\n    });\n  };\n\n  for (var i = 0; i < txB.__tx.ins.length; i++) {\n    _loop(i);\n  }\n\n  return signingPromise.then(function () {\n    return txB;\n  });\n}","map":null,"metadata":{},"sourceType":"script"}