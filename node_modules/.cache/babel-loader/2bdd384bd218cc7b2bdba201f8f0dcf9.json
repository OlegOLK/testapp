{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getHexFromBN = getHexFromBN;\nexports.encryptECIES = encryptECIES;\nexports.decryptECIES = decryptECIES;\nexports.signECDSA = signECDSA;\nexports.verifyECDSA = verifyECDSA;\n\nvar _elliptic = require(\"elliptic\");\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _keys = require(\"../keys\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ecurve = new _elliptic.ec('secp256k1');\n\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n  var cipher = _crypto.default.createCipheriv('aes-256-cbc', key, iv);\n\n  return Buffer.concat([cipher.update(plaintext), cipher.final()]);\n}\n\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n  var cipher = _crypto.default.createDecipheriv('aes-256-cbc', key, iv);\n\n  return Buffer.concat([cipher.update(ciphertext), cipher.final()]);\n}\n\nfunction hmacSha256(key, content) {\n  return _crypto.default.createHmac('sha256', key).update(content).digest();\n}\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  var res = 0;\n\n  for (var i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n\nfunction sharedSecretToKeys(sharedSecret) {\n  // generate mac and encryption key from shared secret\n  var hashedSecret = _crypto.default.createHash('sha512').update(sharedSecret).digest();\n\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n\nfunction getHexFromBN(bnInput) {\n  var hexOut = bnInput.toString('hex');\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    var padding = '0'.repeat(64 - hexOut.length);\n    return \"\".concat(padding).concat(hexOut);\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param {String} publicKey - secp256k1 public key hex string\n * @param {String | Buffer} content - content to encrypt\n * @return {Object} Object containing (hex encoded):\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeral public key\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n *  @private\n */\n\n\nfunction encryptECIES(publicKey, content) {\n  var isString = typeof content === 'string';\n  var plainText = Buffer.from(content); // always copy to buffer\n\n  var ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  var ephemeralSK = ecurve.genKeyPair();\n  var ephemeralPK = ephemeralSK.getPublic();\n  var sharedSecret = ephemeralSK.derive(ecPK);\n  var sharedSecretHex = getHexFromBN(sharedSecret);\n  var sharedKeys = sharedSecretToKeys(new Buffer(sharedSecretHex, 'hex'));\n\n  var initializationVector = _crypto.default.randomBytes(16);\n\n  var cipherText = aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, plainText);\n  var macData = Buffer.concat([initializationVector, new Buffer(ephemeralPK.encodeCompressed()), cipherText]);\n  var mac = hmacSha256(sharedKeys.hmacKey, macData);\n  return {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.encodeCompressed('hex'),\n    cipherText: cipherText.toString('hex'),\n    mac: mac.toString('hex'),\n    wasString: isString\n  };\n}\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {Error} if unable to decrypt\n * @private\n */\n\n\nfunction decryptECIES(privateKey, cipherObject) {\n  var ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  var ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  var sharedSecret = ecSK.derive(ephemeralPK);\n  var sharedSecretBuffer = new Buffer(getHexFromBN(sharedSecret), 'hex');\n  var sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n  var ivBuffer = new Buffer(cipherObject.iv, 'hex');\n  var cipherTextBuffer = new Buffer(cipherObject.cipherText, 'hex');\n  var macData = Buffer.concat([ivBuffer, new Buffer(ephemeralPK.encodeCompressed()), cipherTextBuffer]);\n  var actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  var expectedMac = new Buffer(cipherObject.mac, 'hex');\n\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new Error('Decryption failed: failure in MAC check');\n  }\n\n  var plainText = aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n/**\n * Sign content using ECDSA\n * @private\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n */\n\n\nfunction signECDSA(privateKey, content) {\n  var contentBuffer = Buffer.from(content);\n  var ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  var publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);\n\n  var contentHash = _crypto.default.createHash('sha256').update(contentBuffer).digest();\n\n  var signature = ecPrivate.sign(contentHash);\n  var signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey: publicKey\n  };\n}\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n */\n\n\nfunction verifyECDSA(content, publicKey, signature) {\n  var contentBuffer = Buffer.from(content);\n  var ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n\n  var contentHash = _crypto.default.createHash('sha256').update(contentBuffer).digest();\n\n  return ecPublic.verify(contentHash, signature);\n}","map":null,"metadata":{},"sourceType":"script"}