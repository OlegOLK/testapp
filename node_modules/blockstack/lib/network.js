"use strict";

exports.__esModule = true;
exports.network = exports.BlockchainInfoApi = exports.InsightClient = exports.BitcoindAPI = exports.LocalRegtest = exports.BlockstackNetwork = exports.BitcoinNetwork = void 0;

var _bitcoinjsLib = _interopRequireDefault(require("bitcoinjs-lib"));

var _formData = _interopRequireDefault(require("form-data"));

var _bigi = _interopRequireDefault(require("bigi"));

var _ripemd = _interopRequireDefault(require("ripemd160"));

var _errors = require("./errors");

var _logger = require("./logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const SATOSHIS_PER_BTC = 1e8;
const TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';
const TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';
const TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';

class BitcoinNetwork {
  broadcastTransaction(transaction) {
    return Promise.reject(new Error(`Not implemented, broadcastTransaction(${transaction})`));
  }

  getBlockHeight() {
    return Promise.reject(new Error('Not implemented, getBlockHeight()'));
  }

  getTransactionInfo(txid) {
    return Promise.reject(new Error(`Not implemented, getTransactionInfo(${txid})`));
  }

  getNetworkedUTXOs(address) {
    return Promise.reject(new Error(`Not implemented, getNetworkedUTXOs(${address})`));
  }

}

exports.BitcoinNetwork = BitcoinNetwork;

class BlockstackNetwork {
  constructor(apiUrl, broadcastServiceUrl, bitcoinAPI, network = _bitcoinjsLib.default.networks.bitcoin) {
    this.blockstackAPIUrl = apiUrl;
    this.broadcastServiceUrl = broadcastServiceUrl;
    this.layer1 = network;
    this.btc = bitcoinAPI;
    this.DUST_MINIMUM = 5500;
    this.includeUtxoMap = {};
    this.excludeUtxoSet = [];
    this.MAGIC_BYTES = 'id';
  }

  coerceAddress(address) {
    const {
      hash,
      version
    } = _bitcoinjsLib.default.address.fromBase58Check(address);

    const scriptHashes = [_bitcoinjsLib.default.networks.bitcoin.scriptHash, _bitcoinjsLib.default.networks.testnet.scriptHash];
    const pubKeyHashes = [_bitcoinjsLib.default.networks.bitcoin.pubKeyHash, _bitcoinjsLib.default.networks.testnet.pubKeyHash];
    let coercedVersion;

    if (scriptHashes.indexOf(version) >= 0) {
      coercedVersion = this.layer1.scriptHash;
    } else if (pubKeyHashes.indexOf(version) >= 0) {
      coercedVersion = this.layer1.pubKeyHash;
    } else {
      throw new Error(`Unrecognized address version number ${version} in ${address}`);
    }

    return _bitcoinjsLib.default.address.toBase58Check(hash, coercedVersion);
  }

  getDefaultBurnAddress() {
    return this.coerceAddress('1111111111111111111114oLvT2');
  }
  /**
   * Get the price of a name via the legacy /v1/prices API endpoint.
   * @param {String} fullyQualifiedName the name to query
   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }
   * @private
   */


  getNamePriceV1(fullyQualifiedName) {
    // legacy code path
    return fetch(`${this.blockstackAPIUrl}/v1/prices/names/${fullyQualifiedName}`).then(resp => {
      if (!resp.ok) {
        throw new Error(`Failed to query name price for ${fullyQualifiedName}`);
      }

      return resp;
    }).then(resp => resp.json()).then(resp => resp.name_price).then(namePrice => {
      if (!namePrice || !namePrice.satoshis) {
        throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);
      }

      if (namePrice.satoshis < this.DUST_MINIMUM) {
        namePrice.satoshis = this.DUST_MINIMUM;
      }

      const result = {
        units: 'BTC',
        amount: _bigi.default.fromByteArrayUnsigned(String(namePrice.satoshis))
      };
      return result;
    });
  }
  /**
   * Get the price of a namespace via the legacy /v1/prices API endpoint.
   * @param {String} namespaceID the namespace to query
   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }
   * @private
   */


  getNamespacePriceV1(namespaceID) {
    // legacy code path
    return fetch(`${this.blockstackAPIUrl}/v1/prices/namespaces/${namespaceID}`).then(resp => {
      if (!resp.ok) {
        throw new Error(`Failed to query name price for ${namespaceID}`);
      }

      return resp;
    }).then(resp => resp.json()).then(namespacePrice => {
      if (!namespacePrice || !namespacePrice.satoshis) {
        throw new Error(`Failed to get price for ${namespaceID}`);
      }

      if (namespacePrice.satoshis < this.DUST_MINIMUM) {
        namespacePrice.satoshis = this.DUST_MINIMUM;
      }

      const result = {
        units: 'BTC',
        amount: _bigi.default.fromByteArrayUnsigned(String(namespacePrice.satoshis))
      };
      return result;
    });
  }
  /**
   * Get the price of a name via the /v2/prices API endpoint.
   * @param {String} fullyQualifiedName the name to query
   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }
   * @private
   */


  getNamePriceV2(fullyQualifiedName) {
    return fetch(`${this.blockstackAPIUrl}/v2/prices/names/${fullyQualifiedName}`).then(resp => {
      if (resp.status !== 200) {
        // old core node 
        throw new Error('The upstream node does not handle the /v2/ price namespace');
      }

      return resp;
    }).then(resp => resp.json()).then(resp => resp.name_price).then(namePrice => {
      if (!namePrice) {
        throw new Error(`Failed to get price for ${fullyQualifiedName}. Does the namespace exist?`);
      }

      const result = {
        units: namePrice.units,
        amount: _bigi.default.fromByteArrayUnsigned(namePrice.amount)
      };

      if (namePrice.units === 'BTC') {
        // must be at least dust-minimum
        const dustMin = _bigi.default.fromByteArrayUnsigned(String(this.DUST_MINIMUM));

        if (result.amount.compareTo(dustMin) < 0) {
          result.amount = dustMin;
        }
      }

      return result;
    });
  }
  /**
   * Get the price of a namespace via the /v2/prices API endpoint.
   * @param {String} namespaceID the namespace to query
   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }
   * @private
   */


  getNamespacePriceV2(namespaceID) {
    return fetch(`${this.blockstackAPIUrl}/v2/prices/namespaces/${namespaceID}`).then(resp => {
      if (resp.status !== 200) {
        // old core node 
        throw new Error('The upstream node does not handle the /v2/ price namespace');
      }

      return resp;
    }).then(resp => resp.json()).then(namespacePrice => {
      if (!namespacePrice) {
        throw new Error(`Failed to get price for ${namespaceID}`);
      }

      const result = {
        units: namespacePrice.units,
        amount: _bigi.default.fromByteArrayUnsigned(namespacePrice.amount)
      };

      if (namespacePrice.units === 'BTC') {
        // must be at least dust-minimum
        const dustMin = _bigi.default.fromByteArrayUnsigned(String(this.DUST_MINIMUM));

        if (result.amount.compareTo(dustMin) < 0) {
          result.amount = dustMin;
        }
      }

      return result;
    });
  }
  /**
   * Get the price of a name.
   * @param {String} fullyQualifiedName the name to query
   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where
   *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and
   *   .amount encodes the number of units, in the smallest denominiated amount
   *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS, 
   *   .amount will be microStacks)
   */


  getNamePrice(fullyQualifiedName) {
    // handle v1 or v2 
    return Promise.resolve().then(() => this.getNamePriceV2(fullyQualifiedName)).catch(() => this.getNamePriceV1(fullyQualifiedName));
  }
  /**
   * Get the price of a namespace
   * @param {String} namespaceID the namespace to query
   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where
   *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and
   *   .amount encodes the number of units, in the smallest denominiated amount
   *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS, 
   *   .amount will be microStacks)
   */


  getNamespacePrice(namespaceID) {
    // handle v1 or v2 
    return Promise.resolve().then(() => this.getNamespacePriceV2(namespaceID)).catch(() => this.getNamespacePriceV1(namespaceID));
  }
  /**
   * How many blocks can pass between a name expiring and the name being able to be
   * re-registered by a different owner?
   * @return {Promise} a promise to the number of blocks
   */


  getGracePeriod() {
    return Promise.resolve(5000);
  }
  /**
   * Get the names -- both on-chain and off-chain -- owned by an address.
   * @param {String} address the blockchain address (the hash of the owner public key)
   * @return {Promise} a promise that resolves to a list of names (Strings)
   */


  getNamesOwned(address) {
    const networkAddress = this.coerceAddress(address);
    return fetch(`${this.blockstackAPIUrl}/v1/addresses/bitcoin/${networkAddress}`).then(resp => resp.json()).then(obj => obj.names);
  }
  /**
   * Get the blockchain address to which a name's registration fee must be sent
   * (the address will depend on the namespace in which it is registered.)
   * @param {String} namespace the namespace ID
   * @return {Promise} a promise that resolves to an address (String)
   */


  getNamespaceBurnAddress(namespace) {
    return Promise.all([fetch(`${this.blockstackAPIUrl}/v1/namespaces/${namespace}`), this.getBlockHeight()]).then(([resp, blockHeight]) => {
      if (resp.status === 404) {
        throw new Error(`No such namespace '${namespace}'`);
      } else {
        return Promise.all([resp.json(), blockHeight]);
      }
    }).then(([namespaceInfo, blockHeight]) => {
      let address = this.getDefaultBurnAddress();

      if (namespaceInfo.version === 2) {
        // pay-to-namespace-creator if this namespace is less than 1 year old
        if (namespaceInfo.reveal_block + 52595 >= blockHeight) {
          address = namespaceInfo.address;
        }
      }

      return address;
    }).then(address => this.coerceAddress(address));
  }
  /**
   * Get WHOIS-like information for a name, including the address that owns it,
   * the block at which it expires, and the zone file anchored to it (if available).
   * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.
   * @return {Promise} a promise that resolves to the WHOIS-like information 
   */


  getNameInfo(fullyQualifiedName) {
    _logger.Logger.debug(this.blockstackAPIUrl);

    const nameLookupURL = `${this.blockstackAPIUrl}/v1/names/${fullyQualifiedName}`;
    return fetch(nameLookupURL).then(resp => {
      if (resp.status === 404) {
        throw new Error('Name not found');
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(nameInfo => {
      _logger.Logger.debug(`nameInfo: ${JSON.stringify(nameInfo)}`); // the returned address _should_ be in the correct network ---
      //  blockstackd gets into trouble because it tries to coerce back to mainnet
      //  and the regtest transaction generation libraries want to use testnet addresses


      if (nameInfo.address) {
        return Object.assign({}, nameInfo, {
          address: this.coerceAddress(nameInfo.address)
        });
      } else {
        return nameInfo;
      }
    });
  }
  /**
   * Get the pricing parameters and creation history of a namespace.
   * @param {String} namespaceID the namespace to query
   * @return {Promise} a promise that resolves to the namespace information.
   */


  getNamespaceInfo(namespaceID) {
    return fetch(`${this.blockstackAPIUrl}/v1/namespaces/${namespaceID}`).then(resp => {
      if (resp.status === 404) {
        throw new Error('Namespace not found');
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(namespaceInfo => {
      // the returned address _should_ be in the correct network ---
      //  blockstackd gets into trouble because it tries to coerce back to mainnet
      //  and the regtest transaction generation libraries want to use testnet addresses
      if (namespaceInfo.address && namespaceInfo.recipient_address) {
        return Object.assign({}, namespaceInfo, {
          address: this.coerceAddress(namespaceInfo.address),
          recipient_address: this.coerceAddress(namespaceInfo.recipient_address)
        });
      } else {
        return namespaceInfo;
      }
    });
  }
  /**
   * Get a zone file, given its hash.  Throws an exception if the zone file
   * obtained does not match the hash.
   * @param {String} zonefileHash the ripemd160(sha256) hash of the zone file
   * @return {Promise} a promise that resolves to the zone file's text
   */


  getZonefile(zonefileHash) {
    return fetch(`${this.blockstackAPIUrl}/v1/zonefiles/${zonefileHash}`).then(resp => {
      if (resp.status === 200) {
        return resp.text().then(body => {
          const sha256 = _bitcoinjsLib.default.crypto.sha256(body);

          const h = new _ripemd.default().update(sha256).digest('hex');

          if (h !== zonefileHash) {
            throw new Error(`Zone file contents hash to ${h}, not ${zonefileHash}`);
          }

          return body;
        });
      } else {
        throw new Error(`Bad response status: ${resp.status}`);
      }
    });
  }
  /**
   * Get the status of an account for a particular token holding.  This includes its total number of
   * expenditures and credits, lockup times, last txid, and so on.
   * @param {String} address the account
   * @param {String} tokenType the token type to query
   * @return {Promise} a promise that resolves to an object representing the state of the account
   *   for this token
   */


  getAccountStatus(address, tokenType) {
    return fetch(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/status`).then(resp => {
      if (resp.status === 404) {
        throw new Error('Account not found');
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(accountStatus => {
      // coerce all addresses, and convert credit/debit to biginteger
      const formattedStatus = Object.assign({}, accountStatus, {
        address: this.coerceAddress(accountStatus.address),
        debit_value: _bigi.default.fromByteArrayUnsigned(String(accountStatus.debit_value)),
        credit_value: _bigi.default.fromByteArrayUnsigned(String(accountStatus.credit_value))
      });
      return formattedStatus;
    });
  }
  /**
   * Get a page of an account's transaction history.
   * @param {String} address the account's address
   * @param {number} page the page number.  Page 0 is the most recent transactions
   * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes
   *   states of the account at various block heights (e.g. prior balances, txids, etc)
   */


  getAccountHistoryPage(address, page) {
    const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history?page=${page}`;
    return fetch(url).then(resp => {
      if (resp.status === 404) {
        throw new Error('Account not found');
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(historyList => {
      if (historyList.error) {
        throw new Error(`Unable to get account history page: ${historyList.error}`);
      } // coerse all addresses and convert to bigint


      return historyList.map(histEntry => {
        histEntry.address = this.coerceAddress(histEntry.address);
        histEntry.debit_value = _bigi.default.fromByteArrayUnsigned(String(histEntry.debit_value));
        histEntry.credit_value = _bigi.default.fromByteArrayUnsigned(String(histEntry.credit_value));
        return histEntry;
      });
    });
  }
  /**
   * Get the state(s) of an account at a particular block height.  This includes the state of the
   * account beginning with this block's transactions, as well as all of the states the account
   * passed through when this block was processed (if any).
   * @param {String} address the account's address
   * @param {Integer} blockHeight the block to query
   * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes
   *   states of the account at this block.
   */


  getAccountAt(address, blockHeight) {
    const url = `${this.blockstackAPIUrl}/v1/accounts/${address}/history/${blockHeight}`;
    return fetch(url).then(resp => {
      if (resp.status === 404) {
        throw new Error('Account not found');
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(historyList => {
      if (historyList.error) {
        throw new Error(`Unable to get historic account state: ${historyList.error}`);
      } // coerce all addresses 


      return historyList.map(histEntry => {
        histEntry.address = this.coerceAddress(histEntry.address);
        histEntry.debit_value = _bigi.default.fromByteArrayUnsigned(String(histEntry.debit_value));
        histEntry.credit_value = _bigi.default.fromByteArrayUnsigned(String(histEntry.credit_value));
        return histEntry;
      });
    });
  }
  /**
   * Get the set of token types that this account owns
   * @param {String} address the account's address
   * @return {Promise} a promise that resolves to an Array of Strings, where each item encodes the 
   *   type of token this account holds (excluding the underlying blockchain's tokens)
   */


  getAccountTokens(address) {
    return fetch(`${this.blockstackAPIUrl}/v1/accounts/${address}/tokens`).then(resp => {
      if (resp.status === 404) {
        throw new Error('Account not found');
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(tokenList => {
      if (tokenList.error) {
        throw new Error(`Unable to get token list: ${tokenList.error}`);
      }

      return tokenList;
    });
  }
  /**
   * Get the number of tokens owned by an account.  If the account does not exist or has no
   * tokens of this type, then 0 will be returned.
   * @param {String} address the account's address
   * @param {String} tokenType the type of token to query.
   * @return {Promise} a promise that resolves to a BigInteger that encodes the number of tokens 
   *   held by this account.
   */


  getAccountBalance(address, tokenType) {
    return fetch(`${this.blockstackAPIUrl}/v1/accounts/${address}/${tokenType}/balance`).then(resp => {
      if (resp.status === 404) {
        // talking to an older blockstack core node without the accounts API
        return Promise.resolve().then(() => _bigi.default.fromByteArrayUnsigned('0'));
      } else if (resp.status !== 200) {
        throw new Error(`Bad response status: ${resp.status}`);
      } else {
        return resp.json();
      }
    }).then(tokenBalance => {
      if (tokenBalance.error) {
        throw new Error(`Unable to get account balance: ${tokenBalance.error}`);
      }

      let balance = '0';

      if (tokenBalance && tokenBalance.balance) {
        balance = tokenBalance.balance;
      }

      return _bigi.default.fromByteArrayUnsigned(balance);
    });
  }
  /**
   * Performs a POST request to the given URL
   * @param  {String} endpoint  the name of
   * @param  {String} body [description]
   * @return {Promise<Object|Error>} Returns a `Promise` that resolves to the object requested.
   * In the event of an error, it rejects with:
   * * a `RemoteServiceError` if there is a problem
   * with the transaction broadcast service
   * * `MissingParameterError` if you call the function without a required
   * parameter
   *
   * @private
   */


  broadcastServiceFetchHelper(endpoint, body) {
    const requestHeaders = {
      Accept: 'application/json',
      'Content-Type': 'application/json'
    };
    const options = {
      method: 'POST',
      headers: requestHeaders,
      body: JSON.stringify(body)
    };
    const url = `${this.broadcastServiceUrl}/v1/broadcast/${endpoint}`;
    return fetch(url, options).then(response => {
      if (response.ok) {
        return response.json();
      } else {
        throw new _errors.RemoteServiceError(response);
      }
    });
  }
  /**
  * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the
  * transaction until a second transaction has a certain number of confirmations.
  *
  * @param  {string} transaction the hex-encoded transaction to broadcast
  * @param  {string} transactionToWatch the hex transaction id of the transaction to watch for
  * the specified number of confirmations before broadcasting the `transaction`
  * @param  {number} confirmations the number of confirmations `transactionToWatch` must have
  * before broadcasting `transaction`.
  * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a
  * `transaction_hash` key containing the transaction hash of the broadcasted transaction.
  *
  * In the event of an error, it rejects with:
  * * a `RemoteServiceError` if there is a problem
  *   with the transaction broadcast service
  * * `MissingParameterError` if you call the function without a required
  *   parameter
  * @private
  */


  broadcastTransaction(transaction, transactionToWatch = null, confirmations = 6) {
    if (!transaction) {
      const error = new _errors.MissingParameterError('transaction');
      return Promise.reject(error);
    }

    if (!confirmations && confirmations !== 0) {
      const error = new _errors.MissingParameterError('confirmations');
      return Promise.reject(error);
    }

    if (transactionToWatch === null) {
      return this.btc.broadcastTransaction(transaction);
    } else {
      /*
       * POST /v1/broadcast/transaction
       * Request body:
       * JSON.stringify({
       *  transaction,
       *  transactionToWatch,
       *  confirmations
       * })
       */
      const endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;
      const requestBody = {
        transaction,
        transactionToWatch,
        confirmations
      };
      return this.broadcastServiceFetchHelper(endpoint, requestBody);
    }
  }
  /**
   * Broadcasts a zone file to the Atlas network via the transaction broadcast service.
   *
   * @param  {String} zoneFile the zone file to be broadcast to the Atlas network
   * @param  {String} transactionToWatch the hex transaction id of the transaction
   * to watch for confirmation before broadcasting the zone file to the Atlas network
   * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a
   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.
   *
   * In the event of an error, it rejects with:
   * * a `RemoteServiceError` if there is a problem
   *   with the transaction broadcast service
   * * `MissingParameterError` if you call the function without a required
   *   parameter
   * @private
   */


  broadcastZoneFile(zoneFile, transactionToWatch = null) {
    if (!zoneFile) {
      return Promise.reject(new _errors.MissingParameterError('zoneFile'));
    } // TODO: validate zonefile


    if (transactionToWatch) {
      // broadcast via transaction broadcast service

      /*
       * POST /v1/broadcast/zone-file
       * Request body:
       * JSON.stringify({
       *  zoneFile,
       *  transactionToWatch
       * })
       */
      const requestBody = {
        zoneFile,
        transactionToWatch
      };
      const endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;
      return this.broadcastServiceFetchHelper(endpoint, requestBody);
    } else {
      // broadcast via core endpoint
      // zone file is two words but core's api treats it as one word 'zonefile'
      const requestBody = {
        zonefile: zoneFile
      };
      return fetch(`${this.blockstackAPIUrl}/v1/zonefile/`, {
        method: 'POST',
        body: JSON.stringify(requestBody),
        headers: {
          'Content-Type': 'application/json'
        }
      }).then(resp => {
        const json = resp.json();
        return json.then(respObj => {
          if (respObj.hasOwnProperty('error')) {
            throw new _errors.RemoteServiceError(resp);
          }

          return respObj.servers;
        });
      });
    }
  }
  /**
   * Sends the preorder and registration transactions and zone file
   * for a Blockstack name registration
   * along with the to the transaction broadcast service.
   *
   * The transaction broadcast:
   *
   * * immediately broadcasts the preorder transaction
   * * broadcasts the register transactions after the preorder transaction
   * has an appropriate number of confirmations
   * * broadcasts the zone file to the Atlas network after the register transaction
   * has an appropriate number of confirmations
   *
   * @param  {String} preorderTransaction the hex-encoded, signed preorder transaction generated
   * using the `makePreorder` function
   * @param  {String} registerTransaction the hex-encoded, signed register transaction generated
   * using the `makeRegister` function
   * @param  {String} zoneFile the zone file to be broadcast to the Atlas network
   * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a
   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.
   *
   * In the event of an error, it rejects with:
   * * a `RemoteServiceError` if there is a problem
   *   with the transaction broadcast service
   * * `MissingParameterError` if you call the function without a required
   *   parameter
   * @private
   */


  broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {
    /*
       * POST /v1/broadcast/registration
       * Request body:
       * JSON.stringify({
       * preorderTransaction,
       * registerTransaction,
       * zoneFile
       * })
       */
    if (!preorderTransaction) {
      const error = new _errors.MissingParameterError('preorderTransaction');
      return Promise.reject(error);
    }

    if (!registerTransaction) {
      const error = new _errors.MissingParameterError('registerTransaction');
      return Promise.reject(error);
    }

    if (!zoneFile) {
      const error = new _errors.MissingParameterError('zoneFile');
      return Promise.reject(error);
    }

    const requestBody = {
      preorderTransaction,
      registerTransaction,
      zoneFile
    };
    const endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;
    return this.broadcastServiceFetchHelper(endpoint, requestBody);
  }

  getFeeRate() {
    return fetch('https://bitcoinfees.earn.com/api/v1/fees/recommended').then(resp => resp.json()).then(rates => Math.floor(rates.fastestFee));
  }

  countDustOutputs() {
    throw new Error('Not implemented.');
  }

  getUTXOs(address) {
    return this.getNetworkedUTXOs(address).then(networkedUTXOs => {
      let returnSet = networkedUTXOs.concat();

      if (this.includeUtxoMap.hasOwnProperty(address)) {
        returnSet = networkedUTXOs.concat(this.includeUtxoMap[address]);
      } // aaron: I am *well* aware this is O(n)*O(m) runtime
      //    however, clients should clear the exclude set periodically


      const excludeSet = this.excludeUtxoSet;
      returnSet = returnSet.filter(utxo => {
        const inExcludeSet = excludeSet.reduce((inSet, utxoToCheck) => inSet || utxoToCheck.tx_hash === utxo.tx_hash && utxoToCheck.tx_output_n === utxo.tx_output_n, false);
        return !inExcludeSet;
      });
      return returnSet;
    });
  }
  /**
   * This will modify the network's utxo set to include UTXOs
   *  from the given transaction and exclude UTXOs *spent* in
   *  that transaction
   * @param {String} txHex - the hex-encoded transaction to use
   * @return {void} no return value, this modifies the UTXO config state
   * @private
   */


  modifyUTXOSetFrom(txHex) {
    const tx = _bitcoinjsLib.default.Transaction.fromHex(txHex);

    const excludeSet = this.excludeUtxoSet.concat();
    tx.ins.forEach(utxoUsed => {
      const reverseHash = Buffer.from(utxoUsed.hash);
      reverseHash.reverse();
      excludeSet.push({
        tx_hash: reverseHash.toString('hex'),
        tx_output_n: utxoUsed.index
      });
    });
    this.excludeUtxoSet = excludeSet;
    const txHash = tx.getHash().reverse().toString('hex');
    tx.outs.forEach((utxoCreated, txOutputN) => {
      const isNullData = function isNullData(script) {
        try {
          _bitcoinjsLib.default.payments.embed({
            output: script
          }, {
            validate: true
          });

          return true;
        } catch (_) {
          return false;
        }
      };

      if (isNullData(utxoCreated.script)) {
        return;
      }

      const address = _bitcoinjsLib.default.address.fromOutputScript(utxoCreated.script, this.layer1);

      let includeSet = [];

      if (this.includeUtxoMap.hasOwnProperty(address)) {
        includeSet = includeSet.concat(this.includeUtxoMap[address]);
      }

      includeSet.push({
        tx_hash: txHash,
        confirmations: 0,
        value: utxoCreated.value,
        tx_output_n: txOutputN
      });
      this.includeUtxoMap[address] = includeSet;
    });
  }

  resetUTXOs(address) {
    delete this.includeUtxoMap[address];
    this.excludeUtxoSet = [];
  }

  getConsensusHash() {
    return fetch(`${this.blockstackAPIUrl}/v1/blockchains/bitcoin/consensus`).then(resp => resp.json()).then(x => x.consensus_hash);
  }

  getTransactionInfo(txHash) {
    return this.btc.getTransactionInfo(txHash);
  }

  getBlockHeight() {
    return this.btc.getBlockHeight();
  }

  getNetworkedUTXOs(address) {
    return this.btc.getNetworkedUTXOs(address);
  }

}

exports.BlockstackNetwork = BlockstackNetwork;

class LocalRegtest extends BlockstackNetwork {
  constructor(apiUrl, broadcastServiceUrl, bitcoinAPI) {
    super(apiUrl, broadcastServiceUrl, bitcoinAPI, _bitcoinjsLib.default.networks.testnet);
  }

  getFeeRate() {
    return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));
  }

}

exports.LocalRegtest = LocalRegtest;

class BitcoindAPI extends BitcoinNetwork {
  constructor(bitcoindUrl, bitcoindCredentials) {
    super();
    this.bitcoindUrl = bitcoindUrl;
    this.bitcoindCredentials = bitcoindCredentials;
    this.importedBefore = {};
  }

  broadcastTransaction(transaction) {
    const jsonRPC = {
      jsonrpc: '1.0',
      method: 'sendrawtransaction',
      params: [transaction]
    };
    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');
    const headers = {
      Authorization: `Basic ${authString}`
    };
    return fetch(this.bitcoindUrl, {
      method: 'POST',
      body: JSON.stringify(jsonRPC),
      headers
    }).then(resp => resp.json()).then(respObj => respObj.result);
  }

  getBlockHeight() {
    const jsonRPC = {
      jsonrpc: '1.0',
      method: 'getblockcount'
    };
    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');
    const headers = {
      Authorization: `Basic ${authString}`
    };
    return fetch(this.bitcoindUrl, {
      method: 'POST',
      body: JSON.stringify(jsonRPC),
      headers
    }).then(resp => resp.json()).then(respObj => respObj.result);
  }

  getTransactionInfo(txHash) {
    const jsonRPC = {
      jsonrpc: '1.0',
      method: 'gettransaction',
      params: [txHash]
    };
    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');
    const headers = {
      Authorization: `Basic ${authString}`
    };
    return fetch(this.bitcoindUrl, {
      method: 'POST',
      body: JSON.stringify(jsonRPC),
      headers
    }).then(resp => resp.json()).then(respObj => respObj.result).then(txInfo => txInfo.blockhash).then(blockhash => {
      const jsonRPCBlock = {
        jsonrpc: '1.0',
        method: 'getblockheader',
        params: [blockhash]
      };
      headers.Authorization = `Basic ${authString}`;
      return fetch(this.bitcoindUrl, {
        method: 'POST',
        body: JSON.stringify(jsonRPCBlock),
        headers
      });
    }).then(resp => resp.json()).then(respObj => {
      if (!respObj || !respObj.result) {
        // unconfirmed 
        throw new Error('Unconfirmed transaction');
      } else {
        return {
          block_height: respObj.result.height
        };
      }
    });
  }

  getNetworkedUTXOs(address) {
    const jsonRPCImport = {
      jsonrpc: '1.0',
      method: 'importaddress',
      params: [address]
    };
    const jsonRPCUnspent = {
      jsonrpc: '1.0',
      method: 'listunspent',
      params: [0, 9999999, [address]]
    };
    const authString = Buffer.from(`${this.bitcoindCredentials.username}:${this.bitcoindCredentials.password}`).toString('base64');
    const headers = {
      Authorization: `Basic ${authString}`
    };
    const importPromise = this.importedBefore[address] ? Promise.resolve() : fetch(this.bitcoindUrl, {
      method: 'POST',
      body: JSON.stringify(jsonRPCImport),
      headers
    }).then(() => {
      this.importedBefore[address] = true;
    });
    return importPromise.then(() => fetch(this.bitcoindUrl, {
      method: 'POST',
      body: JSON.stringify(jsonRPCUnspent),
      headers
    })).then(resp => resp.json()).then(x => x.result).then(utxos => utxos.map(x => Object({
      value: Math.round(x.amount * SATOSHIS_PER_BTC),
      confirmations: x.confirmations,
      tx_hash: x.txid,
      tx_output_n: x.vout
    })));
  }

}

exports.BitcoindAPI = BitcoindAPI;

class InsightClient extends BitcoinNetwork {
  constructor(insightUrl = 'https://utxo.technofractal.com/') {
    super();
    this.apiUrl = insightUrl;
  }

  broadcastTransaction(transaction) {
    const jsonData = {
      rawtx: transaction
    };
    return fetch(`${this.apiUrl}/tx/send`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(jsonData)
    }).then(resp => resp.json());
  }

  getBlockHeight() {
    return fetch(`${this.apiUrl}/status`).then(resp => resp.json()).then(status => status.blocks);
  }

  getTransactionInfo(txHash) {
    return fetch(`${this.apiUrl}/tx/${txHash}`).then(resp => resp.json()).then(transactionInfo => {
      if (transactionInfo.error) {
        throw new Error(`Error finding transaction: ${transactionInfo.error}`);
      }

      return fetch(`${this.apiUrl}/block/${transactionInfo.blockHash}`);
    }).then(resp => resp.json()).then(blockInfo => ({
      block_height: blockInfo.height
    }));
  }

  getNetworkedUTXOs(address) {
    return fetch(`${this.apiUrl}/addr/${address}/utxo`).then(resp => resp.json()).then(utxos => utxos.map(x => ({
      value: x.satoshis,
      confirmations: x.confirmations,
      tx_hash: x.txid,
      tx_output_n: x.vout
    })));
  }

}

exports.InsightClient = InsightClient;

class BlockchainInfoApi extends BitcoinNetwork {
  constructor(blockchainInfoUrl = 'https://blockchain.info') {
    super();
    this.utxoProviderUrl = blockchainInfoUrl;
  }

  getBlockHeight() {
    return fetch(`${this.utxoProviderUrl}/latestblock?cors=true`).then(resp => resp.json()).then(blockObj => blockObj.height);
  }

  getNetworkedUTXOs(address) {
    return fetch(`${this.utxoProviderUrl}/unspent?format=json&active=${address}&cors=true`).then(resp => {
      if (resp.status === 500) {
        _logger.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');

        return {
          unspent_outputs: []
        };
      } else {
        return resp.json();
      }
    }).then(utxoJSON => utxoJSON.unspent_outputs).then(utxoList => utxoList.map(utxo => {
      const utxoOut = {
        value: utxo.value,
        tx_output_n: utxo.tx_output_n,
        confirmations: utxo.confirmations,
        tx_hash: utxo.tx_hash_big_endian
      };
      return utxoOut;
    }));
  }

  getTransactionInfo(txHash) {
    return fetch(`${this.utxoProviderUrl}/rawtx/${txHash}?cors=true`).then(resp => {
      if (resp.status === 200) {
        return resp.json();
      } else {
        throw new Error(`Could not lookup transaction info for '${txHash}'. Server error.`);
      }
    }).then(respObj => ({
      block_height: respObj.block_height
    }));
  }

  broadcastTransaction(transaction) {
    const form = new _formData.default();
    form.append('tx', transaction);
    return fetch(`${this.utxoProviderUrl}/pushtx?cors=true`, {
      method: 'POST',
      body: form
    }).then(resp => {
      const text = resp.text();
      return text.then(respText => {
        if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {
          const txHash = _bitcoinjsLib.default.Transaction.fromHex(transaction).getHash().reverse().toString('hex'); // big_endian


          return txHash;
        } else {
          throw new _errors.RemoteServiceError(resp, `Broadcast transaction failed with message: ${respText}`);
        }
      });
    });
  }

}

exports.BlockchainInfoApi = BlockchainInfoApi;
const LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', {
  username: 'blockstack',
  password: 'blockstacksystem'
}));
const MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());
const network = {
  BlockstackNetwork,
  LocalRegtest,
  BlockchainInfoApi,
  BitcoindAPI,
  InsightClient,
  defaults: {
    LOCAL_REGTEST,
    MAINNET_DEFAULT
  }
};
exports.network = network;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9uZXR3b3JrLmpzIl0sIm5hbWVzIjpbIlNBVE9TSElTX1BFUl9CVEMiLCJUWF9CUk9BRENBU1RfU0VSVklDRV9aT05FX0ZJTEVfRU5EUE9JTlQiLCJUWF9CUk9BRENBU1RfU0VSVklDRV9SRUdJU1RSQVRJT05fRU5EUE9JTlQiLCJUWF9CUk9BRENBU1RfU0VSVklDRV9UWF9FTkRQT0lOVCIsIkJpdGNvaW5OZXR3b3JrIiwiYnJvYWRjYXN0VHJhbnNhY3Rpb24iLCJ0cmFuc2FjdGlvbiIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImdldEJsb2NrSGVpZ2h0IiwiZ2V0VHJhbnNhY3Rpb25JbmZvIiwidHhpZCIsImdldE5ldHdvcmtlZFVUWE9zIiwiYWRkcmVzcyIsIkJsb2Nrc3RhY2tOZXR3b3JrIiwiY29uc3RydWN0b3IiLCJhcGlVcmwiLCJicm9hZGNhc3RTZXJ2aWNlVXJsIiwiYml0Y29pbkFQSSIsIm5ldHdvcmsiLCJiaXRjb2luanMiLCJuZXR3b3JrcyIsImJpdGNvaW4iLCJibG9ja3N0YWNrQVBJVXJsIiwibGF5ZXIxIiwiYnRjIiwiRFVTVF9NSU5JTVVNIiwiaW5jbHVkZVV0eG9NYXAiLCJleGNsdWRlVXR4b1NldCIsIk1BR0lDX0JZVEVTIiwiY29lcmNlQWRkcmVzcyIsImhhc2giLCJ2ZXJzaW9uIiwiZnJvbUJhc2U1OENoZWNrIiwic2NyaXB0SGFzaGVzIiwic2NyaXB0SGFzaCIsInRlc3RuZXQiLCJwdWJLZXlIYXNoZXMiLCJwdWJLZXlIYXNoIiwiY29lcmNlZFZlcnNpb24iLCJpbmRleE9mIiwidG9CYXNlNThDaGVjayIsImdldERlZmF1bHRCdXJuQWRkcmVzcyIsImdldE5hbWVQcmljZVYxIiwiZnVsbHlRdWFsaWZpZWROYW1lIiwiZmV0Y2giLCJ0aGVuIiwicmVzcCIsIm9rIiwianNvbiIsIm5hbWVfcHJpY2UiLCJuYW1lUHJpY2UiLCJzYXRvc2hpcyIsInJlc3VsdCIsInVuaXRzIiwiYW1vdW50IiwiYmlnaSIsImZyb21CeXRlQXJyYXlVbnNpZ25lZCIsIlN0cmluZyIsImdldE5hbWVzcGFjZVByaWNlVjEiLCJuYW1lc3BhY2VJRCIsIm5hbWVzcGFjZVByaWNlIiwiZ2V0TmFtZVByaWNlVjIiLCJzdGF0dXMiLCJkdXN0TWluIiwiY29tcGFyZVRvIiwiZ2V0TmFtZXNwYWNlUHJpY2VWMiIsImdldE5hbWVQcmljZSIsInJlc29sdmUiLCJjYXRjaCIsImdldE5hbWVzcGFjZVByaWNlIiwiZ2V0R3JhY2VQZXJpb2QiLCJnZXROYW1lc093bmVkIiwibmV0d29ya0FkZHJlc3MiLCJvYmoiLCJuYW1lcyIsImdldE5hbWVzcGFjZUJ1cm5BZGRyZXNzIiwibmFtZXNwYWNlIiwiYWxsIiwiYmxvY2tIZWlnaHQiLCJuYW1lc3BhY2VJbmZvIiwicmV2ZWFsX2Jsb2NrIiwiZ2V0TmFtZUluZm8iLCJMb2dnZXIiLCJkZWJ1ZyIsIm5hbWVMb29rdXBVUkwiLCJuYW1lSW5mbyIsIkpTT04iLCJzdHJpbmdpZnkiLCJPYmplY3QiLCJhc3NpZ24iLCJnZXROYW1lc3BhY2VJbmZvIiwicmVjaXBpZW50X2FkZHJlc3MiLCJnZXRab25lZmlsZSIsInpvbmVmaWxlSGFzaCIsInRleHQiLCJib2R5Iiwic2hhMjU2IiwiY3J5cHRvIiwiaCIsIlJJUEVNRDE2MCIsInVwZGF0ZSIsImRpZ2VzdCIsImdldEFjY291bnRTdGF0dXMiLCJ0b2tlblR5cGUiLCJhY2NvdW50U3RhdHVzIiwiZm9ybWF0dGVkU3RhdHVzIiwiZGViaXRfdmFsdWUiLCJjcmVkaXRfdmFsdWUiLCJnZXRBY2NvdW50SGlzdG9yeVBhZ2UiLCJwYWdlIiwidXJsIiwiaGlzdG9yeUxpc3QiLCJlcnJvciIsIm1hcCIsImhpc3RFbnRyeSIsImdldEFjY291bnRBdCIsImdldEFjY291bnRUb2tlbnMiLCJ0b2tlbkxpc3QiLCJnZXRBY2NvdW50QmFsYW5jZSIsInRva2VuQmFsYW5jZSIsImJhbGFuY2UiLCJicm9hZGNhc3RTZXJ2aWNlRmV0Y2hIZWxwZXIiLCJlbmRwb2ludCIsInJlcXVlc3RIZWFkZXJzIiwiQWNjZXB0Iiwib3B0aW9ucyIsIm1ldGhvZCIsImhlYWRlcnMiLCJyZXNwb25zZSIsIlJlbW90ZVNlcnZpY2VFcnJvciIsInRyYW5zYWN0aW9uVG9XYXRjaCIsImNvbmZpcm1hdGlvbnMiLCJNaXNzaW5nUGFyYW1ldGVyRXJyb3IiLCJyZXF1ZXN0Qm9keSIsImJyb2FkY2FzdFpvbmVGaWxlIiwiem9uZUZpbGUiLCJ6b25lZmlsZSIsInJlc3BPYmoiLCJoYXNPd25Qcm9wZXJ0eSIsInNlcnZlcnMiLCJicm9hZGNhc3ROYW1lUmVnaXN0cmF0aW9uIiwicHJlb3JkZXJUcmFuc2FjdGlvbiIsInJlZ2lzdGVyVHJhbnNhY3Rpb24iLCJnZXRGZWVSYXRlIiwicmF0ZXMiLCJNYXRoIiwiZmxvb3IiLCJmYXN0ZXN0RmVlIiwiY291bnREdXN0T3V0cHV0cyIsImdldFVUWE9zIiwibmV0d29ya2VkVVRYT3MiLCJyZXR1cm5TZXQiLCJjb25jYXQiLCJleGNsdWRlU2V0IiwiZmlsdGVyIiwidXR4byIsImluRXhjbHVkZVNldCIsInJlZHVjZSIsImluU2V0IiwidXR4b1RvQ2hlY2siLCJ0eF9oYXNoIiwidHhfb3V0cHV0X24iLCJtb2RpZnlVVFhPU2V0RnJvbSIsInR4SGV4IiwidHgiLCJUcmFuc2FjdGlvbiIsImZyb21IZXgiLCJpbnMiLCJmb3JFYWNoIiwidXR4b1VzZWQiLCJyZXZlcnNlSGFzaCIsIkJ1ZmZlciIsImZyb20iLCJyZXZlcnNlIiwicHVzaCIsInRvU3RyaW5nIiwiaW5kZXgiLCJ0eEhhc2giLCJnZXRIYXNoIiwib3V0cyIsInV0eG9DcmVhdGVkIiwidHhPdXRwdXROIiwiaXNOdWxsRGF0YSIsInNjcmlwdCIsInBheW1lbnRzIiwiZW1iZWQiLCJvdXRwdXQiLCJ2YWxpZGF0ZSIsIl8iLCJmcm9tT3V0cHV0U2NyaXB0IiwiaW5jbHVkZVNldCIsInZhbHVlIiwicmVzZXRVVFhPcyIsImdldENvbnNlbnN1c0hhc2giLCJ4IiwiY29uc2Vuc3VzX2hhc2giLCJMb2NhbFJlZ3Rlc3QiLCJCaXRjb2luZEFQSSIsImJpdGNvaW5kVXJsIiwiYml0Y29pbmRDcmVkZW50aWFscyIsImltcG9ydGVkQmVmb3JlIiwianNvblJQQyIsImpzb25ycGMiLCJwYXJhbXMiLCJhdXRoU3RyaW5nIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsIkF1dGhvcml6YXRpb24iLCJ0eEluZm8iLCJibG9ja2hhc2giLCJqc29uUlBDQmxvY2siLCJibG9ja19oZWlnaHQiLCJoZWlnaHQiLCJqc29uUlBDSW1wb3J0IiwianNvblJQQ1Vuc3BlbnQiLCJpbXBvcnRQcm9taXNlIiwidXR4b3MiLCJyb3VuZCIsInZvdXQiLCJJbnNpZ2h0Q2xpZW50IiwiaW5zaWdodFVybCIsImpzb25EYXRhIiwicmF3dHgiLCJibG9ja3MiLCJ0cmFuc2FjdGlvbkluZm8iLCJibG9ja0hhc2giLCJibG9ja0luZm8iLCJCbG9ja2NoYWluSW5mb0FwaSIsImJsb2NrY2hhaW5JbmZvVXJsIiwidXR4b1Byb3ZpZGVyVXJsIiwiYmxvY2tPYmoiLCJ1bnNwZW50X291dHB1dHMiLCJ1dHhvSlNPTiIsInV0eG9MaXN0IiwidXR4b091dCIsInR4X2hhc2hfYmlnX2VuZGlhbiIsImZvcm0iLCJGb3JtRGF0YSIsImFwcGVuZCIsInJlc3BUZXh0IiwidG9Mb3dlckNhc2UiLCJMT0NBTF9SRUdURVNUIiwiTUFJTk5FVF9ERUZBVUxUIiwiZGVmYXVsdHMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFPQSxNQUFNQSxnQkFBZ0IsR0FBRyxHQUF6QjtBQUNBLE1BQU1DLHVDQUF1QyxHQUFHLFdBQWhEO0FBQ0EsTUFBTUMsMENBQTBDLEdBQUcsY0FBbkQ7QUFDQSxNQUFNQyxnQ0FBZ0MsR0FBRyxhQUF6Qzs7QUFFTyxNQUFNQyxjQUFOLENBQXFCO0FBQzFCQyxFQUFBQSxvQkFBb0IsQ0FBQ0MsV0FBRCxFQUF3QztBQUMxRCxXQUFPQyxPQUFPLENBQUNDLE1BQVIsQ0FBZSxJQUFJQyxLQUFKLENBQVcseUNBQXdDSCxXQUFZ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QWhCLEVBQ2dCO0FBQUVRLEVBQUFBLFFBQVEsRUFBRSxZQUFaO0FBQTBCQyxFQUFBQSxRQUFRLEVBQUU7QUFBcEMsQ0FEaEIsQ0FIb0IsQ0FBdEI7QUFPQSxNQUFNb0MsZUFBZSxHQUFHLElBQUlyTyxpQkFBSixDQUN0Qiw2QkFEc0IsRUFFdEIsa0NBRnNCLEVBR3RCLElBQUlzTixpQkFBSixFQUhzQixDQUF4QjtBQU1PLE1BQU1qTixPQUFPLEdBQUc7QUFDckJMLEVBQUFBLGlCQURxQjtBQUVyQnVMLEVBQUFBLFlBRnFCO0FBR3JCK0IsRUFBQUEsaUJBSHFCO0FBSXJCOUIsRUFBQUEsV0FKcUI7QUFLckJzQixFQUFBQSxhQUxxQjtBQU1yQndCLEVBQUFBLFFBQVEsRUFBRTtBQUFFRixJQUFBQSxhQUFGO0FBQWlCQyxJQUFBQTtBQUFqQjtBQU5XLENBQWhCIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cbmltcG9ydCBiaXRjb2luanMgZnJvbSAnYml0Y29pbmpzLWxpYidcbmltcG9ydCBGb3JtRGF0YSBmcm9tICdmb3JtLWRhdGEnXG5pbXBvcnQgYmlnaSBmcm9tICdiaWdpJ1xuaW1wb3J0IFJJUEVNRDE2MCBmcm9tICdyaXBlbWQxNjAnXG5pbXBvcnQgeyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IsIFJlbW90ZVNlcnZpY2VFcnJvciB9IGZyb20gJy4vZXJyb3JzJ1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInXG5cbnR5cGUgVVRYTyA9IHsgdmFsdWU/OiBudW1iZXIsXG4gICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM/OiBudW1iZXIsXG4gICAgICAgICAgICAgIHR4X2hhc2g6IHN0cmluZyxcbiAgICAgICAgICAgICAgdHhfb3V0cHV0X246IG51bWJlciB9XG5cbmNvbnN0IFNBVE9TSElTX1BFUl9CVEMgPSAxZThcbmNvbnN0IFRYX0JST0FEQ0FTVF9TRVJWSUNFX1pPTkVfRklMRV9FTkRQT0lOVCA9ICd6b25lLWZpbGUnXG5jb25zdCBUWF9CUk9BRENBU1RfU0VSVklDRV9SRUdJU1RSQVRJT05fRU5EUE9JTlQgPSAncmVnaXN0cmF0aW9uJ1xuY29uc3QgVFhfQlJPQURDQVNUX1NFUlZJQ0VfVFhfRU5EUE9JTlQgPSAndHJhbnNhY3Rpb24nXG5cbmV4cG9ydCBjbGFzcyBCaXRjb2luTmV0d29yayB7XG4gIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBzdHJpbmcpIDogUHJvbWlzZTxPYmplY3Q+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKGBOb3QgaW1wbGVtZW50ZWQsIGJyb2FkY2FzdFRyYW5zYWN0aW9uKCR7dHJhbnNhY3Rpb259KWApKVxuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoKSA6IFByb21pc2U8TnVtYmVyPiB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkLCBnZXRCbG9ja0hlaWdodCgpJykpXG4gIH1cblxuICBnZXRUcmFuc2FjdGlvbkluZm8odHhpZDogc3RyaW5nKSA6IFByb21pc2U8e2Jsb2NrX2hlaWdodDogTnVtYmVyfT4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCwgZ2V0VHJhbnNhY3Rpb25JbmZvKCR7dHhpZH0pYCkpXG4gIH1cblxuICBnZXROZXR3b3JrZWRVVFhPcyhhZGRyZXNzOiBzdHJpbmcpIDogUHJvbWlzZTxBcnJheTxVVFhPPj4ge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYE5vdCBpbXBsZW1lbnRlZCwgZ2V0TmV0d29ya2VkVVRYT3MoJHthZGRyZXNzfSlgKSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tzdGFja05ldHdvcmsge1xuICBibG9ja3N0YWNrQVBJVXJsOiBzdHJpbmdcblxuICBicm9hZGNhc3RTZXJ2aWNlVXJsOiBzdHJpbmdcblxuICBsYXllcjE6IE9iamVjdFxuXG4gIERVU1RfTUlOSU1VTTogbnVtYmVyXG5cbiAgaW5jbHVkZVV0eG9NYXA6IE9iamVjdFxuXG4gIGV4Y2x1ZGVVdHhvU2V0OiBBcnJheTxVVFhPPlxuXG4gIGJ0YzogQml0Y29pbk5ldHdvcmtcblxuICBNQUdJQ19CWVRFUzogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYXBpVXJsOiBzdHJpbmcsIGJyb2FkY2FzdFNlcnZpY2VVcmw6IHN0cmluZyxcbiAgICAgICAgICAgICAgYml0Y29pbkFQSTogQml0Y29pbk5ldHdvcmssXG4gICAgICAgICAgICAgIG5ldHdvcms6IE9iamVjdCA9IGJpdGNvaW5qcy5uZXR3b3Jrcy5iaXRjb2luKSB7XG4gICAgdGhpcy5ibG9ja3N0YWNrQVBJVXJsID0gYXBpVXJsXG4gICAgdGhpcy5icm9hZGNhc3RTZXJ2aWNlVXJsID0gYnJvYWRjYXN0U2VydmljZVVybFxuICAgIHRoaXMubGF5ZXIxID0gbmV0d29ya1xuICAgIHRoaXMuYnRjID0gYml0Y29pbkFQSVxuXG4gICAgdGhpcy5EVVNUX01JTklNVU0gPSA1NTAwXG4gICAgdGhpcy5pbmNsdWRlVXR4b01hcCA9IHt9XG4gICAgdGhpcy5leGNsdWRlVXR4b1NldCA9IFtdXG4gICAgdGhpcy5NQUdJQ19CWVRFUyA9ICdpZCdcbiAgfVxuXG4gIGNvZXJjZUFkZHJlc3MoYWRkcmVzczogc3RyaW5nKSB7XG4gICAgY29uc3QgeyBoYXNoLCB2ZXJzaW9uIH0gPSBiaXRjb2luanMuYWRkcmVzcy5mcm9tQmFzZTU4Q2hlY2soYWRkcmVzcylcbiAgICBjb25zdCBzY3JpcHRIYXNoZXMgPSBbYml0Y29pbmpzLm5ldHdvcmtzLmJpdGNvaW4uc2NyaXB0SGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYml0Y29pbmpzLm5ldHdvcmtzLnRlc3RuZXQuc2NyaXB0SGFzaF1cbiAgICBjb25zdCBwdWJLZXlIYXNoZXMgPSBbYml0Y29pbmpzLm5ldHdvcmtzLmJpdGNvaW4ucHViS2V5SGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYml0Y29pbmpzLm5ldHdvcmtzLnRlc3RuZXQucHViS2V5SGFzaF1cbiAgICBsZXQgY29lcmNlZFZlcnNpb25cbiAgICBpZiAoc2NyaXB0SGFzaGVzLmluZGV4T2YodmVyc2lvbikgPj0gMCkge1xuICAgICAgY29lcmNlZFZlcnNpb24gPSB0aGlzLmxheWVyMS5zY3JpcHRIYXNoXG4gICAgfSBlbHNlIGlmIChwdWJLZXlIYXNoZXMuaW5kZXhPZih2ZXJzaW9uKSA+PSAwKSB7XG4gICAgICBjb2VyY2VkVmVyc2lvbiA9IHRoaXMubGF5ZXIxLnB1YktleUhhc2hcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgYWRkcmVzcyB2ZXJzaW9uIG51bWJlciAke3ZlcnNpb259IGluICR7YWRkcmVzc31gKVxuICAgIH1cbiAgICByZXR1cm4gYml0Y29pbmpzLmFkZHJlc3MudG9CYXNlNThDaGVjayhoYXNoLCBjb2VyY2VkVmVyc2lvbilcbiAgfVxuXG4gIGdldERlZmF1bHRCdXJuQWRkcmVzcygpIHtcbiAgICByZXR1cm4gdGhpcy5jb2VyY2VBZGRyZXNzKCcxMTExMTExMTExMTExMTExMTExMTE0b0x2VDInKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpY2Ugb2YgYSBuYW1lIHZpYSB0aGUgbGVnYWN5IC92MS9wcmljZXMgQVBJIGVuZHBvaW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnVsbHlRdWFsaWZpZWROYW1lIHRoZSBuYW1lIHRvIHF1ZXJ5XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0byBhbiBPYmplY3Qgd2l0aCB7IHVuaXRzOiBTdHJpbmcsIGFtb3VudDogQmlnSW50ZWdlciB9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYW1lUHJpY2VWMShmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZykgOiBQcm9taXNlPCo+IHtcbiAgICAvLyBsZWdhY3kgY29kZSBwYXRoXG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMuYmxvY2tzdGFja0FQSVVybH0vdjEvcHJpY2VzL25hbWVzLyR7ZnVsbHlRdWFsaWZpZWROYW1lfWApXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBxdWVyeSBuYW1lIHByaWNlIGZvciAke2Z1bGx5UXVhbGlmaWVkTmFtZX1gKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwXG4gICAgICB9KVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5uYW1lX3ByaWNlKVxuICAgICAgLnRoZW4oKG5hbWVQcmljZSkgPT4ge1xuICAgICAgICBpZiAoIW5hbWVQcmljZSB8fCAhbmFtZVByaWNlLnNhdG9zaGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZXQgcHJpY2UgZm9yICR7ZnVsbHlRdWFsaWZpZWROYW1lfS4gRG9lcyB0aGUgbmFtZXNwYWNlIGV4aXN0P2BcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVQcmljZS5zYXRvc2hpcyA8IHRoaXMuRFVTVF9NSU5JTVVNKSB7XG4gICAgICAgICAgbmFtZVByaWNlLnNhdG9zaGlzID0gdGhpcy5EVVNUX01JTklNVU1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgdW5pdHM6ICdCVEMnLFxuICAgICAgICAgIGFtb3VudDogYmlnaS5mcm9tQnl0ZUFycmF5VW5zaWduZWQoU3RyaW5nKG5hbWVQcmljZS5zYXRvc2hpcykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaWNlIG9mIGEgbmFtZXNwYWNlIHZpYSB0aGUgbGVnYWN5IC92MS9wcmljZXMgQVBJIGVuZHBvaW50LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlSUQgdGhlIG5hbWVzcGFjZSB0byBxdWVyeVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdG8gYW4gT2JqZWN0IHdpdGggeyB1bml0czogU3RyaW5nLCBhbW91bnQ6IEJpZ0ludGVnZXIgfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmFtZXNwYWNlUHJpY2VWMShuYW1lc3BhY2VJRDogc3RyaW5nKSA6IFByb21pc2U8Kj4ge1xuICAgIC8vIGxlZ2FjeSBjb2RlIHBhdGhcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92MS9wcmljZXMvbmFtZXNwYWNlcy8ke25hbWVzcGFjZUlEfWApXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBpZiAoIXJlc3Aub2spIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBxdWVyeSBuYW1lIHByaWNlIGZvciAke25hbWVzcGFjZUlEfWApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AuanNvbigpKVxuICAgICAgLnRoZW4oKG5hbWVzcGFjZVByaWNlKSA9PiB7XG4gICAgICAgIGlmICghbmFtZXNwYWNlUHJpY2UgfHwgIW5hbWVzcGFjZVByaWNlLnNhdG9zaGlzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2V0IHByaWNlIGZvciAke25hbWVzcGFjZUlEfWApXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZVByaWNlLnNhdG9zaGlzIDwgdGhpcy5EVVNUX01JTklNVU0pIHtcbiAgICAgICAgICBuYW1lc3BhY2VQcmljZS5zYXRvc2hpcyA9IHRoaXMuRFVTVF9NSU5JTVVNXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHVuaXRzOiAnQlRDJyxcbiAgICAgICAgICBhbW91bnQ6IGJpZ2kuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKFN0cmluZyhuYW1lc3BhY2VQcmljZS5zYXRvc2hpcykpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgfVxuICBcbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpY2Ugb2YgYSBuYW1lIHZpYSB0aGUgL3YyL3ByaWNlcyBBUEkgZW5kcG9pbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmdWxseVF1YWxpZmllZE5hbWUgdGhlIG5hbWUgdG8gcXVlcnlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRvIGFuIE9iamVjdCB3aXRoIHsgdW5pdHM6IFN0cmluZywgYW1vdW50OiBCaWdJbnRlZ2VyIH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hbWVQcmljZVYyKGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nKSA6IFByb21pc2U8Kj4ge1xuICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmJsb2Nrc3RhY2tBUElVcmx9L3YyL3ByaWNlcy9uYW1lcy8ke2Z1bGx5UXVhbGlmaWVkTmFtZX1gKVxuICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICAvLyBvbGQgY29yZSBub2RlIFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHVwc3RyZWFtIG5vZGUgZG9lcyBub3QgaGFuZGxlIHRoZSAvdjIvIHByaWNlIG5hbWVzcGFjZScpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BcbiAgICAgIH0pXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AuanNvbigpKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLm5hbWVfcHJpY2UpXG4gICAgICAudGhlbigobmFtZVByaWNlKSA9PiB7XG4gICAgICAgIGlmICghbmFtZVByaWNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEZhaWxlZCB0byBnZXQgcHJpY2UgZm9yICR7ZnVsbHlRdWFsaWZpZWROYW1lfS4gRG9lcyB0aGUgbmFtZXNwYWNlIGV4aXN0P2BcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgIHVuaXRzOiBuYW1lUHJpY2UudW5pdHMsXG4gICAgICAgICAgYW1vdW50OiBiaWdpLmZyb21CeXRlQXJyYXlVbnNpZ25lZChuYW1lUHJpY2UuYW1vdW50KVxuICAgICAgICB9XG4gICAgICAgIGlmIChuYW1lUHJpY2UudW5pdHMgPT09ICdCVEMnKSB7XG4gICAgICAgICAgLy8gbXVzdCBiZSBhdCBsZWFzdCBkdXN0LW1pbmltdW1cbiAgICAgICAgICBjb25zdCBkdXN0TWluID0gYmlnaS5mcm9tQnl0ZUFycmF5VW5zaWduZWQoU3RyaW5nKHRoaXMuRFVTVF9NSU5JTVVNKSlcbiAgICAgICAgICBpZiAocmVzdWx0LmFtb3VudC5jb21wYXJlVG8oZHVzdE1pbikgPCAwKSB7XG4gICAgICAgICAgICByZXN1bHQuYW1vdW50ID0gZHVzdE1pblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpY2Ugb2YgYSBuYW1lc3BhY2UgdmlhIHRoZSAvdjIvcHJpY2VzIEFQSSBlbmRwb2ludC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZUlEIHRoZSBuYW1lc3BhY2UgdG8gcXVlcnlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRvIGFuIE9iamVjdCB3aXRoIHsgdW5pdHM6IFN0cmluZywgYW1vdW50OiBCaWdJbnRlZ2VyIH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hbWVzcGFjZVByaWNlVjIobmFtZXNwYWNlSUQ6IHN0cmluZykgOiBQcm9taXNlPCo+IHtcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92Mi9wcmljZXMvbmFtZXNwYWNlcy8ke25hbWVzcGFjZUlEfWApXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIC8vIG9sZCBjb3JlIG5vZGUgXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdXBzdHJlYW0gbm9kZSBkb2VzIG5vdCBoYW5kbGUgdGhlIC92Mi8gcHJpY2UgbmFtZXNwYWNlJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcFxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbigobmFtZXNwYWNlUHJpY2UpID0+IHtcbiAgICAgICAgaWYgKCFuYW1lc3BhY2VQcmljZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBwcmljZSBmb3IgJHtuYW1lc3BhY2VJRH1gKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICB1bml0czogbmFtZXNwYWNlUHJpY2UudW5pdHMsXG4gICAgICAgICAgYW1vdW50OiBiaWdpLmZyb21CeXRlQXJyYXlVbnNpZ25lZChuYW1lc3BhY2VQcmljZS5hbW91bnQpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWVzcGFjZVByaWNlLnVuaXRzID09PSAnQlRDJykge1xuICAgICAgICAgIC8vIG11c3QgYmUgYXQgbGVhc3QgZHVzdC1taW5pbXVtXG4gICAgICAgICAgY29uc3QgZHVzdE1pbiA9IGJpZ2kuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKFN0cmluZyh0aGlzLkRVU1RfTUlOSU1VTSkpXG4gICAgICAgICAgaWYgKHJlc3VsdC5hbW91bnQuY29tcGFyZVRvKGR1c3RNaW4pIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFtb3VudCA9IGR1c3RNaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHByaWNlIG9mIGEgbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSB0aGUgbmFtZSB0byBxdWVyeVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdG8gYW4gT2JqZWN0IHdpdGggeyB1bml0czogU3RyaW5nLCBhbW91bnQ6IEJpZ0ludGVnZXIgfSwgd2hlcmVcbiAgICogICAudW5pdHMgZW5jb2RlcyB0aGUgY3J5cHRvY3VycmVuY3kgdW5pdHMgdG8gcGF5IChlLmcuIEJUQywgU1RBQ0tTKSwgYW5kXG4gICAqICAgLmFtb3VudCBlbmNvZGVzIHRoZSBudW1iZXIgb2YgdW5pdHMsIGluIHRoZSBzbWFsbGVzdCBkZW5vbWluaWF0ZWQgYW1vdW50XG4gICAqICAgKGUuZy4gaWYgLnVuaXRzIGlzIEJUQywgLmFtb3VudCB3aWxsIGJlIHNhdG9zaGlzOyBpZiAudW5pdHMgaXMgU1RBQ0tTLCBcbiAgICogICAuYW1vdW50IHdpbGwgYmUgbWljcm9TdGFja3MpXG4gICAqL1xuICBnZXROYW1lUHJpY2UoZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcpIDogUHJvbWlzZTwqPiB7XG4gICAgLy8gaGFuZGxlIHYxIG9yIHYyIFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHRoaXMuZ2V0TmFtZVByaWNlVjIoZnVsbHlRdWFsaWZpZWROYW1lKSlcbiAgICAgIC5jYXRjaCgoKSA9PiB0aGlzLmdldE5hbWVQcmljZVYxKGZ1bGx5UXVhbGlmaWVkTmFtZSkpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmljZSBvZiBhIG5hbWVzcGFjZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlSUQgdGhlIG5hbWVzcGFjZSB0byBxdWVyeVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdG8gYW4gT2JqZWN0IHdpdGggeyB1bml0czogU3RyaW5nLCBhbW91bnQ6IEJpZ0ludGVnZXIgfSwgd2hlcmVcbiAgICogICAudW5pdHMgZW5jb2RlcyB0aGUgY3J5cHRvY3VycmVuY3kgdW5pdHMgdG8gcGF5IChlLmcuIEJUQywgU1RBQ0tTKSwgYW5kXG4gICAqICAgLmFtb3VudCBlbmNvZGVzIHRoZSBudW1iZXIgb2YgdW5pdHMsIGluIHRoZSBzbWFsbGVzdCBkZW5vbWluaWF0ZWQgYW1vdW50XG4gICAqICAgKGUuZy4gaWYgLnVuaXRzIGlzIEJUQywgLmFtb3VudCB3aWxsIGJlIHNhdG9zaGlzOyBpZiAudW5pdHMgaXMgU1RBQ0tTLCBcbiAgICogICAuYW1vdW50IHdpbGwgYmUgbWljcm9TdGFja3MpXG4gICAqL1xuICBnZXROYW1lc3BhY2VQcmljZShuYW1lc3BhY2VJRDogc3RyaW5nKSA6IFByb21pc2U8Kj4ge1xuICAgIC8vIGhhbmRsZSB2MSBvciB2MiBcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0aGlzLmdldE5hbWVzcGFjZVByaWNlVjIobmFtZXNwYWNlSUQpKVxuICAgICAgLmNhdGNoKCgpID0+IHRoaXMuZ2V0TmFtZXNwYWNlUHJpY2VWMShuYW1lc3BhY2VJRCkpXG4gIH1cblxuICAvKipcbiAgICogSG93IG1hbnkgYmxvY2tzIGNhbiBwYXNzIGJldHdlZW4gYSBuYW1lIGV4cGlyaW5nIGFuZCB0aGUgbmFtZSBiZWluZyBhYmxlIHRvIGJlXG4gICAqIHJlLXJlZ2lzdGVyZWQgYnkgYSBkaWZmZXJlbnQgb3duZXI/XG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0byB0aGUgbnVtYmVyIG9mIGJsb2Nrc1xuICAgKi9cbiAgZ2V0R3JhY2VQZXJpb2QoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSg1MDAwKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZXMgLS0gYm90aCBvbi1jaGFpbiBhbmQgb2ZmLWNoYWluIC0tIG93bmVkIGJ5IGFuIGFkZHJlc3MuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBibG9ja2NoYWluIGFkZHJlc3MgKHRoZSBoYXNoIG9mIHRoZSBvd25lciBwdWJsaWMga2V5KVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGxpc3Qgb2YgbmFtZXMgKFN0cmluZ3MpXG4gICAqL1xuICBnZXROYW1lc093bmVkKGFkZHJlc3M6IHN0cmluZykge1xuICAgIGNvbnN0IG5ldHdvcmtBZGRyZXNzID0gdGhpcy5jb2VyY2VBZGRyZXNzKGFkZHJlc3MpXG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMuYmxvY2tzdGFja0FQSVVybH0vdjEvYWRkcmVzc2VzL2JpdGNvaW4vJHtuZXR3b3JrQWRkcmVzc31gKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKG9iaiA9PiBvYmoubmFtZXMpXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBibG9ja2NoYWluIGFkZHJlc3MgdG8gd2hpY2ggYSBuYW1lJ3MgcmVnaXN0cmF0aW9uIGZlZSBtdXN0IGJlIHNlbnRcbiAgICogKHRoZSBhZGRyZXNzIHdpbGwgZGVwZW5kIG9uIHRoZSBuYW1lc3BhY2UgaW4gd2hpY2ggaXQgaXMgcmVnaXN0ZXJlZC4pXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgdGhlIG5hbWVzcGFjZSBJRFxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhZGRyZXNzIChTdHJpbmcpXG4gICAqL1xuICBnZXROYW1lc3BhY2VCdXJuQWRkcmVzcyhuYW1lc3BhY2U6IHN0cmluZykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICBmZXRjaChgJHt0aGlzLmJsb2Nrc3RhY2tBUElVcmx9L3YxL25hbWVzcGFjZXMvJHtuYW1lc3BhY2V9YCksXG4gICAgICB0aGlzLmdldEJsb2NrSGVpZ2h0KClcbiAgICBdKVxuICAgICAgLnRoZW4oKFtyZXNwLCBibG9ja0hlaWdodF0pID0+IHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHN1Y2ggbmFtZXNwYWNlICcke25hbWVzcGFjZX0nYClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3Jlc3AuanNvbigpLCBibG9ja0hlaWdodF0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAudGhlbigoW25hbWVzcGFjZUluZm8sIGJsb2NrSGVpZ2h0XSkgPT4ge1xuICAgICAgICBsZXQgYWRkcmVzcyA9IHRoaXMuZ2V0RGVmYXVsdEJ1cm5BZGRyZXNzKClcbiAgICAgICAgaWYgKG5hbWVzcGFjZUluZm8udmVyc2lvbiA9PT0gMikge1xuICAgICAgICAgIC8vIHBheS10by1uYW1lc3BhY2UtY3JlYXRvciBpZiB0aGlzIG5hbWVzcGFjZSBpcyBsZXNzIHRoYW4gMSB5ZWFyIG9sZFxuICAgICAgICAgIGlmIChuYW1lc3BhY2VJbmZvLnJldmVhbF9ibG9jayArIDUyNTk1ID49IGJsb2NrSGVpZ2h0KSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gbmFtZXNwYWNlSW5mby5hZGRyZXNzXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGRyZXNzXG4gICAgICB9KVxuICAgICAgLnRoZW4oYWRkcmVzcyA9PiB0aGlzLmNvZXJjZUFkZHJlc3MoYWRkcmVzcykpXG4gIH1cblxuICAvKipcbiAgICogR2V0IFdIT0lTLWxpa2UgaW5mb3JtYXRpb24gZm9yIGEgbmFtZSwgaW5jbHVkaW5nIHRoZSBhZGRyZXNzIHRoYXQgb3ducyBpdCxcbiAgICogdGhlIGJsb2NrIGF0IHdoaWNoIGl0IGV4cGlyZXMsIGFuZCB0aGUgem9uZSBmaWxlIGFuY2hvcmVkIHRvIGl0IChpZiBhdmFpbGFibGUpLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZnVsbHlRdWFsaWZpZWROYW1lIHRoZSBuYW1lIHRvIHF1ZXJ5LiAgQ2FuIGJlIG9uLWNoYWluIG9mIG9mZi1jaGFpbi5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIFdIT0lTLWxpa2UgaW5mb3JtYXRpb24gXG4gICAqL1xuICBnZXROYW1lSW5mbyhmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZykge1xuICAgIExvZ2dlci5kZWJ1Zyh0aGlzLmJsb2Nrc3RhY2tBUElVcmwpXG4gICAgY29uc3QgbmFtZUxvb2t1cFVSTCA9IGAke3RoaXMuYmxvY2tzdGFja0FQSVVybH0vdjEvbmFtZXMvJHtmdWxseVF1YWxpZmllZE5hbWV9YFxuICAgIHJldHVybiBmZXRjaChuYW1lTG9va3VwVVJMKVxuICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWUgbm90IGZvdW5kJylcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgcmVzcG9uc2Ugc3RhdHVzOiAke3Jlc3Auc3RhdHVzfWApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3AuanNvbigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAudGhlbigobmFtZUluZm8pID0+IHtcbiAgICAgICAgTG9nZ2VyLmRlYnVnKGBuYW1lSW5mbzogJHtKU09OLnN0cmluZ2lmeShuYW1lSW5mbyl9YClcbiAgICAgICAgLy8gdGhlIHJldHVybmVkIGFkZHJlc3MgX3Nob3VsZF8gYmUgaW4gdGhlIGNvcnJlY3QgbmV0d29yayAtLS1cbiAgICAgICAgLy8gIGJsb2Nrc3RhY2tkIGdldHMgaW50byB0cm91YmxlIGJlY2F1c2UgaXQgdHJpZXMgdG8gY29lcmNlIGJhY2sgdG8gbWFpbm5ldFxuICAgICAgICAvLyAgYW5kIHRoZSByZWd0ZXN0IHRyYW5zYWN0aW9uIGdlbmVyYXRpb24gbGlicmFyaWVzIHdhbnQgdG8gdXNlIHRlc3RuZXQgYWRkcmVzc2VzXG4gICAgICAgIGlmIChuYW1lSW5mby5hZGRyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG5hbWVJbmZvLCB7IGFkZHJlc3M6IHRoaXMuY29lcmNlQWRkcmVzcyhuYW1lSW5mby5hZGRyZXNzKSB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuYW1lSW5mb1xuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgcHJpY2luZyBwYXJhbWV0ZXJzIGFuZCBjcmVhdGlvbiBoaXN0b3J5IG9mIGEgbmFtZXNwYWNlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlSUQgdGhlIG5hbWVzcGFjZSB0byBxdWVyeVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgbmFtZXNwYWNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZ2V0TmFtZXNwYWNlSW5mbyhuYW1lc3BhY2VJRDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMuYmxvY2tzdGFja0FQSVVybH0vdjEvbmFtZXNwYWNlcy8ke25hbWVzcGFjZUlEfWApXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZXNwYWNlIG5vdCBmb3VuZCcpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHJlc3BvbnNlIHN0YXR1czogJHtyZXNwLnN0YXR1c31gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXNwLmpzb24oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oKG5hbWVzcGFjZUluZm8pID0+IHtcbiAgICAgICAgLy8gdGhlIHJldHVybmVkIGFkZHJlc3MgX3Nob3VsZF8gYmUgaW4gdGhlIGNvcnJlY3QgbmV0d29yayAtLS1cbiAgICAgICAgLy8gIGJsb2Nrc3RhY2tkIGdldHMgaW50byB0cm91YmxlIGJlY2F1c2UgaXQgdHJpZXMgdG8gY29lcmNlIGJhY2sgdG8gbWFpbm5ldFxuICAgICAgICAvLyAgYW5kIHRoZSByZWd0ZXN0IHRyYW5zYWN0aW9uIGdlbmVyYXRpb24gbGlicmFyaWVzIHdhbnQgdG8gdXNlIHRlc3RuZXQgYWRkcmVzc2VzXG4gICAgICAgIGlmIChuYW1lc3BhY2VJbmZvLmFkZHJlc3MgJiYgbmFtZXNwYWNlSW5mby5yZWNpcGllbnRfYWRkcmVzcykge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBuYW1lc3BhY2VJbmZvLCB7XG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmNvZXJjZUFkZHJlc3MobmFtZXNwYWNlSW5mby5hZGRyZXNzKSxcbiAgICAgICAgICAgIHJlY2lwaWVudF9hZGRyZXNzOiB0aGlzLmNvZXJjZUFkZHJlc3MobmFtZXNwYWNlSW5mby5yZWNpcGllbnRfYWRkcmVzcylcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBuYW1lc3BhY2VJbmZvXG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgem9uZSBmaWxlLCBnaXZlbiBpdHMgaGFzaC4gIFRocm93cyBhbiBleGNlcHRpb24gaWYgdGhlIHpvbmUgZmlsZVxuICAgKiBvYnRhaW5lZCBkb2VzIG5vdCBtYXRjaCB0aGUgaGFzaC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHpvbmVmaWxlSGFzaCB0aGUgcmlwZW1kMTYwKHNoYTI1NikgaGFzaCBvZiB0aGUgem9uZSBmaWxlXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSB6b25lIGZpbGUncyB0ZXh0XG4gICAqL1xuICBnZXRab25lZmlsZSh6b25lZmlsZUhhc2g6IHN0cmluZykge1xuICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmJsb2Nrc3RhY2tBUElVcmx9L3YxL3pvbmVmaWxlcy8ke3pvbmVmaWxlSGFzaH1gKVxuICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC50ZXh0KClcbiAgICAgICAgICAgIC50aGVuKChib2R5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHNoYTI1NiA9IGJpdGNvaW5qcy5jcnlwdG8uc2hhMjU2KGJvZHkpXG4gICAgICAgICAgICAgIGNvbnN0IGggPSAobmV3IFJJUEVNRDE2MCgpKS51cGRhdGUoc2hhMjU2KS5kaWdlc3QoJ2hleCcpXG4gICAgICAgICAgICAgIGlmIChoICE9PSB6b25lZmlsZUhhc2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFpvbmUgZmlsZSBjb250ZW50cyBoYXNoIHRvICR7aH0sIG5vdCAke3pvbmVmaWxlSGFzaH1gKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBib2R5XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHJlc3BvbnNlIHN0YXR1czogJHtyZXNwLnN0YXR1c31gKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIG9mIGFuIGFjY291bnQgZm9yIGEgcGFydGljdWxhciB0b2tlbiBob2xkaW5nLiAgVGhpcyBpbmNsdWRlcyBpdHMgdG90YWwgbnVtYmVyIG9mXG4gICAqIGV4cGVuZGl0dXJlcyBhbmQgY3JlZGl0cywgbG9ja3VwIHRpbWVzLCBsYXN0IHR4aWQsIGFuZCBzbyBvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRva2VuVHlwZSB0aGUgdG9rZW4gdHlwZSB0byBxdWVyeVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgYWNjb3VudFxuICAgKiAgIGZvciB0aGlzIHRva2VuXG4gICAqL1xuICBnZXRBY2NvdW50U3RhdHVzKGFkZHJlc3M6IHN0cmluZywgdG9rZW5UeXBlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92MS9hY2NvdW50cy8ke2FkZHJlc3N9LyR7dG9rZW5UeXBlfS9zdGF0dXNgKVxuICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJylcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgcmVzcG9uc2Ugc3RhdHVzOiAke3Jlc3Auc3RhdHVzfWApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3AuanNvbigpXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oKGFjY291bnRTdGF0dXMpID0+IHtcbiAgICAgICAgLy8gY29lcmNlIGFsbCBhZGRyZXNzZXMsIGFuZCBjb252ZXJ0IGNyZWRpdC9kZWJpdCB0byBiaWdpbnRlZ2VyXG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZFN0YXR1cyA9IE9iamVjdC5hc3NpZ24oe30sIGFjY291bnRTdGF0dXMsIHtcbiAgICAgICAgICBhZGRyZXNzOiB0aGlzLmNvZXJjZUFkZHJlc3MoYWNjb3VudFN0YXR1cy5hZGRyZXNzKSxcbiAgICAgICAgICBkZWJpdF92YWx1ZTogYmlnaS5mcm9tQnl0ZUFycmF5VW5zaWduZWQoU3RyaW5nKGFjY291bnRTdGF0dXMuZGViaXRfdmFsdWUpKSxcbiAgICAgICAgICBjcmVkaXRfdmFsdWU6IGJpZ2kuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKFN0cmluZyhhY2NvdW50U3RhdHVzLmNyZWRpdF92YWx1ZSkpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWRTdGF0dXNcbiAgICAgIH0pXG4gIH1cbiAgXG4gIFxuICAvKipcbiAgICogR2V0IGEgcGFnZSBvZiBhbiBhY2NvdW50J3MgdHJhbnNhY3Rpb24gaGlzdG9yeS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGFjY291bnQncyBhZGRyZXNzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlIHRoZSBwYWdlIG51bWJlci4gIFBhZ2UgMCBpcyB0aGUgbW9zdCByZWNlbnQgdHJhbnNhY3Rpb25zXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEFycmF5IG9mIE9iamVjdHMsIHdoZXJlIGVhY2ggT2JqZWN0IGVuY29kZXNcbiAgICogICBzdGF0ZXMgb2YgdGhlIGFjY291bnQgYXQgdmFyaW91cyBibG9jayBoZWlnaHRzIChlLmcuIHByaW9yIGJhbGFuY2VzLCB0eGlkcywgZXRjKVxuICAgKi9cbiAgZ2V0QWNjb3VudEhpc3RvcnlQYWdlKGFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2U6IG51bWJlcikgOiBQcm9taXNlPCo+IHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJsb2Nrc3RhY2tBUElVcmx9L3YxL2FjY291bnRzLyR7YWRkcmVzc30vaGlzdG9yeT9wYWdlPSR7cGFnZX1gXG4gICAgcmV0dXJuIGZldGNoKHVybClcbiAgICAgIC50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IG5vdCBmb3VuZCcpXG4gICAgICAgIH0gZWxzZSBpZiAocmVzcC5zdGF0dXMgIT09IDIwMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIHJlc3BvbnNlIHN0YXR1czogJHtyZXNwLnN0YXR1c31gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZXNwLmpzb24oKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLnRoZW4oKGhpc3RvcnlMaXN0KSA9PiB7XG4gICAgICAgIGlmIChoaXN0b3J5TGlzdC5lcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBhY2NvdW50IGhpc3RvcnkgcGFnZTogJHtoaXN0b3J5TGlzdC5lcnJvcn1gKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvZXJzZSBhbGwgYWRkcmVzc2VzIGFuZCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICByZXR1cm4gaGlzdG9yeUxpc3QubWFwKChoaXN0RW50cnkpID0+IHtcbiAgICAgICAgICBoaXN0RW50cnkuYWRkcmVzcyA9IHRoaXMuY29lcmNlQWRkcmVzcyhoaXN0RW50cnkuYWRkcmVzcylcbiAgICAgICAgICBoaXN0RW50cnkuZGViaXRfdmFsdWUgPSBiaWdpLmZyb21CeXRlQXJyYXlVbnNpZ25lZChTdHJpbmcoaGlzdEVudHJ5LmRlYml0X3ZhbHVlKSlcbiAgICAgICAgICBoaXN0RW50cnkuY3JlZGl0X3ZhbHVlID0gYmlnaS5mcm9tQnl0ZUFycmF5VW5zaWduZWQoU3RyaW5nKGhpc3RFbnRyeS5jcmVkaXRfdmFsdWUpKVxuICAgICAgICAgIHJldHVybiBoaXN0RW50cnlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0ZShzKSBvZiBhbiBhY2NvdW50IGF0IGEgcGFydGljdWxhciBibG9jayBoZWlnaHQuICBUaGlzIGluY2x1ZGVzIHRoZSBzdGF0ZSBvZiB0aGVcbiAgICogYWNjb3VudCBiZWdpbm5pbmcgd2l0aCB0aGlzIGJsb2NrJ3MgdHJhbnNhY3Rpb25zLCBhcyB3ZWxsIGFzIGFsbCBvZiB0aGUgc3RhdGVzIHRoZSBhY2NvdW50XG4gICAqIHBhc3NlZCB0aHJvdWdoIHdoZW4gdGhpcyBibG9jayB3YXMgcHJvY2Vzc2VkIChpZiBhbnkpLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgYWNjb3VudCdzIGFkZHJlc3NcbiAgICogQHBhcmFtIHtJbnRlZ2VyfSBibG9ja0hlaWdodCB0aGUgYmxvY2sgdG8gcXVlcnlcbiAgICogQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gQXJyYXkgb2YgT2JqZWN0cywgd2hlcmUgZWFjaCBPYmplY3QgZW5jb2Rlc1xuICAgKiAgIHN0YXRlcyBvZiB0aGUgYWNjb3VudCBhdCB0aGlzIGJsb2NrLlxuICAgKi9cbiAgZ2V0QWNjb3VudEF0KGFkZHJlc3M6IHN0cmluZywgYmxvY2tIZWlnaHQ6IG51bWJlcikgOiBQcm9taXNlPCo+IHtcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJsb2Nrc3RhY2tBUElVcmx9L3YxL2FjY291bnRzLyR7YWRkcmVzc30vaGlzdG9yeS8ke2Jsb2NrSGVpZ2h0fWBcbiAgICByZXR1cm4gZmV0Y2godXJsKVxuICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgaWYgKHJlc3Auc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnQgbm90IGZvdW5kJylcbiAgICAgICAgfSBlbHNlIGlmIChyZXNwLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgcmVzcG9uc2Ugc3RhdHVzOiAke3Jlc3Auc3RhdHVzfWApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3AuanNvbigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAudGhlbigoaGlzdG9yeUxpc3QpID0+IHtcbiAgICAgICAgaWYgKGhpc3RvcnlMaXN0LmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gZ2V0IGhpc3RvcmljIGFjY291bnQgc3RhdGU6ICR7aGlzdG9yeUxpc3QuZXJyb3J9YClcbiAgICAgICAgfVxuICAgICAgICAvLyBjb2VyY2UgYWxsIGFkZHJlc3NlcyBcbiAgICAgICAgcmV0dXJuIGhpc3RvcnlMaXN0Lm1hcCgoaGlzdEVudHJ5KSA9PiB7XG4gICAgICAgICAgaGlzdEVudHJ5LmFkZHJlc3MgPSB0aGlzLmNvZXJjZUFkZHJlc3MoaGlzdEVudHJ5LmFkZHJlc3MpXG4gICAgICAgICAgaGlzdEVudHJ5LmRlYml0X3ZhbHVlID0gYmlnaS5mcm9tQnl0ZUFycmF5VW5zaWduZWQoU3RyaW5nKGhpc3RFbnRyeS5kZWJpdF92YWx1ZSkpXG4gICAgICAgICAgaGlzdEVudHJ5LmNyZWRpdF92YWx1ZSA9IGJpZ2kuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKFN0cmluZyhoaXN0RW50cnkuY3JlZGl0X3ZhbHVlKSlcbiAgICAgICAgICByZXR1cm4gaGlzdEVudHJ5XG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2V0IG9mIHRva2VuIHR5cGVzIHRoYXQgdGhpcyBhY2NvdW50IG93bnNcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGFjY291bnQncyBhZGRyZXNzXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIEFycmF5IG9mIFN0cmluZ3MsIHdoZXJlIGVhY2ggaXRlbSBlbmNvZGVzIHRoZSBcbiAgICogICB0eXBlIG9mIHRva2VuIHRoaXMgYWNjb3VudCBob2xkcyAoZXhjbHVkaW5nIHRoZSB1bmRlcmx5aW5nIGJsb2NrY2hhaW4ncyB0b2tlbnMpXG4gICAqL1xuICBnZXRBY2NvdW50VG9rZW5zKGFkZHJlc3M6IHN0cmluZykgOiBQcm9taXNlPCo+IHtcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92MS9hY2NvdW50cy8ke2FkZHJlc3N9L3Rva2Vuc2ApXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBub3QgZm91bmQnKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCByZXNwb25zZSBzdGF0dXM6ICR7cmVzcC5zdGF0dXN9YClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC5qc29uKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC50aGVuKCh0b2tlbkxpc3QpID0+IHtcbiAgICAgICAgaWYgKHRva2VuTGlzdC5lcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCB0b2tlbiBsaXN0OiAke3Rva2VuTGlzdC5lcnJvcn1gKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbkxpc3RcbiAgICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBudW1iZXIgb2YgdG9rZW5zIG93bmVkIGJ5IGFuIGFjY291bnQuICBJZiB0aGUgYWNjb3VudCBkb2VzIG5vdCBleGlzdCBvciBoYXMgbm9cbiAgICogdG9rZW5zIG9mIHRoaXMgdHlwZSwgdGhlbiAwIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBhY2NvdW50J3MgYWRkcmVzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5UeXBlIHRoZSB0eXBlIG9mIHRva2VuIHRvIHF1ZXJ5LlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIEJpZ0ludGVnZXIgdGhhdCBlbmNvZGVzIHRoZSBudW1iZXIgb2YgdG9rZW5zIFxuICAgKiAgIGhlbGQgYnkgdGhpcyBhY2NvdW50LlxuICAgKi9cbiAgZ2V0QWNjb3VudEJhbGFuY2UoYWRkcmVzczogc3RyaW5nLCB0b2tlblR5cGU6IHN0cmluZykgOiBQcm9taXNlPCo+IHtcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92MS9hY2NvdW50cy8ke2FkZHJlc3N9LyR7dG9rZW5UeXBlfS9iYWxhbmNlYClcbiAgICAgIC50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgLy8gdGFsa2luZyB0byBhbiBvbGRlciBibG9ja3N0YWNrIGNvcmUgbm9kZSB3aXRob3V0IHRoZSBhY2NvdW50cyBBUElcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiBiaWdpLmZyb21CeXRlQXJyYXlVbnNpZ25lZCgnMCcpKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc3Auc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCByZXNwb25zZSBzdGF0dXM6ICR7cmVzcC5zdGF0dXN9YClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC5qc29uKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC50aGVuKCh0b2tlbkJhbGFuY2UpID0+IHtcbiAgICAgICAgaWYgKHRva2VuQmFsYW5jZS5lcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGdldCBhY2NvdW50IGJhbGFuY2U6ICR7dG9rZW5CYWxhbmNlLmVycm9yfWApXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJhbGFuY2UgPSAnMCdcbiAgICAgICAgaWYgKHRva2VuQmFsYW5jZSAmJiB0b2tlbkJhbGFuY2UuYmFsYW5jZSkge1xuICAgICAgICAgIGJhbGFuY2UgPSB0b2tlbkJhbGFuY2UuYmFsYW5jZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiaWdpLmZyb21CeXRlQXJyYXlVbnNpZ25lZChiYWxhbmNlKVxuICAgICAgfSlcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGEgUE9TVCByZXF1ZXN0IHRvIHRoZSBnaXZlbiBVUkxcbiAgICogQHBhcmFtICB7U3RyaW5nfSBlbmRwb2ludCAgdGhlIG5hbWUgb2ZcbiAgICogQHBhcmFtICB7U3RyaW5nfSBib2R5IFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3R8RXJyb3I+fSBSZXR1cm5zIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG9iamVjdCByZXF1ZXN0ZWQuXG4gICAqIEluIHRoZSBldmVudCBvZiBhbiBlcnJvciwgaXQgcmVqZWN0cyB3aXRoOlxuICAgKiAqIGEgYFJlbW90ZVNlcnZpY2VFcnJvcmAgaWYgdGhlcmUgaXMgYSBwcm9ibGVtXG4gICAqIHdpdGggdGhlIHRyYW5zYWN0aW9uIGJyb2FkY2FzdCBzZXJ2aWNlXG4gICAqICogYE1pc3NpbmdQYXJhbWV0ZXJFcnJvcmAgaWYgeW91IGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGhvdXQgYSByZXF1aXJlZFxuICAgKiBwYXJhbWV0ZXJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJyb2FkY2FzdFNlcnZpY2VGZXRjaEhlbHBlcihlbmRwb2ludDogc3RyaW5nLCBib2R5OiBPYmplY3QpIDogUHJvbWlzZTxPYmplY3R8RXJyb3I+IHtcbiAgICBjb25zdCByZXF1ZXN0SGVhZGVycyA9IHtcbiAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3RIZWFkZXJzLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9XG5cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJyb2FkY2FzdFNlcnZpY2VVcmx9L3YxL2Jyb2FkY2FzdC8ke2VuZHBvaW50fWBcbiAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmVtb3RlU2VydmljZUVycm9yKHJlc3BvbnNlKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICogQnJvYWRjYXN0cyBhIHNpZ25lZCBiaXRjb2luIHRyYW5zYWN0aW9uIHRvIHRoZSBuZXR3b3JrIG9wdGlvbmFsbHkgd2FpdGluZyB0byBicm9hZGNhc3QgdGhlXG4gICogdHJhbnNhY3Rpb24gdW50aWwgYSBzZWNvbmQgdHJhbnNhY3Rpb24gaGFzIGEgY2VydGFpbiBudW1iZXIgb2YgY29uZmlybWF0aW9ucy5cbiAgKlxuICAqIEBwYXJhbSAge3N0cmluZ30gdHJhbnNhY3Rpb24gdGhlIGhleC1lbmNvZGVkIHRyYW5zYWN0aW9uIHRvIGJyb2FkY2FzdFxuICAqIEBwYXJhbSAge3N0cmluZ30gdHJhbnNhY3Rpb25Ub1dhdGNoIHRoZSBoZXggdHJhbnNhY3Rpb24gaWQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIHdhdGNoIGZvclxuICAqIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgYmVmb3JlIGJyb2FkY2FzdGluZyB0aGUgYHRyYW5zYWN0aW9uYFxuICAqIEBwYXJhbSAge251bWJlcn0gY29uZmlybWF0aW9ucyB0aGUgbnVtYmVyIG9mIGNvbmZpcm1hdGlvbnMgYHRyYW5zYWN0aW9uVG9XYXRjaGAgbXVzdCBoYXZlXG4gICogYmVmb3JlIGJyb2FkY2FzdGluZyBgdHJhbnNhY3Rpb25gLlxuICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0fEVycm9yPn0gUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3Qgd2l0aCBhXG4gICogYHRyYW5zYWN0aW9uX2hhc2hgIGtleSBjb250YWluaW5nIHRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSBicm9hZGNhc3RlZCB0cmFuc2FjdGlvbi5cbiAgKlxuICAqIEluIHRoZSBldmVudCBvZiBhbiBlcnJvciwgaXQgcmVqZWN0cyB3aXRoOlxuICAqICogYSBgUmVtb3RlU2VydmljZUVycm9yYCBpZiB0aGVyZSBpcyBhIHByb2JsZW1cbiAgKiAgIHdpdGggdGhlIHRyYW5zYWN0aW9uIGJyb2FkY2FzdCBzZXJ2aWNlXG4gICogKiBgTWlzc2luZ1BhcmFtZXRlckVycm9yYCBpZiB5b3UgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aG91dCBhIHJlcXVpcmVkXG4gICogICBwYXJhbWV0ZXJcbiAgKiBAcHJpdmF0ZVxuICAqL1xuICBicm9hZGNhc3RUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblRvV2F0Y2g6ID9zdHJpbmcgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiBudW1iZXIgPSA2KSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCd0cmFuc2FjdGlvbicpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKCFjb25maXJtYXRpb25zICYmIGNvbmZpcm1hdGlvbnMgIT09IDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcignY29uZmlybWF0aW9ucycpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKHRyYW5zYWN0aW9uVG9XYXRjaCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYnRjLmJyb2FkY2FzdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICAvKlxuICAgICAgICogUE9TVCAvdjEvYnJvYWRjYXN0L3RyYW5zYWN0aW9uXG4gICAgICAgKiBSZXF1ZXN0IGJvZHk6XG4gICAgICAgKiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgKiAgdHJhbnNhY3Rpb24sXG4gICAgICAgKiAgdHJhbnNhY3Rpb25Ub1dhdGNoLFxuICAgICAgICogIGNvbmZpcm1hdGlvbnNcbiAgICAgICAqIH0pXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGVuZHBvaW50ID0gVFhfQlJPQURDQVNUX1NFUlZJQ0VfVFhfRU5EUE9JTlRcblxuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB0cmFuc2FjdGlvblRvV2F0Y2gsXG4gICAgICAgIGNvbmZpcm1hdGlvbnNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0U2VydmljZUZldGNoSGVscGVyKGVuZHBvaW50LCByZXF1ZXN0Qm9keSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnJvYWRjYXN0cyBhIHpvbmUgZmlsZSB0byB0aGUgQXRsYXMgbmV0d29yayB2aWEgdGhlIHRyYW5zYWN0aW9uIGJyb2FkY2FzdCBzZXJ2aWNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IHpvbmVGaWxlIHRoZSB6b25lIGZpbGUgdG8gYmUgYnJvYWRjYXN0IHRvIHRoZSBBdGxhcyBuZXR3b3JrXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHJhbnNhY3Rpb25Ub1dhdGNoIHRoZSBoZXggdHJhbnNhY3Rpb24gaWQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gICAqIHRvIHdhdGNoIGZvciBjb25maXJtYXRpb24gYmVmb3JlIGJyb2FkY2FzdGluZyB0aGUgem9uZSBmaWxlIHRvIHRoZSBBdGxhcyBuZXR3b3JrXG4gICAqIEByZXR1cm4ge1Byb21pc2U8T2JqZWN0fEVycm9yPn0gUmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBvYmplY3Qgd2l0aCBhXG4gICAqIGB0cmFuc2FjdGlvbl9oYXNoYCBrZXkgY29udGFpbmluZyB0aGUgdHJhbnNhY3Rpb24gaGFzaCBvZiB0aGUgYnJvYWRjYXN0ZWQgdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIEluIHRoZSBldmVudCBvZiBhbiBlcnJvciwgaXQgcmVqZWN0cyB3aXRoOlxuICAgKiAqIGEgYFJlbW90ZVNlcnZpY2VFcnJvcmAgaWYgdGhlcmUgaXMgYSBwcm9ibGVtXG4gICAqICAgd2l0aCB0aGUgdHJhbnNhY3Rpb24gYnJvYWRjYXN0IHNlcnZpY2VcbiAgICogKiBgTWlzc2luZ1BhcmFtZXRlckVycm9yYCBpZiB5b3UgY2FsbCB0aGUgZnVuY3Rpb24gd2l0aG91dCBhIHJlcXVpcmVkXG4gICAqICAgcGFyYW1ldGVyXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBicm9hZGNhc3Rab25lRmlsZSh6b25lRmlsZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvblRvV2F0Y2g6ID9zdHJpbmcgPSBudWxsKSB7XG4gICAgaWYgKCF6b25lRmlsZSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBNaXNzaW5nUGFyYW1ldGVyRXJyb3IoJ3pvbmVGaWxlJykpXG4gICAgfVxuXG4gICAgLy8gVE9ETzogdmFsaWRhdGUgem9uZWZpbGVcblxuICAgIGlmICh0cmFuc2FjdGlvblRvV2F0Y2gpIHtcbiAgICAgIC8vIGJyb2FkY2FzdCB2aWEgdHJhbnNhY3Rpb24gYnJvYWRjYXN0IHNlcnZpY2VcblxuICAgICAgLypcbiAgICAgICAqIFBPU1QgL3YxL2Jyb2FkY2FzdC96b25lLWZpbGVcbiAgICAgICAqIFJlcXVlc3QgYm9keTpcbiAgICAgICAqIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAqICB6b25lRmlsZSxcbiAgICAgICAqICB0cmFuc2FjdGlvblRvV2F0Y2hcbiAgICAgICAqIH0pXG4gICAgICAgKi9cblxuICAgICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICAgIHpvbmVGaWxlLFxuICAgICAgICB0cmFuc2FjdGlvblRvV2F0Y2hcbiAgICAgIH1cblxuICAgICAgY29uc3QgZW5kcG9pbnQgPSBUWF9CUk9BRENBU1RfU0VSVklDRV9aT05FX0ZJTEVfRU5EUE9JTlRcblxuICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0U2VydmljZUZldGNoSGVscGVyKGVuZHBvaW50LCByZXF1ZXN0Qm9keSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnJvYWRjYXN0IHZpYSBjb3JlIGVuZHBvaW50XG5cbiAgICAgIC8vIHpvbmUgZmlsZSBpcyB0d28gd29yZHMgYnV0IGNvcmUncyBhcGkgdHJlYXRzIGl0IGFzIG9uZSB3b3JkICd6b25lZmlsZSdcbiAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0geyB6b25lZmlsZTogem9uZUZpbGUgfVxuXG4gICAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92MS96b25lZmlsZS9gLFxuICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgICBjb25zdCBqc29uID0gcmVzcC5qc29uKClcbiAgICAgICAgICByZXR1cm4ganNvblxuICAgICAgICAgICAgLnRoZW4oKHJlc3BPYmopID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJlc3BPYmouaGFzT3duUHJvcGVydHkoJ2Vycm9yJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmVtb3RlU2VydmljZUVycm9yKHJlc3ApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BPYmouc2VydmVyc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgdGhlIHByZW9yZGVyIGFuZCByZWdpc3RyYXRpb24gdHJhbnNhY3Rpb25zIGFuZCB6b25lIGZpbGVcbiAgICogZm9yIGEgQmxvY2tzdGFjayBuYW1lIHJlZ2lzdHJhdGlvblxuICAgKiBhbG9uZyB3aXRoIHRoZSB0byB0aGUgdHJhbnNhY3Rpb24gYnJvYWRjYXN0IHNlcnZpY2UuXG4gICAqXG4gICAqIFRoZSB0cmFuc2FjdGlvbiBicm9hZGNhc3Q6XG4gICAqXG4gICAqICogaW1tZWRpYXRlbHkgYnJvYWRjYXN0cyB0aGUgcHJlb3JkZXIgdHJhbnNhY3Rpb25cbiAgICogKiBicm9hZGNhc3RzIHRoZSByZWdpc3RlciB0cmFuc2FjdGlvbnMgYWZ0ZXIgdGhlIHByZW9yZGVyIHRyYW5zYWN0aW9uXG4gICAqIGhhcyBhbiBhcHByb3ByaWF0ZSBudW1iZXIgb2YgY29uZmlybWF0aW9uc1xuICAgKiAqIGJyb2FkY2FzdHMgdGhlIHpvbmUgZmlsZSB0byB0aGUgQXRsYXMgbmV0d29yayBhZnRlciB0aGUgcmVnaXN0ZXIgdHJhbnNhY3Rpb25cbiAgICogaGFzIGFuIGFwcHJvcHJpYXRlIG51bWJlciBvZiBjb25maXJtYXRpb25zXG4gICAqXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcHJlb3JkZXJUcmFuc2FjdGlvbiB0aGUgaGV4LWVuY29kZWQsIHNpZ25lZCBwcmVvcmRlciB0cmFuc2FjdGlvbiBnZW5lcmF0ZWRcbiAgICogdXNpbmcgdGhlIGBtYWtlUHJlb3JkZXJgIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gcmVnaXN0ZXJUcmFuc2FjdGlvbiB0aGUgaGV4LWVuY29kZWQsIHNpZ25lZCByZWdpc3RlciB0cmFuc2FjdGlvbiBnZW5lcmF0ZWRcbiAgICogdXNpbmcgdGhlIGBtYWtlUmVnaXN0ZXJgIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSAge1N0cmluZ30gem9uZUZpbGUgdGhlIHpvbmUgZmlsZSB0byBiZSBicm9hZGNhc3QgdG8gdGhlIEF0bGFzIG5ldHdvcmtcbiAgICogQHJldHVybiB7UHJvbWlzZTxPYmplY3R8RXJyb3I+fSBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIG9iamVjdCB3aXRoIGFcbiAgICogYHRyYW5zYWN0aW9uX2hhc2hgIGtleSBjb250YWluaW5nIHRoZSB0cmFuc2FjdGlvbiBoYXNoIG9mIHRoZSBicm9hZGNhc3RlZCB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogSW4gdGhlIGV2ZW50IG9mIGFuIGVycm9yLCBpdCByZWplY3RzIHdpdGg6XG4gICAqICogYSBgUmVtb3RlU2VydmljZUVycm9yYCBpZiB0aGVyZSBpcyBhIHByb2JsZW1cbiAgICogICB3aXRoIHRoZSB0cmFuc2FjdGlvbiBicm9hZGNhc3Qgc2VydmljZVxuICAgKiAqIGBNaXNzaW5nUGFyYW1ldGVyRXJyb3JgIGlmIHlvdSBjYWxsIHRoZSBmdW5jdGlvbiB3aXRob3V0IGEgcmVxdWlyZWRcbiAgICogICBwYXJhbWV0ZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGJyb2FkY2FzdE5hbWVSZWdpc3RyYXRpb24ocHJlb3JkZXJUcmFuc2FjdGlvbjogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyVHJhbnNhY3Rpb246IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6b25lRmlsZTogc3RyaW5nKSB7XG4gICAgLypcbiAgICAgICAqIFBPU1QgL3YxL2Jyb2FkY2FzdC9yZWdpc3RyYXRpb25cbiAgICAgICAqIFJlcXVlc3QgYm9keTpcbiAgICAgICAqIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAqIHByZW9yZGVyVHJhbnNhY3Rpb24sXG4gICAgICAgKiByZWdpc3RlclRyYW5zYWN0aW9uLFxuICAgICAgICogem9uZUZpbGVcbiAgICAgICAqIH0pXG4gICAgICAgKi9cblxuICAgIGlmICghcHJlb3JkZXJUcmFuc2FjdGlvbikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCdwcmVvcmRlclRyYW5zYWN0aW9uJylcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcilcbiAgICB9XG5cbiAgICBpZiAoIXJlZ2lzdGVyVHJhbnNhY3Rpb24pIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IE1pc3NpbmdQYXJhbWV0ZXJFcnJvcigncmVnaXN0ZXJUcmFuc2FjdGlvbicpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgfVxuXG4gICAgaWYgKCF6b25lRmlsZSkge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgTWlzc2luZ1BhcmFtZXRlckVycm9yKCd6b25lRmlsZScpXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpXG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdEJvZHkgPSB7XG4gICAgICBwcmVvcmRlclRyYW5zYWN0aW9uLFxuICAgICAgcmVnaXN0ZXJUcmFuc2FjdGlvbixcbiAgICAgIHpvbmVGaWxlXG4gICAgfVxuXG4gICAgY29uc3QgZW5kcG9pbnQgPSBUWF9CUk9BRENBU1RfU0VSVklDRV9SRUdJU1RSQVRJT05fRU5EUE9JTlRcblxuICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdFNlcnZpY2VGZXRjaEhlbHBlcihlbmRwb2ludCwgcmVxdWVzdEJvZHkpXG4gIH1cblxuICBnZXRGZWVSYXRlKCkgOiBQcm9taXNlPG51bWJlcj4ge1xuICAgIHJldHVybiBmZXRjaCgnaHR0cHM6Ly9iaXRjb2luZmVlcy5lYXJuLmNvbS9hcGkvdjEvZmVlcy9yZWNvbW1lbmRlZCcpXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AuanNvbigpKVxuICAgICAgLnRoZW4ocmF0ZXMgPT4gTWF0aC5mbG9vcihyYXRlcy5mYXN0ZXN0RmVlKSlcbiAgfVxuXG4gIGNvdW50RHVzdE91dHB1dHMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQuJylcbiAgfVxuXG4gIGdldFVUWE9zKGFkZHJlc3M6IHN0cmluZykgOiBQcm9taXNlPEFycmF5PFVUWE8+PiB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmV0d29ya2VkVVRYT3MoYWRkcmVzcylcbiAgICAgIC50aGVuKChuZXR3b3JrZWRVVFhPcykgPT4ge1xuICAgICAgICBsZXQgcmV0dXJuU2V0ID0gbmV0d29ya2VkVVRYT3MuY29uY2F0KClcbiAgICAgICAgaWYgKHRoaXMuaW5jbHVkZVV0eG9NYXAuaGFzT3duUHJvcGVydHkoYWRkcmVzcykpIHtcbiAgICAgICAgICByZXR1cm5TZXQgPSBuZXR3b3JrZWRVVFhPcy5jb25jYXQodGhpcy5pbmNsdWRlVXR4b01hcFthZGRyZXNzXSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFhcm9uOiBJIGFtICp3ZWxsKiBhd2FyZSB0aGlzIGlzIE8obikqTyhtKSBydW50aW1lXG4gICAgICAgIC8vICAgIGhvd2V2ZXIsIGNsaWVudHMgc2hvdWxkIGNsZWFyIHRoZSBleGNsdWRlIHNldCBwZXJpb2RpY2FsbHlcbiAgICAgICAgY29uc3QgZXhjbHVkZVNldCA9IHRoaXMuZXhjbHVkZVV0eG9TZXRcbiAgICAgICAgcmV0dXJuU2V0ID0gcmV0dXJuU2V0LmZpbHRlcihcbiAgICAgICAgICAodXR4bykgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5FeGNsdWRlU2V0ID0gZXhjbHVkZVNldC5yZWR1Y2UoXG4gICAgICAgICAgICAgIChpblNldCwgdXR4b1RvQ2hlY2spID0+IGluU2V0IHx8ICh1dHhvVG9DaGVjay50eF9oYXNoID09PSB1dHhvLnR4X2hhc2hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgdXR4b1RvQ2hlY2sudHhfb3V0cHV0X24gPT09IHV0eG8udHhfb3V0cHV0X24pLCBmYWxzZVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgcmV0dXJuICFpbkV4Y2x1ZGVTZXRcbiAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICByZXR1cm4gcmV0dXJuU2V0XG4gICAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCBtb2RpZnkgdGhlIG5ldHdvcmsncyB1dHhvIHNldCB0byBpbmNsdWRlIFVUWE9zXG4gICAqICBmcm9tIHRoZSBnaXZlbiB0cmFuc2FjdGlvbiBhbmQgZXhjbHVkZSBVVFhPcyAqc3BlbnQqIGluXG4gICAqICB0aGF0IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eEhleCAtIHRoZSBoZXgtZW5jb2RlZCB0cmFuc2FjdGlvbiB0byB1c2VcbiAgICogQHJldHVybiB7dm9pZH0gbm8gcmV0dXJuIHZhbHVlLCB0aGlzIG1vZGlmaWVzIHRoZSBVVFhPIGNvbmZpZyBzdGF0ZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbW9kaWZ5VVRYT1NldEZyb20odHhIZXg6IHN0cmluZykge1xuICAgIGNvbnN0IHR4ID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uLmZyb21IZXgodHhIZXgpXG5cbiAgICBjb25zdCBleGNsdWRlU2V0OiBBcnJheTxVVFhPPiA9IHRoaXMuZXhjbHVkZVV0eG9TZXQuY29uY2F0KClcblxuICAgIHR4Lmlucy5mb3JFYWNoKCh1dHhvVXNlZCkgPT4ge1xuICAgICAgY29uc3QgcmV2ZXJzZUhhc2ggPSBCdWZmZXIuZnJvbSh1dHhvVXNlZC5oYXNoKVxuICAgICAgcmV2ZXJzZUhhc2gucmV2ZXJzZSgpXG4gICAgICBleGNsdWRlU2V0LnB1c2goe1xuICAgICAgICB0eF9oYXNoOiByZXZlcnNlSGFzaC50b1N0cmluZygnaGV4JyksXG4gICAgICAgIHR4X291dHB1dF9uOiB1dHhvVXNlZC5pbmRleFxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgdGhpcy5leGNsdWRlVXR4b1NldCA9IGV4Y2x1ZGVTZXRcblxuICAgIGNvbnN0IHR4SGFzaCA9IHR4LmdldEhhc2goKS5yZXZlcnNlKCkudG9TdHJpbmcoJ2hleCcpXG4gICAgdHgub3V0cy5mb3JFYWNoKCh1dHhvQ3JlYXRlZCwgdHhPdXRwdXROKSA9PiB7XG4gICAgICBjb25zdCBpc051bGxEYXRhID0gZnVuY3Rpb24gaXNOdWxsRGF0YShzY3JpcHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBiaXRjb2luanMucGF5bWVudHMuZW1iZWQoeyBvdXRwdXQ6IHNjcmlwdCB9LCB7IHZhbGlkYXRlOiB0cnVlIH0pXG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXNOdWxsRGF0YSh1dHhvQ3JlYXRlZC5zY3JpcHQpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgYWRkcmVzcyA9IGJpdGNvaW5qcy5hZGRyZXNzLmZyb21PdXRwdXRTY3JpcHQoXG4gICAgICAgIHV0eG9DcmVhdGVkLnNjcmlwdCwgdGhpcy5sYXllcjFcbiAgICAgIClcblxuICAgICAgbGV0IGluY2x1ZGVTZXQgPSBbXVxuICAgICAgaWYgKHRoaXMuaW5jbHVkZVV0eG9NYXAuaGFzT3duUHJvcGVydHkoYWRkcmVzcykpIHtcbiAgICAgICAgaW5jbHVkZVNldCA9IGluY2x1ZGVTZXQuY29uY2F0KHRoaXMuaW5jbHVkZVV0eG9NYXBbYWRkcmVzc10pXG4gICAgICB9XG5cbiAgICAgIGluY2x1ZGVTZXQucHVzaCh7XG4gICAgICAgIHR4X2hhc2g6IHR4SGFzaCxcbiAgICAgICAgY29uZmlybWF0aW9uczogMCxcbiAgICAgICAgdmFsdWU6IHV0eG9DcmVhdGVkLnZhbHVlLFxuICAgICAgICB0eF9vdXRwdXRfbjogdHhPdXRwdXROXG4gICAgICB9KVxuICAgICAgdGhpcy5pbmNsdWRlVXR4b01hcFthZGRyZXNzXSA9IGluY2x1ZGVTZXRcbiAgICB9KVxuICB9XG5cbiAgcmVzZXRVVFhPcyhhZGRyZXNzOiBzdHJpbmcpIHtcbiAgICBkZWxldGUgdGhpcy5pbmNsdWRlVXR4b01hcFthZGRyZXNzXVxuICAgIHRoaXMuZXhjbHVkZVV0eG9TZXQgPSBbXVxuICB9XG5cbiAgZ2V0Q29uc2Vuc3VzSGFzaCgpIHtcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5ibG9ja3N0YWNrQVBJVXJsfS92MS9ibG9ja2NoYWlucy9iaXRjb2luL2NvbnNlbnN1c2ApXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AuanNvbigpKVxuICAgICAgLnRoZW4oeCA9PiB4LmNvbnNlbnN1c19oYXNoKVxuICB9XG5cbiAgZ2V0VHJhbnNhY3Rpb25JbmZvKHR4SGFzaDogc3RyaW5nKSA6IFByb21pc2U8e2Jsb2NrX2hlaWdodDogTnVtYmVyfT4ge1xuICAgIHJldHVybiB0aGlzLmJ0Yy5nZXRUcmFuc2FjdGlvbkluZm8odHhIYXNoKVxuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnRjLmdldEJsb2NrSGVpZ2h0KClcbiAgfVxuXG4gIGdldE5ldHdvcmtlZFVUWE9zKGFkZHJlc3M6IHN0cmluZykgOiBQcm9taXNlPEFycmF5PFVUWE8+PiB7XG4gICAgcmV0dXJuIHRoaXMuYnRjLmdldE5ldHdvcmtlZFVUWE9zKGFkZHJlc3MpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIExvY2FsUmVndGVzdCBleHRlbmRzIEJsb2Nrc3RhY2tOZXR3b3JrIHtcbiAgY29uc3RydWN0b3IoYXBpVXJsOiBzdHJpbmcsIGJyb2FkY2FzdFNlcnZpY2VVcmw6IHN0cmluZyxcbiAgICAgICAgICAgICAgYml0Y29pbkFQSTogQml0Y29pbk5ldHdvcmspIHtcbiAgICBzdXBlcihhcGlVcmwsIGJyb2FkY2FzdFNlcnZpY2VVcmwsIGJpdGNvaW5BUEksIGJpdGNvaW5qcy5uZXR3b3Jrcy50ZXN0bmV0KVxuICB9XG5cbiAgZ2V0RmVlUmF0ZSgpIDogUHJvbWlzZTxudW1iZXI+IHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKE1hdGguZmxvb3IoMC4wMDAwMTAwMCAqIFNBVE9TSElTX1BFUl9CVEMpKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCaXRjb2luZEFQSSBleHRlbmRzIEJpdGNvaW5OZXR3b3JrIHtcbiAgYml0Y29pbmRVcmw6IHN0cmluZ1xuXG4gIGJpdGNvaW5kQ3JlZGVudGlhbHM6IE9iamVjdFxuXG4gIGltcG9ydGVkQmVmb3JlOiBPYmplY3RcblxuICBjb25zdHJ1Y3RvcihiaXRjb2luZFVybDogc3RyaW5nLCBiaXRjb2luZENyZWRlbnRpYWxzOiB7dXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZ30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5iaXRjb2luZFVybCA9IGJpdGNvaW5kVXJsXG4gICAgdGhpcy5iaXRjb2luZENyZWRlbnRpYWxzID0gYml0Y29pbmRDcmVkZW50aWFsc1xuICAgIHRoaXMuaW1wb3J0ZWRCZWZvcmUgPSB7fVxuICB9XG5cbiAgYnJvYWRjYXN0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb246IHN0cmluZykge1xuICAgIGNvbnN0IGpzb25SUEMgPSB7XG4gICAgICBqc29ucnBjOiAnMS4wJyxcbiAgICAgIG1ldGhvZDogJ3NlbmRyYXd0cmFuc2FjdGlvbicsXG4gICAgICBwYXJhbXM6IFt0cmFuc2FjdGlvbl1cbiAgICB9XG4gICAgY29uc3QgYXV0aFN0cmluZyA9ICAgICAgQnVmZmVyLmZyb20oYCR7dGhpcy5iaXRjb2luZENyZWRlbnRpYWxzLnVzZXJuYW1lfToke3RoaXMuYml0Y29pbmRDcmVkZW50aWFscy5wYXNzd29yZH1gKVxuICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCYXNpYyAke2F1dGhTdHJpbmd9YCB9XG4gICAgcmV0dXJuIGZldGNoKHRoaXMuYml0Y29pbmRVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvblJQQyksXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbihyZXNwT2JqID0+IHJlc3BPYmoucmVzdWx0KVxuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoKSB7XG4gICAgY29uc3QganNvblJQQyA9IHtcbiAgICAgIGpzb25ycGM6ICcxLjAnLFxuICAgICAgbWV0aG9kOiAnZ2V0YmxvY2tjb3VudCdcbiAgICB9XG4gICAgY29uc3QgYXV0aFN0cmluZyA9ICAgICAgQnVmZmVyLmZyb20oYCR7dGhpcy5iaXRjb2luZENyZWRlbnRpYWxzLnVzZXJuYW1lfToke3RoaXMuYml0Y29pbmRDcmVkZW50aWFscy5wYXNzd29yZH1gKVxuICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCYXNpYyAke2F1dGhTdHJpbmd9YCB9XG4gICAgcmV0dXJuIGZldGNoKHRoaXMuYml0Y29pbmRVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvblJQQyksXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbihyZXNwT2JqID0+IHJlc3BPYmoucmVzdWx0KVxuICB9XG5cbiAgZ2V0VHJhbnNhY3Rpb25JbmZvKHR4SGFzaDogc3RyaW5nKSA6IFByb21pc2U8e2Jsb2NrX2hlaWdodDogTnVtYmVyfT4ge1xuICAgIGNvbnN0IGpzb25SUEMgPSB7XG4gICAgICBqc29ucnBjOiAnMS4wJyxcbiAgICAgIG1ldGhvZDogJ2dldHRyYW5zYWN0aW9uJyxcbiAgICAgIHBhcmFtczogW3R4SGFzaF1cbiAgICB9XG4gICAgY29uc3QgYXV0aFN0cmluZyA9ICAgICAgQnVmZmVyLmZyb20oYCR7dGhpcy5iaXRjb2luZENyZWRlbnRpYWxzLnVzZXJuYW1lfToke3RoaXMuYml0Y29pbmRDcmVkZW50aWFscy5wYXNzd29yZH1gKVxuICAgICAgLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgIGNvbnN0IGhlYWRlcnMgPSB7IEF1dGhvcml6YXRpb246IGBCYXNpYyAke2F1dGhTdHJpbmd9YCB9XG4gICAgcmV0dXJuIGZldGNoKHRoaXMuYml0Y29pbmRVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvblJQQyksXG4gICAgICBoZWFkZXJzXG4gICAgfSlcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbihyZXNwT2JqID0+IHJlc3BPYmoucmVzdWx0KVxuICAgICAgLnRoZW4odHhJbmZvID0+IHR4SW5mby5ibG9ja2hhc2gpXG4gICAgICAudGhlbigoYmxvY2toYXNoKSA9PiB7XG4gICAgICAgIGNvbnN0IGpzb25SUENCbG9jayA9IHtcbiAgICAgICAgICBqc29ucnBjOiAnMS4wJyxcbiAgICAgICAgICBtZXRob2Q6ICdnZXRibG9ja2hlYWRlcicsXG4gICAgICAgICAgcGFyYW1zOiBbYmxvY2toYXNoXVxuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCYXNpYyAke2F1dGhTdHJpbmd9YFxuICAgICAgICByZXR1cm4gZmV0Y2godGhpcy5iaXRjb2luZFVybCwge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25SUENCbG9jayksXG4gICAgICAgICAgaGVhZGVyc1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbigocmVzcE9iaikgPT4ge1xuICAgICAgICBpZiAoIXJlc3BPYmogfHwgIXJlc3BPYmoucmVzdWx0KSB7XG4gICAgICAgICAgLy8gdW5jb25maXJtZWQgXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNvbmZpcm1lZCB0cmFuc2FjdGlvbicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHsgYmxvY2tfaGVpZ2h0OiByZXNwT2JqLnJlc3VsdC5oZWlnaHQgfVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgZ2V0TmV0d29ya2VkVVRYT3MoYWRkcmVzczogc3RyaW5nKSA6IFByb21pc2U8QXJyYXk8VVRYTz4+IHtcbiAgICBjb25zdCBqc29uUlBDSW1wb3J0ID0ge1xuICAgICAganNvbnJwYzogJzEuMCcsXG4gICAgICBtZXRob2Q6ICdpbXBvcnRhZGRyZXNzJyxcbiAgICAgIHBhcmFtczogW2FkZHJlc3NdXG4gICAgfVxuICAgIGNvbnN0IGpzb25SUENVbnNwZW50ID0ge1xuICAgICAganNvbnJwYzogJzEuMCcsXG4gICAgICBtZXRob2Q6ICdsaXN0dW5zcGVudCcsXG4gICAgICBwYXJhbXM6IFswLCA5OTk5OTk5LCBbYWRkcmVzc11dXG4gICAgfVxuICAgIGNvbnN0IGF1dGhTdHJpbmcgPSBCdWZmZXIuZnJvbShgJHt0aGlzLmJpdGNvaW5kQ3JlZGVudGlhbHMudXNlcm5hbWV9OiR7dGhpcy5iaXRjb2luZENyZWRlbnRpYWxzLnBhc3N3b3JkfWApXG4gICAgICAudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgY29uc3QgaGVhZGVycyA9IHsgQXV0aG9yaXphdGlvbjogYEJhc2ljICR7YXV0aFN0cmluZ31gIH1cblxuICAgIGNvbnN0IGltcG9ydFByb21pc2UgPSAodGhpcy5pbXBvcnRlZEJlZm9yZVthZGRyZXNzXSlcbiAgICAgID8gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgIDogZmV0Y2godGhpcy5iaXRjb2luZFVybCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoanNvblJQQ0ltcG9ydCksXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pXG4gICAgICAgIC50aGVuKCgpID0+IHsgdGhpcy5pbXBvcnRlZEJlZm9yZVthZGRyZXNzXSA9IHRydWUgfSlcblxuICAgIHJldHVybiBpbXBvcnRQcm9taXNlXG4gICAgICAudGhlbigoKSA9PiBmZXRjaCh0aGlzLmJpdGNvaW5kVXJsLCB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShqc29uUlBDVW5zcGVudCksXG4gICAgICAgIGhlYWRlcnNcbiAgICAgIH0pKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHggPT4geC5yZXN1bHQpXG4gICAgICAudGhlbih1dHhvcyA9PiB1dHhvcy5tYXAoXG4gICAgICAgIHggPT4gT2JqZWN0KHtcbiAgICAgICAgICB2YWx1ZTogTWF0aC5yb3VuZCh4LmFtb3VudCAqIFNBVE9TSElTX1BFUl9CVEMpLFxuICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IHguY29uZmlybWF0aW9ucyxcbiAgICAgICAgICB0eF9oYXNoOiB4LnR4aWQsXG4gICAgICAgICAgdHhfb3V0cHV0X246IHgudm91dFxuICAgICAgICB9KVxuICAgICAgKSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgSW5zaWdodENsaWVudCBleHRlbmRzIEJpdGNvaW5OZXR3b3JrIHtcbiAgYXBpVXJsOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihpbnNpZ2h0VXJsOiBzdHJpbmcgPSAnaHR0cHM6Ly91dHhvLnRlY2hub2ZyYWN0YWwuY29tLycpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hcGlVcmwgPSBpbnNpZ2h0VXJsXG4gIH1cblxuICBicm9hZGNhc3RUcmFuc2FjdGlvbih0cmFuc2FjdGlvbjogc3RyaW5nKSB7XG4gICAgY29uc3QganNvbkRhdGEgPSB7IHJhd3R4OiB0cmFuc2FjdGlvbiB9XG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMuYXBpVXJsfS90eC9zZW5kYCxcbiAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LFxuICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGpzb25EYXRhKVxuICAgICAgICAgICAgICAgICB9KVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgfVxuXG4gIGdldEJsb2NrSGVpZ2h0KCkge1xuICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmFwaVVybH0vc3RhdHVzYClcbiAgICAgIC50aGVuKHJlc3AgPT4gcmVzcC5qc29uKCkpXG4gICAgICAudGhlbihzdGF0dXMgPT4gc3RhdHVzLmJsb2NrcylcbiAgfVxuXG4gIGdldFRyYW5zYWN0aW9uSW5mbyh0eEhhc2g6IHN0cmluZykgOiBQcm9taXNlPHtibG9ja19oZWlnaHQ6IE51bWJlcn0+IHtcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy5hcGlVcmx9L3R4LyR7dHhIYXNofWApXG4gICAgICAudGhlbihyZXNwID0+IHJlc3AuanNvbigpKVxuICAgICAgLnRoZW4oKHRyYW5zYWN0aW9uSW5mbykgPT4ge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb25JbmZvLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBmaW5kaW5nIHRyYW5zYWN0aW9uOiAke3RyYW5zYWN0aW9uSW5mby5lcnJvcn1gKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmFwaVVybH0vYmxvY2svJHt0cmFuc2FjdGlvbkluZm8uYmxvY2tIYXNofWApXG4gICAgICB9KVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKGJsb2NrSW5mbyA9PiAoeyBibG9ja19oZWlnaHQ6IGJsb2NrSW5mby5oZWlnaHQgfSkpXG4gIH1cblxuICBnZXROZXR3b3JrZWRVVFhPcyhhZGRyZXNzOiBzdHJpbmcpIDogUHJvbWlzZTxBcnJheTxVVFhPPj4ge1xuICAgIHJldHVybiBmZXRjaChgJHt0aGlzLmFwaVVybH0vYWRkci8ke2FkZHJlc3N9L3V0eG9gKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKHV0eG9zID0+IHV0eG9zLm1hcChcbiAgICAgICAgeCA9PiAoe1xuICAgICAgICAgIHZhbHVlOiB4LnNhdG9zaGlzLFxuICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IHguY29uZmlybWF0aW9ucyxcbiAgICAgICAgICB0eF9oYXNoOiB4LnR4aWQsXG4gICAgICAgICAgdHhfb3V0cHV0X246IHgudm91dFxuICAgICAgICB9KVxuICAgICAgKSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQmxvY2tjaGFpbkluZm9BcGkgZXh0ZW5kcyBCaXRjb2luTmV0d29yayB7XG4gIHV0eG9Qcm92aWRlclVybDogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IoYmxvY2tjaGFpbkluZm9Vcmw6IHN0cmluZyA9ICdodHRwczovL2Jsb2NrY2hhaW4uaW5mbycpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy51dHhvUHJvdmlkZXJVcmwgPSBibG9ja2NoYWluSW5mb1VybFxuICB9XG5cbiAgZ2V0QmxvY2tIZWlnaHQoKSB7XG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMudXR4b1Byb3ZpZGVyVXJsfS9sYXRlc3RibG9jaz9jb3JzPXRydWVgKVxuICAgICAgLnRoZW4ocmVzcCA9PiByZXNwLmpzb24oKSlcbiAgICAgIC50aGVuKGJsb2NrT2JqID0+IGJsb2NrT2JqLmhlaWdodClcbiAgfVxuXG4gIGdldE5ldHdvcmtlZFVUWE9zKGFkZHJlc3M6IHN0cmluZykgOiBQcm9taXNlPEFycmF5PFVUWE8+PiB7XG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMudXR4b1Byb3ZpZGVyVXJsfS91bnNwZW50P2Zvcm1hdD1qc29uJmFjdGl2ZT0ke2FkZHJlc3N9JmNvcnM9dHJ1ZWApXG4gICAgICAudGhlbigocmVzcCkgPT4ge1xuICAgICAgICBpZiAocmVzcC5zdGF0dXMgPT09IDUwMCkge1xuICAgICAgICAgIExvZ2dlci5kZWJ1ZygnVVRYTyBwcm92aWRlciA1MDAgdXN1YWxseSBtZWFucyBubyBVVFhPczogcmV0dXJuaW5nIFtdJylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5zcGVudF9vdXRwdXRzOiBbXVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzcC5qc29uKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC50aGVuKHV0eG9KU09OID0+IHV0eG9KU09OLnVuc3BlbnRfb3V0cHV0cylcbiAgICAgIC50aGVuKHV0eG9MaXN0ID0+IHV0eG9MaXN0Lm1hcChcbiAgICAgICAgKHV0eG8pID0+IHtcbiAgICAgICAgICBjb25zdCB1dHhvT3V0ID0ge1xuICAgICAgICAgICAgdmFsdWU6IHV0eG8udmFsdWUsXG4gICAgICAgICAgICB0eF9vdXRwdXRfbjogdXR4by50eF9vdXRwdXRfbixcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IHV0eG8uY29uZmlybWF0aW9ucyxcbiAgICAgICAgICAgIHR4X2hhc2g6IHV0eG8udHhfaGFzaF9iaWdfZW5kaWFuXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB1dHhvT3V0XG4gICAgICAgIH1cbiAgICAgICkpXG4gIH1cblxuICBnZXRUcmFuc2FjdGlvbkluZm8odHhIYXNoOiBzdHJpbmcpIDogUHJvbWlzZTx7YmxvY2tfaGVpZ2h0OiBOdW1iZXJ9PiB7XG4gICAgcmV0dXJuIGZldGNoKGAke3RoaXMudXR4b1Byb3ZpZGVyVXJsfS9yYXd0eC8ke3R4SGFzaH0/Y29ycz10cnVlYClcbiAgICAgIC50aGVuKChyZXNwKSA9PiB7XG4gICAgICAgIGlmIChyZXNwLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3AuanNvbigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgbG9va3VwIHRyYW5zYWN0aW9uIGluZm8gZm9yICcke3R4SGFzaH0nLiBTZXJ2ZXIgZXJyb3IuYClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC50aGVuKHJlc3BPYmogPT4gKHsgYmxvY2tfaGVpZ2h0OiByZXNwT2JqLmJsb2NrX2hlaWdodCB9KSlcbiAgfVxuXG4gIGJyb2FkY2FzdFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uOiBzdHJpbmcpIHtcbiAgICBjb25zdCBmb3JtID0gbmV3IEZvcm1EYXRhKClcbiAgICBmb3JtLmFwcGVuZCgndHgnLCB0cmFuc2FjdGlvbilcbiAgICByZXR1cm4gZmV0Y2goYCR7dGhpcy51dHhvUHJvdmlkZXJVcmx9L3B1c2h0eD9jb3JzPXRydWVgLFxuICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgYm9keTogZm9ybVxuICAgICAgICAgICAgICAgICB9KVxuICAgICAgLnRoZW4oKHJlc3ApID0+IHtcbiAgICAgICAgY29uc3QgdGV4dCA9IHJlc3AudGV4dCgpXG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgICAgICAgLnRoZW4oKHJlc3BUZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzcFRleHQudG9Mb3dlckNhc2UoKS5pbmRleE9mKCd0cmFuc2FjdGlvbiBzdWJtaXR0ZWQnKSA+PSAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHR4SGFzaCA9IGJpdGNvaW5qcy5UcmFuc2FjdGlvbi5mcm9tSGV4KHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgIC5nZXRIYXNoKClcbiAgICAgICAgICAgICAgICAucmV2ZXJzZSgpXG4gICAgICAgICAgICAgICAgLnRvU3RyaW5nKCdoZXgnKSAvLyBiaWdfZW5kaWFuXG4gICAgICAgICAgICAgIHJldHVybiB0eEhhc2hcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBSZW1vdGVTZXJ2aWNlRXJyb3IocmVzcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgQnJvYWRjYXN0IHRyYW5zYWN0aW9uIGZhaWxlZCB3aXRoIG1lc3NhZ2U6ICR7cmVzcFRleHR9YClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgfSlcbiAgfVxufVxuXG5jb25zdCBMT0NBTF9SRUdURVNUID0gbmV3IExvY2FsUmVndGVzdChcbiAgJ2h0dHA6Ly9sb2NhbGhvc3Q6MTYyNjgnLFxuICAnaHR0cDovL2xvY2FsaG9zdDoxNjI2OScsXG4gIG5ldyBCaXRjb2luZEFQSSgnaHR0cDovL2xvY2FsaG9zdDoxODMzMi8nLFxuICAgICAgICAgICAgICAgICAgeyB1c2VybmFtZTogJ2Jsb2Nrc3RhY2snLCBwYXNzd29yZDogJ2Jsb2Nrc3RhY2tzeXN0ZW0nIH0pXG4pXG5cbmNvbnN0IE1BSU5ORVRfREVGQVVMVCA9IG5ldyBCbG9ja3N0YWNrTmV0d29yayhcbiAgJ2h0dHBzOi8vY29yZS5ibG9ja3N0YWNrLm9yZycsXG4gICdodHRwczovL2Jyb2FkY2FzdC5ibG9ja3N0YWNrLm9yZycsXG4gIG5ldyBCbG9ja2NoYWluSW5mb0FwaSgpXG4pXG5cbmV4cG9ydCBjb25zdCBuZXR3b3JrID0ge1xuICBCbG9ja3N0YWNrTmV0d29yayxcbiAgTG9jYWxSZWd0ZXN0LFxuICBCbG9ja2NoYWluSW5mb0FwaSxcbiAgQml0Y29pbmRBUEksXG4gIEluc2lnaHRDbGllbnQsXG4gIGRlZmF1bHRzOiB7IExPQ0FMX1JFR1RFU1QsIE1BSU5ORVRfREVGQVVMVCB9XG59XG4iXX0=