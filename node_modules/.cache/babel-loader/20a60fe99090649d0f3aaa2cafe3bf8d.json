{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nexports.__esModule = true;\nexports.BlockstackWallet = void 0;\n\nvar _crypto = _interopRequireWildcard(require(\"crypto\"));\n\nvar _bitcoinjsLib = _interopRequireWildcard(require(\"bitcoinjs-lib\"));\n\nvar _bip = _interopRequireDefault(require(\"bip39\"));\n\nvar _bip2 = _interopRequireDefault(require(\"bip32\"));\n\nvar _utils = require(\"./utils\");\n\nvar _wallet = require(\"./encryption/wallet\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nvar APPS_NODE_INDEX = 0;\nvar IDENTITY_KEYCHAIN = 888;\nvar BLOCKSTACK_ON_BITCOIN = 0;\nvar BITCOIN_BIP_44_PURPOSE = 44;\nvar BITCOIN_COIN_TYPE = 0;\nvar BITCOIN_ACCOUNT_INDEX = 0;\nvar EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nvar CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n\nfunction hashCode(string) {\n  var hash = 0;\n  if (string.length === 0) return hash;\n\n  for (var i = 0; i < string.length; i++) {\n    var character = string.charCodeAt(i);\n    hash = (hash << 5) - hash + character;\n    hash &= hash;\n  }\n\n  return hash & 0x7fffffff;\n}\n\nfunction getNodePrivateKey(node) {\n  return (0, _utils.ecPairToHexString)(_bitcoinjsLib.ECPair.fromPrivateKey(node.privateKey));\n}\n\nfunction getNodePublicKey(node) {\n  return node.publicKey.toString('hex');\n}\n/**\n * The BlockstackWallet class manages the hierarchical derivation\n *  paths for a standard blockstack client wallet. This includes paths\n *  for bitcoin payment address, blockstack identity addresses, blockstack\n *  application specific addresses.\n *  @private\n */\n\n\nvar BlockstackWallet =\n/*#__PURE__*/\nfunction () {\n  function BlockstackWallet(rootNode) {\n    _classCallCheck(this, BlockstackWallet);\n\n    this.rootNode = rootNode;\n  }\n\n  _createClass(BlockstackWallet, [{\n    key: \"toBase58\",\n    value: function toBase58() {\n      return this.rootNode.toBase58();\n    }\n    /**\n     * Initialize a blockstack wallet from a seed buffer\n     * @param {Buffer} seed - the input seed for initializing the root node\n     *  of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n\n  }, {\n    key: \"getIdentityPrivateKeychain\",\n    value: function getIdentityPrivateKeychain() {\n      return this.rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);\n    }\n  }, {\n    key: \"getBitcoinPrivateKeychain\",\n    value: function getBitcoinPrivateKeychain() {\n      return this.rootNode.deriveHardened(BITCOIN_BIP_44_PURPOSE).deriveHardened(BITCOIN_COIN_TYPE).deriveHardened(BITCOIN_ACCOUNT_INDEX);\n    }\n  }, {\n    key: \"getBitcoinNode\",\n    value: function getBitcoinNode(addressIndex) {\n      var chainType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EXTERNAL_ADDRESS;\n      return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n    }\n  }, {\n    key: \"getIdentityAddressNode\",\n    value: function getIdentityAddressNode(identityIndex) {\n      var identityPrivateKeychain = this.getIdentityPrivateKeychain();\n      return identityPrivateKeychain.deriveHardened(identityIndex);\n    }\n  }, {\n    key: \"getIdentitySalt\",\n\n    /**\n     * Get a salt for use with creating application specific addresses\n     * @return {String} the salt\n     */\n    value: function getIdentitySalt() {\n      var identityPrivateKeychain = this.getIdentityPrivateKeychain();\n      var publicKeyHex = getNodePublicKey(identityPrivateKeychain);\n      return _crypto.default.createHash('sha256').update(publicKeyHex).digest('hex');\n    }\n    /**\n     * Get a bitcoin receive address at a given index\n     * @param {number} addressIndex - the index of the address\n     * @return {String} address\n     */\n\n  }, {\n    key: \"getBitcoinAddress\",\n    value: function getBitcoinAddress(addressIndex) {\n      return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the private key hex-string for a given bitcoin receive address\n     * @param {number} addressIndex - the index of the address\n     * @return {String} the hex-string. this will be either 64\n     * characters long to denote an uncompressed bitcoin address, or 66\n     * characters long for a compressed bitcoin address.\n     */\n\n  }, {\n    key: \"getBitcoinPrivateKey\",\n    value: function getBitcoinPrivateKey(addressIndex) {\n      return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n    }\n    /**\n     * Get the root node for the bitcoin public keychain\n     * @return {String} base58-encoding of the public node\n     */\n\n  }, {\n    key: \"getBitcoinPublicKeychain\",\n    value: function getBitcoinPublicKeychain() {\n      return this.getBitcoinPrivateKeychain().neutered();\n    }\n    /**\n     * Get the root node for the identity public keychain\n     * @return {String} base58-encoding of the public node\n     */\n\n  }, {\n    key: \"getIdentityPublicKeychain\",\n    value: function getIdentityPublicKeychain() {\n      return this.getIdentityPrivateKeychain().neutered();\n    }\n  }, {\n    key: \"getIdentityKeyPair\",\n\n    /**\n     * Get the keypair information for a given identity index. This\n     * information is used to obtain the private key for an identity address\n     * and derive application specific keys for that address.\n     * @param {number} addressIndex - the identity index\n     * @param {boolean} alwaysUncompressed - if true, always return a\n     *   private-key hex string corresponding to the uncompressed address\n     * @return {Object} an IdentityKeyPair type object with keys:\n     *   .key {String} - the private key hex-string\n     *   .keyID {String} - the public key hex-string\n     *   .address {String} - the identity address\n     *   .appsNodeKey {String} - the base-58 encoding of the applications node\n     *   .salt {String} - the salt used for creating app-specific addresses\n     */\n    value: function getIdentityKeyPair(addressIndex) {\n      var alwaysUncompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var identityNode = this.getIdentityAddressNode(addressIndex);\n      var address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n      var identityKey = getNodePrivateKey(identityNode);\n\n      if (alwaysUncompressed && identityKey.length === 66) {\n        identityKey = identityKey.slice(0, 64);\n      }\n\n      var identityKeyID = getNodePublicKey(identityNode);\n      var appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n      var salt = this.getIdentitySalt();\n      var keyPair = {\n        key: identityKey,\n        keyID: identityKeyID,\n        address: address,\n        appsNodeKey: appsNodeKey,\n        salt: salt\n      };\n      return keyPair;\n    }\n  }], [{\n    key: \"fromSeedBuffer\",\n    value: function fromSeedBuffer(seed) {\n      return new BlockstackWallet(_bip2.default.fromSeed(seed));\n    }\n    /**\n     * Initialize a blockstack wallet from a base58 string\n     * @param {string} keychain - the Base58 string used to initialize\n     *  the root node of the hierarchical wallet\n     * @return {BlockstackWallet} the constructed wallet\n     */\n\n  }, {\n    key: \"fromBase58\",\n    value: function fromBase58(keychain) {\n      return new BlockstackWallet(_bip2.default.fromBase58(keychain));\n    }\n    /**\n     * Initialize a blockstack wallet from an encrypted phrase & password. Throws\n     * if the password is incorrect. Supports all formats of Blockstack phrases.\n     * @param {string} data - The encrypted phrase as a hex-encoded string\n     * @param {string} password - The plain password\n     * @return {Promise<BlockstackWallet>} the constructed wallet\n     */\n\n  }, {\n    key: \"fromEncryptedMnemonic\",\n    value: function fromEncryptedMnemonic(data, password) {\n      return (0, _wallet.decryptMnemonic)(data, password).then(function (mnemonic) {\n        var seed = _bip.default.mnemonicToSeed(mnemonic);\n\n        return new BlockstackWallet(_bip2.default.fromSeed(seed));\n      }).catch(function (err) {\n        if (err.message && err.message.startsWith('bad header;')) {\n          throw new Error('Incorrect password');\n        } else {\n          throw err;\n        }\n      });\n    }\n    /**\n     * Generate a BIP-39 12 word mnemonic\n     * @return {Promise<string>} space-separated 12 word phrase\n     */\n\n  }, {\n    key: \"generateMnemonic\",\n    value: function generateMnemonic() {\n      return _bip.default.generateMnemonic(128, _crypto.randomBytes);\n    }\n    /**\n     * Encrypt a mnemonic phrase with a password\n     * @param {string} mnemonic - Raw mnemonic phrase\n     * @param {string} password - Password to encrypt mnemonic with\n     * @return {Promise<string>} Hex-encoded encrypted mnemonic\n     */\n\n  }, {\n    key: \"encryptMnemonic\",\n    value: function () {\n      var _encryptMnemonic = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(mnemonic, password) {\n        var encryptedBuffer;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return (0, _wallet.encryptMnemonic)(mnemonic, password);\n\n              case 2:\n                encryptedBuffer = _context.sent;\n                return _context.abrupt(\"return\", encryptedBuffer.toString('hex'));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function encryptMnemonic(_x, _x2) {\n        return _encryptMnemonic.apply(this, arguments);\n      }\n\n      return encryptMnemonic;\n    }()\n  }, {\n    key: \"getAppsNode\",\n    value: function getAppsNode(identityNode) {\n      return identityNode.deriveHardened(APPS_NODE_INDEX);\n    }\n  }, {\n    key: \"getNodeFromBitcoinKeychain\",\n    value: function getNodeFromBitcoinKeychain(keychainBase58, addressIndex) {\n      var chainType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EXTERNAL_ADDRESS;\n      var chain;\n\n      if (chainType === EXTERNAL_ADDRESS) {\n        chain = 0;\n      } else if (chainType === CHANGE_ADDRESS) {\n        chain = 1;\n      } else {\n        throw new Error('Invalid chain type');\n      }\n\n      var keychain = _bip2.default.fromBase58(keychainBase58);\n\n      return keychain.derive(chain).derive(addressIndex);\n    }\n    /**\n     * Get a bitcoin address given a base-58 encoded bitcoin node\n     * (usually called the account node)\n     * @param {String} keychainBase58 - base58-encoding of the node\n     * @param {number} addressIndex - index of the address to get\n     * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\n     * \"receive\" address) or 'CHANGE_ADDRESS'\n     * @return {String} the address\n     */\n\n  }, {\n    key: \"getAddressFromBitcoinKeychain\",\n    value: function getAddressFromBitcoinKeychain(keychainBase58, addressIndex) {\n      var chainType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EXTERNAL_ADDRESS;\n      return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet.getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n\n  }, {\n    key: \"getLegacyAppPrivateKey\",\n    value: function getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n      var hash = _crypto.default.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n\n      var appIndex = hashCode(hash);\n\n      var appNode = _bip2.default.fromBase58(appsNodeKey).deriveHardened(appIndex);\n\n      return getNodePrivateKey(appNode).slice(0, 64);\n    }\n  }, {\n    key: \"getAddressFromBIP32Node\",\n    value: function getAddressFromBIP32Node(node) {\n      return _bitcoinjsLib.default.payments.p2pkh({\n        pubkey: node.publicKey\n      }).address;\n    }\n    /**\n     * Get a ECDSA private key hex-string for an application-specific\n     *  address.\n     * @param {String} appsNodeKey - the base58-encoded private key for\n     * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n     * @param {String} salt - a string, used to salt the\n     * application-specific addresses\n     * @param {String} appDomain - the appDomain to generate a key for\n     * @return {String} the private key hex-string. this will be a 64\n     * character string\n     */\n\n  }, {\n    key: \"getAppPrivateKey\",\n    value: function getAppPrivateKey(appsNodeKey, salt, appDomain) {\n      var hash = _crypto.default.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n\n      var appIndexHexes = []; // note: there's hardcoded numbers here, precisely because I want this\n      //   code to be very specific to the derivation paths we expect.\n\n      if (hash.length !== 64) {\n        throw new Error(\"Unexpected app-domain hash length of \".concat(hash.length));\n      }\n\n      for (var i = 0; i < 11; i++) {\n        // split the hash into 3-byte chunks\n        // because child nodes can only be up to 2^31,\n        // and we shouldn't deal in partial bytes.\n        appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n      }\n\n      var appNode = _bip2.default.fromBase58(appsNodeKey);\n\n      appIndexHexes.forEach(function (hex) {\n        if (hex.length > 6) {\n          throw new Error('Invalid hex string length');\n        }\n\n        appNode = appNode.deriveHardened(parseInt(hex, 16));\n      });\n      return getNodePrivateKey(appNode).slice(0, 64);\n    }\n  }]);\n\n  return BlockstackWallet;\n}();\n\nexports.BlockstackWallet = BlockstackWallet;","map":null,"metadata":{},"sourceType":"script"}