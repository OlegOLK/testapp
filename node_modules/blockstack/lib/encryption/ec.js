"use strict";

exports.__esModule = true;
exports.getHexFromBN = getHexFromBN;
exports.encryptECIES = encryptECIES;
exports.decryptECIES = decryptECIES;
exports.signECDSA = signECDSA;
exports.verifyECDSA = verifyECDSA;

var _elliptic = require("elliptic");

var _crypto = _interopRequireDefault(require("crypto"));

var _keys = require("../keys");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ecurve = new _elliptic.ec('secp256k1');

function aes256CbcEncrypt(iv, key, plaintext) {
  const cipher = _crypto.default.createCipheriv('aes-256-cbc', key, iv);

  return Buffer.concat([cipher.update(plaintext), cipher.final()]);
}

function aes256CbcDecrypt(iv, key, ciphertext) {
  const cipher = _crypto.default.createDecipheriv('aes-256-cbc', key, iv);

  return Buffer.concat([cipher.update(ciphertext), cipher.final()]);
}

function hmacSha256(key, content) {
  return _crypto.default.createHmac('sha256', key).update(content).digest();
}

function equalConstTime(b1, b2) {
  if (b1.length !== b2.length) {
    return false;
  }

  let res = 0;

  for (let i = 0; i < b1.length; i++) {
    res |= b1[i] ^ b2[i]; // jshint ignore:line
  }

  return res === 0;
}

function sharedSecretToKeys(sharedSecret) {
  // generate mac and encryption key from shared secret
  const hashedSecret = _crypto.default.createHash('sha512').update(sharedSecret).digest();

  return {
    encryptionKey: hashedSecret.slice(0, 32),
    hmacKey: hashedSecret.slice(32)
  };
}

function getHexFromBN(bnInput) {
  const hexOut = bnInput.toString('hex');

  if (hexOut.length === 64) {
    return hexOut;
  } else if (hexOut.length < 64) {
    // pad with leading zeros
    // the padStart function would require node 9
    const padding = '0'.repeat(64 - hexOut.length);
    return `${padding}${hexOut}`;
  } else {
    throw new Error('Generated a > 32-byte BN for encryption. Failing.');
  }
}
/**
 * Encrypt content to elliptic curve publicKey using ECIES
 * @param {String} publicKey - secp256k1 public key hex string
 * @param {String | Buffer} content - content to encrypt
 * @return {Object} Object containing (hex encoded):
 *  iv (initialization vector), cipherText (cipher text),
 *  mac (message authentication code), ephemeral public key
 *  wasString (boolean indicating with or not to return a buffer or string on decrypt)
 *  @private
 */


function encryptECIES(publicKey, content) {
  const isString = typeof content === 'string';
  const plainText = Buffer.from(content); // always copy to buffer

  const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();
  const ephemeralSK = ecurve.genKeyPair();
  const ephemeralPK = ephemeralSK.getPublic();
  const sharedSecret = ephemeralSK.derive(ecPK);
  const sharedSecretHex = getHexFromBN(sharedSecret);
  const sharedKeys = sharedSecretToKeys(new Buffer(sharedSecretHex, 'hex'));

  const initializationVector = _crypto.default.randomBytes(16);

  const cipherText = aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, plainText);
  const macData = Buffer.concat([initializationVector, new Buffer(ephemeralPK.encodeCompressed()), cipherText]);
  const mac = hmacSha256(sharedKeys.hmacKey, macData);
  return {
    iv: initializationVector.toString('hex'),
    ephemeralPK: ephemeralPK.encodeCompressed('hex'),
    cipherText: cipherText.toString('hex'),
    mac: mac.toString('hex'),
    wasString: isString
  };
}
/**
 * Decrypt content encrypted using ECIES
 * @param {String} privateKey - secp256k1 private key hex string
 * @param {Object} cipherObject - object to decrypt, should contain:
 *  iv (initialization vector), cipherText (cipher text),
 *  mac (message authentication code), ephemeralPublicKey
 *  wasString (boolean indicating with or not to return a buffer or string on decrypt)
 * @return {Buffer} plaintext
 * @throws {Error} if unable to decrypt
 * @private
 */


function decryptECIES(privateKey, cipherObject) {
  const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');
  const ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();
  const sharedSecret = ecSK.derive(ephemeralPK);
  const sharedSecretBuffer = new Buffer(getHexFromBN(sharedSecret), 'hex');
  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);
  const ivBuffer = new Buffer(cipherObject.iv, 'hex');
  const cipherTextBuffer = new Buffer(cipherObject.cipherText, 'hex');
  const macData = Buffer.concat([ivBuffer, new Buffer(ephemeralPK.encodeCompressed()), cipherTextBuffer]);
  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);
  const expectedMac = new Buffer(cipherObject.mac, 'hex');

  if (!equalConstTime(expectedMac, actualMac)) {
    throw new Error('Decryption failed: failure in MAC check');
  }

  const plainText = aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);

  if (cipherObject.wasString) {
    return plainText.toString();
  } else {
    return plainText;
  }
}
/**
 * Sign content using ECDSA
 * @private
 * @param {String} privateKey - secp256k1 private key hex string
 * @param {Object} content - content to sign
 * @return {Object} contains:
 * signature - Hex encoded DER signature
 * public key - Hex encoded private string taken from privateKey
 * @private
 */


function signECDSA(privateKey, content) {
  const contentBuffer = Buffer.from(content);
  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');
  const publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);

  const contentHash = _crypto.default.createHash('sha256').update(contentBuffer).digest();

  const signature = ecPrivate.sign(contentHash);
  const signatureString = signature.toDER('hex');
  return {
    signature: signatureString,
    publicKey
  };
}
/**
 * Verify content using ECDSA
 * @param {String | Buffer} content - Content to verify was signed
 * @param {String} publicKey - secp256k1 private key hex string
 * @param {String} signature - Hex encoded DER signature
 * @return {Boolean} returns true when signature matches publickey + content, false if not
 * @private
 */


function verifyECDSA(content, publicKey, signature) {
  const contentBuffer = Buffer.from(content);
  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');

  const contentHash = _crypto.default.createHash('sha256').update(contentBuffer).digest();

  return ecPublic.verify(contentHash, signature);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lbmNyeXB0aW9uL2VjLmpzIl0sIm5hbWVzIjpbImVjdXJ2ZSIsIkVsbGlwdGljQ3VydmUiLCJhZXMyNTZDYmNFbmNyeXB0IiwiaXYiLCJrZXkiLCJwbGFpbnRleHQiLCJjaXBoZXIiLCJjcnlwdG8iLCJjcmVhdGVDaXBoZXJpdiIsIkJ1ZmZlciIsImNvbmNhdCIsInVwZGF0ZSIsImZpbmFsIiwiYWVzMjU2Q2JjRGVjcnlwdCIsImNpcGhlcnRleHQiLCJjcmVhdGVEZWNpcGhlcml2IiwiaG1hY1NoYTI1NiIsImNvbnRlbnQiLCJjcmVhdGVIbWFjIiwiZGlnZXN0IiwiZXF1YWxDb25zdFRpbWUiLCJiMSIsImIyIiwibGVuZ3RoIiwicmVzIiwiaSIsInNoYXJlZFNlY3JldFRvS2V5cyIsInNoYXJlZFNlY3JldCIsImhhc2hlZFNlY3JldCIsImNyZWF0ZUhhc2giLCJlbmNyeXB0aW9uS2V5Iiwic2xpY2UiLCJobWFjS2V5IiwiZ2V0SGV4RnJvbUJOIiwiYm5JbnB1dCIsImhleE91dCIsInRvU3RyaW5nIiwicGFkZGluZyIsInJlcGVhdCIsIkVycm9yIiwiZW5jcnlwdEVDSUVTIiwicHVibGljS2V5IiwiaXNTdHJpbmciLCJwbGFpblRleHQiLCJmcm9tIiwiZWNQSyIsImtleUZyb21QdWJsaWMiLCJnZXRQdWJsaWMiLCJlcGhlbWVyYWxTSyIsImdlbktleVBhaXIiLCJlcGhlbWVyYWxQSyIsImRlcml2ZSIsInNoYXJlZFNlY3JldEhleCIsInNoYXJlZEtleXMiLCJpbml0aWFsaXphdGlvblZlY3RvciIsInJhbmRvbUJ5dGVzIiwiY2lwaGVyVGV4dCIsIm1hY0RhdGEiLCJlbmNvZGVDb21wcmVzc2VkIiwibWFjIiwid2FzU3RyaW5nIiwiZGVjcnlwdEVDSUVTIiwicHJpdmF0ZUtleSIsImNpcGhlck9iamVjdCIsImVjU0siLCJrZXlGcm9tUHJpdmF0ZSIsInNoYXJlZFNlY3JldEJ1ZmZlciIsIml2QnVmZmVyIiwiY2lwaGVyVGV4dEJ1ZmZlciIsImFjdHVhbE1hYyIsImV4cGVjdGVkTWFjIiwic2lnbkVDRFNBIiwiY29udGVudEJ1ZmZlciIsImVjUHJpdmF0ZSIsImNvbnRlbnRIYXNoIiwic2lnbmF0dXJlIiwic2lnbiIsInNpZ25hdHVyZVN0cmluZyIsInRvREVSIiwidmVyaWZ5RUNEU0EiLCJlY1B1YmxpYyIsInZlcmlmeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQSxNQUFNQSxNQUFNLEdBQUcsSUFBSUMsWUFBSixDQUFrQixXQUFsQixDQUFmOztBQVVBLFNBQVNDLGdCQUFULENBQTBCQyxFQUExQixFQUFzQ0MsR0FBdEMsRUFBbURDLFNBQW5ELEVBQXNFO0FBQ3BFLFFBQU1DLE1BQU0sR0FBR0MsZ0JBQU9DLGNBQVAsQ0FBc0IsYUFBdEIsRUFBcUNKLEdBQXJDLEVBQTBDRCxFQUExQyxDQUFmOztBQUNBLFNBQU9NLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLENBQUNKLE1BQU0sQ0FBQ0ssTUFBUCxDQUFjTixTQUFkLENBQUQsRUFBMkJDLE1BQU0sQ0FBQ00sS0FBUCxFQUEzQixDQUFkLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxnQkFBVCxDQUEwQlYsRUFBMUIsRUFBc0NDLEdBQXRDLEVBQW1EVSxVQUFuRCxFQUF1RTtBQUNyRSxRQUFNUixNQUFNLEdBQUdDLGdCQUFPUSxnQkFBUCxDQUF3QixhQUF4QixFQUF1Q1gsR0FBdkMsRUFBNENELEVBQTVDLENBQWY7O0FBQ0EsU0FBT00sTUFBTSxDQUFDQyxNQUFQLENBQWMsQ0FBQ0osTUFBTSxDQUFDSyxNQUFQLENBQWNHLFVBQWQsQ0FBRCxFQUE0QlIsTUFBTSxDQUFDTSxLQUFQLEVBQTVCLENBQWQsQ0FBUDtBQUNEOztBQUVELFNBQVNJLFVBQVQsQ0FBb0JaLEdBQXBCLEVBQWlDYSxPQUFqQyxFQUFrRDtBQUNoRCxTQUFPVixnQkFBT1csVUFBUCxDQUFrQixRQUFsQixFQUE0QmQsR0FBNUIsRUFBaUNPLE1BQWpDLENBQXdDTSxPQUF4QyxFQUFpREUsTUFBakQs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d0JxQixVQUF4QixDQUFsQjs7QUFDQSxRQUFNWSxXQUFXLEdBQUduRSxnQkFBT3NCLFVBQVAsQ0FBa0IsUUFBbEIsRUFBNEJsQixNQUE1QixDQUFtQzZELGFBQW5DLEVBQWtEckQsTUFBbEQsRUFBcEI7O0FBQ0EsUUFBTXdELFNBQVMsR0FBR0YsU0FBUyxDQUFDRyxJQUFWLENBQWVGLFdBQWYsQ0FBbEI7QUFDQSxRQUFNRyxlQUFlLEdBQUdGLFNBQVMsQ0FBQ0csS0FBVixDQUFnQixLQUFoQixDQUF4QjtBQUVBLFNBQU87QUFDTEgsSUFBQUEsU0FBUyxFQUFFRSxlQUROO0FBRUxwQyxJQUFBQTtBQUZLLEdBQVA7QUFJRDtBQUVEOzs7Ozs7Ozs7O0FBUU8sU0FBU3NDLFdBQVQsQ0FBcUI5RCxPQUFyQixFQUNxQndCLFNBRHJCLEVBRXFCa0MsU0FGckIsRUFFd0M7QUFDN0MsUUFBTUgsYUFBYSxHQUFHL0QsTUFBTSxDQUFDbUMsSUFBUCxDQUFZM0IsT0FBWixDQUF0QjtBQUNBLFFBQU0rRCxRQUFRLEdBQUdoRixNQUFNLENBQUM4QyxhQUFQLENBQXFCTCxTQUFyQixFQUFnQyxLQUFoQyxDQUFqQjs7QUFDQSxRQUFNaUMsV0FBVyxHQUFHbkUsZ0JBQU9zQixVQUFQLENBQWtCLFFBQWxCLEVBQTRCbEIsTUFBNUIsQ0FBbUM2RCxhQUFuQyxFQUFrRHJELE1BQWxELEVBQXBCOztBQUVBLFNBQU82RCxRQUFRLENBQUNDLE1BQVQsQ0FBZ0JQLFdBQWhCLEVBQTZCQyxTQUE3QixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuaW1wb3J0IHsgZWMgYXMgRWxsaXB0aWNDdXJ2ZSB9IGZyb20gJ2VsbGlwdGljJ1xuaW1wb3J0IGNyeXB0byBmcm9tICdjcnlwdG8nXG5pbXBvcnQgeyBnZXRQdWJsaWNLZXlGcm9tUHJpdmF0ZSB9IGZyb20gJy4uL2tleXMnXG5cbmNvbnN0IGVjdXJ2ZSA9IG5ldyBFbGxpcHRpY0N1cnZlKCdzZWNwMjU2azEnKVxuXG5leHBvcnQgdHlwZSBDaXBoZXJPYmplY3QgPSB7XG4gIGl2OiBzdHJpbmcsXG4gIGVwaGVtZXJhbFBLOiBzdHJpbmcsXG4gIGNpcGhlclRleHQ6IHN0cmluZyxcbiAgbWFjOiBzdHJpbmcsXG4gIHdhc1N0cmluZzogYm9vbGVhblxufVxuXG5mdW5jdGlvbiBhZXMyNTZDYmNFbmNyeXB0KGl2OiBCdWZmZXIsIGtleTogQnVmZmVyLCBwbGFpbnRleHQ6IEJ1ZmZlcikge1xuICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoJ2Flcy0yNTYtY2JjJywga2V5LCBpdilcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUocGxhaW50ZXh0KSwgY2lwaGVyLmZpbmFsKCldKVxufVxuXG5mdW5jdGlvbiBhZXMyNTZDYmNEZWNyeXB0KGl2OiBCdWZmZXIsIGtleTogQnVmZmVyLCBjaXBoZXJ0ZXh0OiBCdWZmZXIpIHtcbiAgY29uc3QgY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoJ2Flcy0yNTYtY2JjJywga2V5LCBpdilcbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2NpcGhlci51cGRhdGUoY2lwaGVydGV4dCksIGNpcGhlci5maW5hbCgpXSlcbn1cblxuZnVuY3Rpb24gaG1hY1NoYTI1NihrZXk6IEJ1ZmZlciwgY29udGVudDogQnVmZmVyKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2Jywga2V5KS51cGRhdGUoY29udGVudCkuZGlnZXN0KClcbn1cblxuZnVuY3Rpb24gZXF1YWxDb25zdFRpbWUoYjE6IEJ1ZmZlciwgYjI6IEJ1ZmZlcikge1xuICBpZiAoYjEubGVuZ3RoICE9PSBiMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICBsZXQgcmVzID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGIxLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzIHw9IGIxW2ldIF4gYjJbaV0gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICB9XG4gIHJldHVybiByZXMgPT09IDBcbn1cblxuZnVuY3Rpb24gc2hhcmVkU2VjcmV0VG9LZXlzKHNoYXJlZFNlY3JldDogQnVmZmVyKSB7XG4gIC8vIGdlbmVyYXRlIG1hYyBhbmQgZW5jcnlwdGlvbiBrZXkgZnJvbSBzaGFyZWQgc2VjcmV0XG4gIGNvbnN0IGhhc2hlZFNlY3JldCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGE1MTInKS51cGRhdGUoc2hhcmVkU2VjcmV0KS5kaWdlc3QoKVxuICByZXR1cm4ge1xuICAgIGVuY3J5cHRpb25LZXk6IGhhc2hlZFNlY3JldC5zbGljZSgwLCAzMiksXG4gICAgaG1hY0tleTogaGFzaGVkU2VjcmV0LnNsaWNlKDMyKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZXhGcm9tQk4oYm5JbnB1dDogT2JqZWN0KSB7XG4gIGNvbnN0IGhleE91dCA9IGJuSW5wdXQudG9TdHJpbmcoJ2hleCcpXG5cbiAgaWYgKGhleE91dC5sZW5ndGggPT09IDY0KSB7XG4gICAgcmV0dXJuIGhleE91dFxuICB9IGVsc2UgaWYgKGhleE91dC5sZW5ndGggPCA2NCkge1xuICAgIC8vIHBhZCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAvLyB0aGUgcGFkU3RhcnQgZnVuY3Rpb24gd291bGQgcmVxdWlyZSBub2RlIDlcbiAgICBjb25zdCBwYWRkaW5nID0gJzAnLnJlcGVhdCg2NCAtIGhleE91dC5sZW5ndGgpXG4gICAgcmV0dXJuIGAke3BhZGRpbmd9JHtoZXhPdXR9YFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignR2VuZXJhdGVkIGEgPiAzMi1ieXRlIEJOIGZvciBlbmNyeXB0aW9uLiBGYWlsaW5nLicpXG4gIH1cbn1cblxuLyoqXG4gKiBFbmNyeXB0IGNvbnRlbnQgdG8gZWxsaXB0aWMgY3VydmUgcHVibGljS2V5IHVzaW5nIEVDSUVTXG4gKiBAcGFyYW0ge1N0cmluZ30gcHVibGljS2V5IC0gc2VjcDI1NmsxIHB1YmxpYyBrZXkgaGV4IHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmcgfCBCdWZmZXJ9IGNvbnRlbnQgLSBjb250ZW50IHRvIGVuY3J5cHRcbiAqIEByZXR1cm4ge09iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgKGhleCBlbmNvZGVkKTpcbiAqICBpdiAoaW5pdGlhbGl6YXRpb24gdmVjdG9yKSwgY2lwaGVyVGV4dCAoY2lwaGVyIHRleHQpLFxuICogIG1hYyAobWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlKSwgZXBoZW1lcmFsIHB1YmxpYyBrZXlcbiAqICB3YXNTdHJpbmcgKGJvb2xlYW4gaW5kaWNhdGluZyB3aXRoIG9yIG5vdCB0byByZXR1cm4gYSBidWZmZXIgb3Igc3RyaW5nIG9uIGRlY3J5cHQpXG4gKiAgQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRFQ0lFUyhwdWJsaWNLZXk6IHN0cmluZywgY29udGVudDogc3RyaW5nIHwgQnVmZmVyKTogQ2lwaGVyT2JqZWN0IHtcbiAgY29uc3QgaXNTdHJpbmcgPSAodHlwZW9mIChjb250ZW50KSA9PT0gJ3N0cmluZycpXG4gIGNvbnN0IHBsYWluVGV4dCA9IEJ1ZmZlci5mcm9tKGNvbnRlbnQpIC8vIGFsd2F5cyBjb3B5IHRvIGJ1ZmZlclxuXG4gIGNvbnN0IGVjUEsgPSBlY3VydmUua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXksICdoZXgnKS5nZXRQdWJsaWMoKVxuICBjb25zdCBlcGhlbWVyYWxTSyA9IGVjdXJ2ZS5nZW5LZXlQYWlyKClcbiAgY29uc3QgZXBoZW1lcmFsUEsgPSBlcGhlbWVyYWxTSy5nZXRQdWJsaWMoKVxuICBjb25zdCBzaGFyZWRTZWNyZXQgPSBlcGhlbWVyYWxTSy5kZXJpdmUoZWNQSylcblxuICBjb25zdCBzaGFyZWRTZWNyZXRIZXggPSBnZXRIZXhGcm9tQk4oc2hhcmVkU2VjcmV0KVxuXG4gIGNvbnN0IHNoYXJlZEtleXMgPSBzaGFyZWRTZWNyZXRUb0tleXMoXG4gICAgbmV3IEJ1ZmZlcihzaGFyZWRTZWNyZXRIZXgsICdoZXgnKVxuICApXG5cbiAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTYpXG5cbiAgY29uc3QgY2lwaGVyVGV4dCA9IGFlczI1NkNiY0VuY3J5cHQoXG4gICAgaW5pdGlhbGl6YXRpb25WZWN0b3IsIHNoYXJlZEtleXMuZW5jcnlwdGlvbktleSwgcGxhaW5UZXh0XG4gIClcblxuICBjb25zdCBtYWNEYXRhID0gQnVmZmVyLmNvbmNhdChbaW5pdGlhbGl6YXRpb25WZWN0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQnVmZmVyKGVwaGVtZXJhbFBLLmVuY29kZUNvbXByZXNzZWQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJUZXh0XSlcbiAgY29uc3QgbWFjID0gaG1hY1NoYTI1NihzaGFyZWRLZXlzLmhtYWNLZXksIG1hY0RhdGEpXG5cbiAgcmV0dXJuIHtcbiAgICBpdjogaW5pdGlhbGl6YXRpb25WZWN0b3IudG9TdHJpbmcoJ2hleCcpLFxuICAgIGVwaGVtZXJhbFBLOiBlcGhlbWVyYWxQSy5lbmNvZGVDb21wcmVzc2VkKCdoZXgnKSxcbiAgICBjaXBoZXJUZXh0OiBjaXBoZXJUZXh0LnRvU3RyaW5nKCdoZXgnKSxcbiAgICBtYWM6IG1hYy50b1N0cmluZygnaGV4JyksXG4gICAgd2FzU3RyaW5nOiBpc1N0cmluZ1xuICB9XG59XG5cbi8qKlxuICogRGVjcnlwdCBjb250ZW50IGVuY3J5cHRlZCB1c2luZyBFQ0lFU1xuICogQHBhcmFtIHtTdHJpbmd9IHByaXZhdGVLZXkgLSBzZWNwMjU2azEgcHJpdmF0ZSBrZXkgaGV4IHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IGNpcGhlck9iamVjdCAtIG9iamVjdCB0byBkZWNyeXB0LCBzaG91bGQgY29udGFpbjpcbiAqICBpdiAoaW5pdGlhbGl6YXRpb24gdmVjdG9yKSwgY2lwaGVyVGV4dCAoY2lwaGVyIHRleHQpLFxuICogIG1hYyAobWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlKSwgZXBoZW1lcmFsUHVibGljS2V5XG4gKiAgd2FzU3RyaW5nIChib29sZWFuIGluZGljYXRpbmcgd2l0aCBvciBub3QgdG8gcmV0dXJuIGEgYnVmZmVyIG9yIHN0cmluZyBvbiBkZWNyeXB0KVxuICogQHJldHVybiB7QnVmZmVyfSBwbGFpbnRleHRcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB1bmFibGUgdG8gZGVjcnlwdFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHRFQ0lFUyhwcml2YXRlS2V5OiBzdHJpbmcsIGNpcGhlck9iamVjdDogQ2lwaGVyT2JqZWN0KTogQnVmZmVyIHwgc3RyaW5nIHtcbiAgY29uc3QgZWNTSyA9IGVjdXJ2ZS5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5LCAnaGV4JylcbiAgY29uc3QgZXBoZW1lcmFsUEsgPSBlY3VydmUua2V5RnJvbVB1YmxpYyhjaXBoZXJPYmplY3QuZXBoZW1lcmFsUEssICdoZXgnKS5nZXRQdWJsaWMoKVxuICBjb25zdCBzaGFyZWRTZWNyZXQgPSBlY1NLLmRlcml2ZShlcGhlbWVyYWxQSylcbiAgY29uc3Qgc2hhcmVkU2VjcmV0QnVmZmVyID0gbmV3IEJ1ZmZlcihnZXRIZXhGcm9tQk4oc2hhcmVkU2VjcmV0KSwgJ2hleCcpXG5cbiAgY29uc3Qgc2hhcmVkS2V5cyA9IHNoYXJlZFNlY3JldFRvS2V5cyhzaGFyZWRTZWNyZXRCdWZmZXIpXG5cbiAgY29uc3QgaXZCdWZmZXIgPSBuZXcgQnVmZmVyKGNpcGhlck9iamVjdC5pdiwgJ2hleCcpXG4gIGNvbnN0IGNpcGhlclRleHRCdWZmZXIgPSBuZXcgQnVmZmVyKGNpcGhlck9iamVjdC5jaXBoZXJUZXh0LCAnaGV4JylcblxuICBjb25zdCBtYWNEYXRhID0gQnVmZmVyLmNvbmNhdChbaXZCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgQnVmZmVyKGVwaGVtZXJhbFBLLmVuY29kZUNvbXByZXNzZWQoKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXBoZXJUZXh0QnVmZmVyXSlcbiAgY29uc3QgYWN0dWFsTWFjID0gaG1hY1NoYTI1NihzaGFyZWRLZXlzLmhtYWNLZXksIG1hY0RhdGEpXG4gIGNvbnN0IGV4cGVjdGVkTWFjID0gbmV3IEJ1ZmZlcihjaXBoZXJPYmplY3QubWFjLCAnaGV4JylcbiAgaWYgKCFlcXVhbENvbnN0VGltZShleHBlY3RlZE1hYywgYWN0dWFsTWFjKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRGVjcnlwdGlvbiBmYWlsZWQ6IGZhaWx1cmUgaW4gTUFDIGNoZWNrJylcbiAgfVxuICBjb25zdCBwbGFpblRleHQgPSBhZXMyNTZDYmNEZWNyeXB0KFxuICAgIGl2QnVmZmVyLCBzaGFyZWRLZXlzLmVuY3J5cHRpb25LZXksIGNpcGhlclRleHRCdWZmZXJcbiAgKVxuXG4gIGlmIChjaXBoZXJPYmplY3Qud2FzU3RyaW5nKSB7XG4gICAgcmV0dXJuIHBsYWluVGV4dC50b1N0cmluZygpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBsYWluVGV4dFxuICB9XG59XG5cbi8qKlxuICogU2lnbiBjb250ZW50IHVzaW5nIEVDRFNBXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHByaXZhdGVLZXkgLSBzZWNwMjU2azEgcHJpdmF0ZSBrZXkgaGV4IHN0cmluZ1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRlbnQgLSBjb250ZW50IHRvIHNpZ25cbiAqIEByZXR1cm4ge09iamVjdH0gY29udGFpbnM6XG4gKiBzaWduYXR1cmUgLSBIZXggZW5jb2RlZCBERVIgc2lnbmF0dXJlXG4gKiBwdWJsaWMga2V5IC0gSGV4IGVuY29kZWQgcHJpdmF0ZSBzdHJpbmcgdGFrZW4gZnJvbSBwcml2YXRlS2V5XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbkVDRFNBKHByaXZhdGVLZXk6IHN0cmluZywgY29udGVudDogc3RyaW5nIHwgQnVmZmVyKVxuICA6IHsgcHVibGljS2V5OiBzdHJpbmcsIHNpZ25hdHVyZTogc3RyaW5nIH0ge1xuICBjb25zdCBjb250ZW50QnVmZmVyID0gQnVmZmVyLmZyb20oY29udGVudClcbiAgY29uc3QgZWNQcml2YXRlID0gZWN1cnZlLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXksICdoZXgnKVxuICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KVxuICBjb25zdCBjb250ZW50SGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoY29udGVudEJ1ZmZlcikuZGlnZXN0KClcbiAgY29uc3Qgc2lnbmF0dXJlID0gZWNQcml2YXRlLnNpZ24oY29udGVudEhhc2gpXG4gIGNvbnN0IHNpZ25hdHVyZVN0cmluZyA9IHNpZ25hdHVyZS50b0RFUignaGV4JylcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlU3RyaW5nLFxuICAgIHB1YmxpY0tleVxuICB9XG59XG5cbi8qKlxuICogVmVyaWZ5IGNvbnRlbnQgdXNpbmcgRUNEU0FcbiAqIEBwYXJhbSB7U3RyaW5nIHwgQnVmZmVyfSBjb250ZW50IC0gQ29udGVudCB0byB2ZXJpZnkgd2FzIHNpZ25lZFxuICogQHBhcmFtIHtTdHJpbmd9IHB1YmxpY0tleSAtIHNlY3AyNTZrMSBwcml2YXRlIGtleSBoZXggc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnbmF0dXJlIC0gSGV4IGVuY29kZWQgREVSIHNpZ25hdHVyZVxuICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIHdoZW4gc2lnbmF0dXJlIG1hdGNoZXMgcHVibGlja2V5ICsgY29udGVudCwgZmFsc2UgaWYgbm90XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5RUNEU0EoY29udGVudDogc3RyaW5nIHwgQnVmZmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1YmxpY0tleTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvbnRlbnRCdWZmZXIgPSBCdWZmZXIuZnJvbShjb250ZW50KVxuICBjb25zdCBlY1B1YmxpYyA9IGVjdXJ2ZS5rZXlGcm9tUHVibGljKHB1YmxpY0tleSwgJ2hleCcpXG4gIGNvbnN0IGNvbnRlbnRIYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShjb250ZW50QnVmZmVyKS5kaWdlc3QoKVxuXG4gIHJldHVybiBlY1B1YmxpYy52ZXJpZnkoY29udGVudEhhc2gsIHNpZ25hdHVyZSlcbn1cbiJdfQ==