"use strict";

exports.__esModule = true;
exports.signProfileToken = signProfileToken;
exports.wrapProfileToken = wrapProfileToken;
exports.verifyProfileToken = verifyProfileToken;
exports.extractProfile = extractProfile;

var _bitcoinjsLib = require("bitcoinjs-lib");

var _jsontokens = require("jsontokens");

var _utils = require("../utils");

/**
  * Signs a profile token
  * @param {Object} profile - the JSON of the profile to be signed
  * @param {String} privateKey - the signing private key
  * @param {Object} subject - the entity that the information is about
  * @param {Object} issuer - the entity that is issuing the token
  * @param {String} signingAlgorithm - the signing algorithm to use
  * @param {Date} issuedAt - the time of issuance of the token
  * @param {Date} expiresAt - the time of expiration of the token
  * @returns {Object} - the signed profile token
  */
function signProfileToken(profile, privateKey, subject = null, issuer = null, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = (0, _utils.nextYear)()) {
  if (signingAlgorithm !== 'ES256K') {
    throw new Error('Signing algorithm not supported');
  }

  const publicKey = _jsontokens.SECP256K1Client.derivePublicKey(privateKey);

  if (subject === null) {
    subject = {
      publicKey
    };
  }

  if (issuer === null) {
    issuer = {
      publicKey
    };
  }

  const tokenSigner = new _jsontokens.TokenSigner(signingAlgorithm, privateKey);
  const payload = {
    jti: (0, _utils.makeUUID4)(),
    iat: issuedAt.toISOString(),
    exp: expiresAt.toISOString(),
    subject,
    issuer,
    claim: profile
  };
  return tokenSigner.sign(payload);
}
/**
  * Wraps a token for a profile token file
  * @param {String} token - the token to be wrapped
  * @returns {Object} - including `token` and `decodedToken`
  */


function wrapProfileToken(token) {
  return {
    token,
    decodedToken: (0, _jsontokens.decodeToken)(token)
  };
}
/**
  * Verifies a profile token
  * @param {String} token - the token to be verified
  * @param {String} publicKeyOrAddress - the public key or address of the
  *   keypair that is thought to have signed the token
  * @returns {Object} - the verified, decoded profile token
  * @throws {Error} - throws an error if token verification fails
  */


function verifyProfileToken(token, publicKeyOrAddress) {
  const decodedToken = (0, _jsontokens.decodeToken)(token);
  const payload = decodedToken.payload; // Inspect and verify the subject

  if (payload.hasOwnProperty('subject')) {
    if (!payload.subject.hasOwnProperty('publicKey')) {
      throw new Error('Token doesn\'t have a subject public key');
    }
  } else {
    throw new Error('Token doesn\'t have a subject');
  } // Inspect and verify the issuer


  if (payload.hasOwnProperty('issuer')) {
    if (!payload.issuer.hasOwnProperty('publicKey')) {
      throw new Error('Token doesn\'t have an issuer public key');
    }
  } else {
    throw new Error('Token doesn\'t have an issuer');
  } // Inspect and verify the claim


  if (!payload.hasOwnProperty('claim')) {
    throw new Error('Token doesn\'t have a claim');
  }

  const issuerPublicKey = payload.issuer.publicKey;
  const publicKeyBuffer = new Buffer(issuerPublicKey, 'hex');

  const compressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, {
    compressed: true
  });

  const compressedAddress = (0, _utils.ecPairToAddress)(compressedKeyPair);

  const uncompressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, {
    compressed: false
  });

  const uncompressedAddress = (0, _utils.ecPairToAddress)(uncompressedKeyPair);

  if (publicKeyOrAddress === issuerPublicKey) {// pass
  } else if (publicKeyOrAddress === compressedAddress) {// pass
  } else if (publicKeyOrAddress === uncompressedAddress) {// pass
  } else {
    throw new Error('Token issuer public key does not match the verifying value');
  }

  const tokenVerifier = new _jsontokens.TokenVerifier(decodedToken.header.alg, issuerPublicKey);

  if (!tokenVerifier) {
    throw new Error('Invalid token verifier');
  }

  const tokenVerified = tokenVerifier.verify(token);

  if (!tokenVerified) {
    throw new Error('Token verification failed');
  }

  return decodedToken;
}
/**
  * Extracts a profile from an encoded token and optionally verifies it,
  * if `publicKeyOrAddress` is provided.
  * @param {String} token - the token to be extracted
  * @param {String} publicKeyOrAddress - the public key or address of the
  *   keypair that is thought to have signed the token
  * @returns {Object} - the profile extracted from the encoded token
  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`
  */


function extractProfile(token, publicKeyOrAddress = null) {
  let decodedToken;

  if (publicKeyOrAddress) {
    decodedToken = verifyProfileToken(token, publicKeyOrAddress);
  } else {
    decodedToken = (0, _jsontokens.decodeToken)(token);
  }

  let profile = {};

  if (decodedToken.hasOwnProperty('payload')) {
    const payload = decodedToken.payload;

    if (payload.hasOwnProperty('claim')) {
      profile = decodedToken.payload.claim;
    }
  }

  return profile;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9maWxlcy9wcm9maWxlVG9rZW5zLmpzIl0sIm5hbWVzIjpbInNpZ25Qcm9maWxlVG9rZW4iLCJwcm9maWxlIiwicHJpdmF0ZUtleSIsInN1YmplY3QiLCJpc3N1ZXIiLCJzaWduaW5nQWxnb3JpdGhtIiwiaXNzdWVkQXQiLCJEYXRlIiwiZXhwaXJlc0F0IiwiRXJyb3IiLCJwdWJsaWNLZXkiLCJTRUNQMjU2SzFDbGllbnQiLCJkZXJpdmVQdWJsaWNLZXkiLCJ0b2tlblNpZ25lciIsIlRva2VuU2lnbmVyIiwicGF5bG9hZCIsImp0aSIsImlhdCIsInRvSVNPU3RyaW5nIiwiZXhwIiwiY2xhaW0iLCJzaWduIiwid3JhcFByb2ZpbGVUb2tlbiIsInRva2VuIiwiZGVjb2RlZFRva2VuIiwidmVyaWZ5UHJvZmlsZVRva2VuIiwicHVibGljS2V5T3JBZGRyZXNzIiwiaGFzT3duUHJvcGVydHkiLCJpc3N1ZXJQdWJsaWNLZXkiLCJwdWJsaWNLZXlCdWZmZXIiLCJCdWZmZXIiLCJjb21wcmVzc2VkS2V5UGFpciIsIkVDUGFpciIsImZyb21QdWJsaWNLZXkiLCJjb21wcmVzc2VkIiwiY29tcHJlc3NlZEFkZHJlc3MiLCJ1bmNvbXByZXNzZWRLZXlQYWlyIiwidW5jb21wcmVzc2VkQWRkcmVzcyIsInRva2VuVmVyaWZpZXIiLCJUb2tlblZlcmlmaWVyIiwiaGVhZGVyIiwiYWxnIiwidG9rZW5WZXJpZmllZCIsInZlcmlmeSIsImV4dHJhY3RQcm9maWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOztBQUNBOztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdPLFNBQVNBLGdCQUFULENBQTBCQyxPQUExQixFQUMwQkMsVUFEMUIsRUFFMEJDLE9BQU8sR0FBRyxJQUZwQyxFQUcwQkMsTUFBTSxHQUFHLElBSG5DLEVBSTBCQyxnQkFBZ0IsR0FBRyxRQUo3QyxFQUswQkMsUUFBUSxHQUFHLElBQUlDLElBQUosRUFMckMsRUFNMEJDLFNBQVMsR0FBRyxz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Q0FBNEIsU0FBNUIsQ0FBSixFQUE0QztBQUMxQyxVQUFNWixPQUFPLEdBQUdTLFlBQVksQ0FBQ1QsT0FBN0I7O0FBQ0EsUUFBSUEsT0FBTyxDQUFDWSxjQUFSLENBQXVCLE9BQXZCLENBQUosRUFBcUM7QUFDbkMxQixNQUFBQSxPQUFPLEdBQUd1QixZQUFZLENBQUNULE9BQWIsQ0FBcUJLLEtBQS9CO0FBQ0Q7QUFDRjs7QUFFRCxTQUFPbkIsT0FBUDtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRUNQYWlyIH0gZnJvbSAnYml0Y29pbmpzLWxpYidcbmltcG9ydCB7XG4gIGRlY29kZVRva2VuLCBTRUNQMjU2SzFDbGllbnQsIFRva2VuU2lnbmVyLCBUb2tlblZlcmlmaWVyXG59IGZyb20gJ2pzb250b2tlbnMnXG5cbmltcG9ydCB7IG5leHRZZWFyLCBtYWtlVVVJRDQsIGVjUGFpclRvQWRkcmVzcyB9IGZyb20gJy4uL3V0aWxzJ1xuXG4vKipcbiAgKiBTaWducyBhIHByb2ZpbGUgdG9rZW5cbiAgKiBAcGFyYW0ge09iamVjdH0gcHJvZmlsZSAtIHRoZSBKU09OIG9mIHRoZSBwcm9maWxlIHRvIGJlIHNpZ25lZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBwcml2YXRlS2V5IC0gdGhlIHNpZ25pbmcgcHJpdmF0ZSBrZXlcbiAgKiBAcGFyYW0ge09iamVjdH0gc3ViamVjdCAtIHRoZSBlbnRpdHkgdGhhdCB0aGUgaW5mb3JtYXRpb24gaXMgYWJvdXRcbiAgKiBAcGFyYW0ge09iamVjdH0gaXNzdWVyIC0gdGhlIGVudGl0eSB0aGF0IGlzIGlzc3VpbmcgdGhlIHRva2VuXG4gICogQHBhcmFtIHtTdHJpbmd9IHNpZ25pbmdBbGdvcml0aG0gLSB0aGUgc2lnbmluZyBhbGdvcml0aG0gdG8gdXNlXG4gICogQHBhcmFtIHtEYXRlfSBpc3N1ZWRBdCAtIHRoZSB0aW1lIG9mIGlzc3VhbmNlIG9mIHRoZSB0b2tlblxuICAqIEBwYXJhbSB7RGF0ZX0gZXhwaXJlc0F0IC0gdGhlIHRpbWUgb2YgZXhwaXJhdGlvbiBvZiB0aGUgdG9rZW5cbiAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIHRoZSBzaWduZWQgcHJvZmlsZSB0b2tlblxuICAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25Qcm9maWxlVG9rZW4ocHJvZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJqZWN0ID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlciA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduaW5nQWxnb3JpdGhtID0gJ0VTMjU2SycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZWRBdCA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzQXQgPSBuZXh0WWVhcigpKSB7XG4gIGlmIChzaWduaW5nQWxnb3JpdGhtICE9PSAnRVMyNTZLJykge1xuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmluZyBhbGdvcml0aG0gbm90IHN1cHBvcnRlZCcpXG4gIH1cblxuICBjb25zdCBwdWJsaWNLZXkgPSBTRUNQMjU2SzFDbGllbnQuZGVyaXZlUHVibGljS2V5KHByaXZhdGVLZXkpXG5cbiAgaWYgKHN1YmplY3QgPT09IG51bGwpIHtcbiAgICBzdWJqZWN0ID0geyBwdWJsaWNLZXkgfVxuICB9XG5cbiAgaWYgKGlzc3VlciA9PT0gbnVsbCkge1xuICAgIGlzc3VlciA9IHsgcHVibGljS2V5IH1cbiAgfVxuXG4gIGNvbnN0IHRva2VuU2lnbmVyID0gbmV3IFRva2VuU2lnbmVyKHNpZ25pbmdBbGdvcml0aG0sIHByaXZhdGVLZXkpXG5cbiAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICBqdGk6IG1ha2VVVUlENCgpLFxuICAgIGlhdDogaXNzdWVkQXQudG9JU09TdHJpbmcoKSxcbiAgICBleHA6IGV4cGlyZXNBdC50b0lTT1N0cmluZygpLFxuICAgIHN1YmplY3QsXG4gICAgaXNzdWVyLFxuICAgIGNsYWltOiBwcm9maWxlXG4gIH1cblxuICByZXR1cm4gdG9rZW5TaWduZXIuc2lnbihwYXlsb2FkKVxufVxuXG4vKipcbiAgKiBXcmFwcyBhIHRva2VuIGZvciBhIHByb2ZpbGUgdG9rZW4gZmlsZVxuICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAtIHRoZSB0b2tlbiB0byBiZSB3cmFwcGVkXG4gICogQHJldHVybnMge09iamVjdH0gLSBpbmNsdWRpbmcgYHRva2VuYCBhbmQgYGRlY29kZWRUb2tlbmBcbiAgKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwUHJvZmlsZVRva2VuKHRva2VuKSB7XG4gIHJldHVybiB7XG4gICAgdG9rZW4sXG4gICAgZGVjb2RlZFRva2VuOiBkZWNvZGVUb2tlbih0b2tlbilcbiAgfVxufVxuXG4vKipcbiAgKiBWZXJpZmllcyBhIHByb2ZpbGUgdG9rZW5cbiAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gLSB0aGUgdG9rZW4gdG8gYmUgdmVyaWZpZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHVibGljS2V5T3JBZGRyZXNzIC0gdGhlIHB1YmxpYyBrZXkgb3IgYWRkcmVzcyBvZiB0aGVcbiAgKiAgIGtleXBhaXIgdGhhdCBpcyB0aG91Z2h0IHRvIGhhdmUgc2lnbmVkIHRoZSB0b2tlblxuICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdGhlIHZlcmlmaWVkLCBkZWNvZGVkIHByb2ZpbGUgdG9rZW5cbiAgKiBAdGhyb3dzIHtFcnJvcn0gLSB0aHJvd3MgYW4gZXJyb3IgaWYgdG9rZW4gdmVyaWZpY2F0aW9uIGZhaWxzXG4gICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5UHJvZmlsZVRva2VuKHRva2VuLCBwdWJsaWNLZXlPckFkZHJlc3MpIHtcbiAgY29uc3QgZGVjb2RlZFRva2VuID0gZGVjb2RlVG9rZW4odG9rZW4pXG4gIGNvbnN0IHBheWxvYWQgPSBkZWNvZGVkVG9rZW4ucGF5bG9hZFxuXG4gIC8vIEluc3BlY3QgYW5kIHZlcmlmeSB0aGUgc3ViamVjdFxuICBpZiAocGF5bG9hZC5oYXNPd25Qcm9wZXJ0eSgnc3ViamVjdCcpKSB7XG4gICAgaWYgKCFwYXlsb2FkLnN1YmplY3QuaGFzT3duUHJvcGVydHkoJ3B1YmxpY0tleScpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIGRvZXNuXFwndCBoYXZlIGEgc3ViamVjdCBwdWJsaWMga2V5JylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiBkb2VzblxcJ3QgaGF2ZSBhIHN1YmplY3QnKVxuICB9XG5cbiAgLy8gSW5zcGVjdCBhbmQgdmVyaWZ5IHRoZSBpc3N1ZXJcbiAgaWYgKHBheWxvYWQuaGFzT3duUHJvcGVydHkoJ2lzc3VlcicpKSB7XG4gICAgaWYgKCFwYXlsb2FkLmlzc3Vlci5oYXNPd25Qcm9wZXJ0eSgncHVibGljS2V5JykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gZG9lc25cXCd0IGhhdmUgYW4gaXNzdWVyIHB1YmxpYyBrZXknKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIGRvZXNuXFwndCBoYXZlIGFuIGlzc3VlcicpXG4gIH1cblxuICAvLyBJbnNwZWN0IGFuZCB2ZXJpZnkgdGhlIGNsYWltXG4gIGlmICghcGF5bG9hZC5oYXNPd25Qcm9wZXJ0eSgnY2xhaW0nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVG9rZW4gZG9lc25cXCd0IGhhdmUgYSBjbGFpbScpXG4gIH1cblxuICBjb25zdCBpc3N1ZXJQdWJsaWNLZXkgPSBwYXlsb2FkLmlzc3Vlci5wdWJsaWNLZXlcbiAgY29uc3QgcHVibGljS2V5QnVmZmVyID0gbmV3IEJ1ZmZlcihpc3N1ZXJQdWJsaWNLZXksICdoZXgnKVxuXG4gIGNvbnN0IGNvbXByZXNzZWRLZXlQYWlyID0gIEVDUGFpci5mcm9tUHVibGljS2V5KHB1YmxpY0tleUJ1ZmZlciwgeyBjb21wcmVzc2VkOiB0cnVlIH0pXG4gIGNvbnN0IGNvbXByZXNzZWRBZGRyZXNzID0gZWNQYWlyVG9BZGRyZXNzKGNvbXByZXNzZWRLZXlQYWlyKVxuICBjb25zdCB1bmNvbXByZXNzZWRLZXlQYWlyID0gRUNQYWlyLmZyb21QdWJsaWNLZXkocHVibGljS2V5QnVmZmVyLCB7IGNvbXByZXNzZWQ6IGZhbHNlIH0pXG4gIGNvbnN0IHVuY29tcHJlc3NlZEFkZHJlc3MgPSBlY1BhaXJUb0FkZHJlc3ModW5jb21wcmVzc2VkS2V5UGFpcilcblxuICBpZiAocHVibGljS2V5T3JBZGRyZXNzID09PSBpc3N1ZXJQdWJsaWNLZXkpIHtcbiAgICAvLyBwYXNzXG4gIH0gZWxzZSBpZiAocHVibGljS2V5T3JBZGRyZXNzID09PSBjb21wcmVzc2VkQWRkcmVzcykge1xuICAgIC8vIHBhc3NcbiAgfSBlbHNlIGlmIChwdWJsaWNLZXlPckFkZHJlc3MgPT09IHVuY29tcHJlc3NlZEFkZHJlc3MpIHtcbiAgICAvLyBwYXNzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiBpc3N1ZXIgcHVibGljIGtleSBkb2VzIG5vdCBtYXRjaCB0aGUgdmVyaWZ5aW5nIHZhbHVlJylcbiAgfVxuXG4gIGNvbnN0IHRva2VuVmVyaWZpZXIgPSBuZXcgVG9rZW5WZXJpZmllcihkZWNvZGVkVG9rZW4uaGVhZGVyLmFsZywgaXNzdWVyUHVibGljS2V5KVxuICBpZiAoIXRva2VuVmVyaWZpZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdG9rZW4gdmVyaWZpZXInKVxuICB9XG5cbiAgY29uc3QgdG9rZW5WZXJpZmllZCA9IHRva2VuVmVyaWZpZXIudmVyaWZ5KHRva2VuKVxuICBpZiAoIXRva2VuVmVyaWZpZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rva2VuIHZlcmlmaWNhdGlvbiBmYWlsZWQnKVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZWRUb2tlblxufVxuXG4vKipcbiAgKiBFeHRyYWN0cyBhIHByb2ZpbGUgZnJvbSBhbiBlbmNvZGVkIHRva2VuIGFuZCBvcHRpb25hbGx5IHZlcmlmaWVzIGl0LFxuICAqIGlmIGBwdWJsaWNLZXlPckFkZHJlc3NgIGlzIHByb3ZpZGVkLlxuICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAtIHRoZSB0b2tlbiB0byBiZSBleHRyYWN0ZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gcHVibGljS2V5T3JBZGRyZXNzIC0gdGhlIHB1YmxpYyBrZXkgb3IgYWRkcmVzcyBvZiB0aGVcbiAgKiAgIGtleXBhaXIgdGhhdCBpcyB0aG91Z2h0IHRvIGhhdmUgc2lnbmVkIHRoZSB0b2tlblxuICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdGhlIHByb2ZpbGUgZXh0cmFjdGVkIGZyb20gdGhlIGVuY29kZWQgdG9rZW5cbiAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiB0aGUgdG9rZW4gaXNuJ3Qgc2lnbmVkIGJ5IHRoZSBwcm92aWRlZCBgcHVibGljS2V5T3JBZGRyZXNzYFxuICAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RQcm9maWxlKHRva2VuLCBwdWJsaWNLZXlPckFkZHJlc3MgPSBudWxsKSB7XG4gIGxldCBkZWNvZGVkVG9rZW5cbiAgaWYgKHB1YmxpY0tleU9yQWRkcmVzcykge1xuICAgIGRlY29kZWRUb2tlbiA9IHZlcmlmeVByb2ZpbGVUb2tlbih0b2tlbiwgcHVibGljS2V5T3JBZGRyZXNzKVxuICB9IGVsc2Uge1xuICAgIGRlY29kZWRUb2tlbiA9IGRlY29kZVRva2VuKHRva2VuKVxuICB9XG5cbiAgbGV0IHByb2ZpbGUgPSB7fVxuICBpZiAoZGVjb2RlZFRva2VuLmhhc093blByb3BlcnR5KCdwYXlsb2FkJykpIHtcbiAgICBjb25zdCBwYXlsb2FkID0gZGVjb2RlZFRva2VuLnBheWxvYWRcbiAgICBpZiAocGF5bG9hZC5oYXNPd25Qcm9wZXJ0eSgnY2xhaW0nKSkge1xuICAgICAgcHJvZmlsZSA9IGRlY29kZWRUb2tlbi5wYXlsb2FkLmNsYWltXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb2ZpbGVcbn1cbiJdfQ==