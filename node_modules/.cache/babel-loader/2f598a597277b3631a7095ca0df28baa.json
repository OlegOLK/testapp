{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\n\nvar _wrapNativeSuper = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/wrapNativeSuper\");\n\nexports.__esModule = true;\nexports.encryptMnemonic = encryptMnemonic;\nexports.decryptMnemonic = decryptMnemonic;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nvar _bip = _interopRequireDefault(require(\"bip39\"));\n\nvar _triplesec = _interopRequireDefault(require(\"triplesec\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n */\n\n\nfunction encryptMnemonic(phrase, password) {\n  return Promise.resolve().then(function () {\n    // must be bip39 mnemonic\n    if (!_bip.default.validateMnemonic(phrase)) {\n      throw new Error('Not a valid bip39 nmemonic');\n    } // normalize plaintext to fixed length byte string\n\n\n    var plaintextNormalized = Buffer.from(_bip.default.mnemonicToEntropy(phrase).toString('hex'), 'hex'); // AES-128-CBC with SHA256 HMAC\n\n    var salt = _crypto.default.randomBytes(16);\n\n    var keysAndIV = _crypto.default.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n\n    var encKey = keysAndIV.slice(0, 16);\n    var macKey = keysAndIV.slice(16, 32);\n    var iv = keysAndIV.slice(32, 48);\n\n    var cipher = _crypto.default.createCipheriv('aes-128-cbc', encKey, iv);\n\n    var cipherText = cipher.update(plaintextNormalized).toString('hex');\n    cipherText += cipher.final().toString('hex');\n    var hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')]);\n\n    var hmac = _crypto.default.createHmac('sha256', macKey);\n\n    hmac.write(hmacPayload);\n    var hmacDigest = hmac.digest();\n    var payload = Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')]);\n    return payload;\n  });\n} // Used to distinguish bad password during decrypt vs invalid format\n\n\nvar PasswordError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(PasswordError, _Error);\n\n  function PasswordError() {\n    _classCallCheck(this, PasswordError);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PasswordError).apply(this, arguments));\n  }\n\n  return PasswordError;\n}(_wrapNativeSuper(Error));\n\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n  return Promise.resolve().then(function () {\n    var salt = dataBuffer.slice(0, 16);\n    var hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n\n    var cipherText = dataBuffer.slice(48);\n    var hmacPayload = Buffer.concat([salt, cipherText]);\n\n    var keysAndIV = _crypto.default.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n\n    var encKey = keysAndIV.slice(0, 16);\n    var macKey = keysAndIV.slice(16, 32);\n    var iv = keysAndIV.slice(32, 48);\n\n    var decipher = _crypto.default.createDecipheriv('aes-128-cbc', encKey, iv);\n\n    var plaintext = decipher.update(cipherText).toString('hex');\n    plaintext += decipher.final().toString('hex');\n\n    var hmac = _crypto.default.createHmac('sha256', macKey);\n\n    hmac.write(hmacPayload);\n    var hmacDigest = hmac.digest(); // hash both hmacSig and hmacDigest so string comparison time\n    // is uncorrelated to the ciphertext\n\n    var hmacSigHash = _crypto.default.createHash('sha256').update(hmacSig).digest().toString('hex');\n\n    var hmacDigestHash = _crypto.default.createHash('sha256').update(hmacDigest).digest().toString('hex');\n\n    if (hmacSigHash !== hmacDigestHash) {\n      // not authentic\n      throw new PasswordError('Wrong password (HMAC mismatch)');\n    }\n\n    var mnemonic = _bip.default.entropyToMnemonic(plaintext);\n\n    if (!_bip.default.validateMnemonic(mnemonic)) {\n      throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n\n    return mnemonic;\n  });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n */\n\n\nfunction decryptLegacy(dataBuffer, password) {\n  return new Promise(function (resolve, reject) {\n    _triplesec.default.decrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, function (err, plaintextBuffer) {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n/**\n * Encrypt a raw mnemonic phrase with a password\n * @param {string | Buffer} data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param {string} password - Password for data\n * @return {Promise<Buffer>} the raw mnemonic phrase\n * @private\n */\n\n\nfunction decryptMnemonic(data, password) {\n  var dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n  return decryptMnemonicBuffer(dataBuffer, password).catch(function (err) {\n    // If it was a password error, don't even bother with legacy\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n\n    return decryptLegacy(dataBuffer, password);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}