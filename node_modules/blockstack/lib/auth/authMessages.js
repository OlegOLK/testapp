"use strict";

exports.__esModule = true;
exports.generateTransitKey = generateTransitKey;
exports.makeAuthRequestImpl = makeAuthRequestImpl;
exports.encryptPrivateKey = encryptPrivateKey;
exports.decryptPrivateKey = decryptPrivateKey;
exports.makeAuthResponse = makeAuthResponse;

require("cross-fetch/polyfill");

var _jsontokens = require("jsontokens");

var _index = require("../index");

var _ec = require("../encryption/ec");

var _logger = require("../logger");

const VERSION = '1.3.1';

/**
 * Generates a ECDSA keypair to
 * use as the ephemeral app transit private key
 * @param {SessionData} session - session object in which key will be stored
 * @return {String} the hex encoded private key
 * @private
 */
function generateTransitKey() {
  const transitKey = (0, _index.makeECPrivateKey)();
  return transitKey;
}
/**
 * Generates an authentication request that can be sent to the Blockstack
 * browser for the user to approve sign in. This authentication request can
 * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`
 * method.
 *
 * *Note: This method should only be used if you want to roll your own authentication
 * flow. Typically you'd use `redirectToSignIn` which takes care of this
 * under the hood.*
 *
 * @param  {String} transitPrivateKey - hex encoded transit private key
 * @param {String} redirectURI - location to redirect user to after sign in approval
 * @param {String} manifestURI - location of this app's manifest file
 * @param {Array<String>} scopes - the permissions this app is requesting
 * @param {String} appDomain - the origin of this app
 * @param {Number} expiresAt - the time at which this request is no longer valid
 * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.
 * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported
 * by special authenticators.
 * @return {String} the authentication request
 * @private
 */


function makeAuthRequestImpl(transitPrivateKey, redirectURI, manifestURI, scopes, appDomain = window.location.origin, expiresAt, extraParams = {}) {
  /* Create the payload */
  const payload = Object.assign({}, extraParams, {
    jti: (0, _index.makeUUID4)(),
    iat: Math.floor(new Date().getTime() / 1000),
    // JWT times are in seconds
    exp: Math.floor(expiresAt / 1000),
    // JWT times are in seconds
    iss: null,
    public_keys: [],
    domain_name: appDomain,
    manifest_uri: manifestURI,
    redirect_uri: redirectURI,
    version: VERSION,
    do_not_include_profile: true,
    supports_hub_url: true,
    scopes
  });

  _logger.Logger.info(`blockstack.js: generating v${VERSION} auth request`);
  /* Convert the private key to a public key to an issuer */


  const publicKey = _jsontokens.SECP256K1Client.derivePublicKey(transitPrivateKey);

  payload.public_keys = [publicKey];
  const address = (0, _index.publicKeyToAddress)(publicKey);
  payload.iss = (0, _index.makeDIDFromAddress)(address);
  /* Sign and return the token */

  const tokenSigner = new _jsontokens.TokenSigner('ES256k', transitPrivateKey);
  const token = tokenSigner.sign(payload);
  return token;
}
/**
 * Encrypts the private key for decryption by the given
 * public key.
 * @param  {String} publicKey  [description]
 * @param  {String} privateKey [description]
 * @return {String} hex encoded ciphertext
 * @private
 */


function encryptPrivateKey(publicKey, privateKey) {
  const encryptedObj = (0, _ec.encryptECIES)(publicKey, privateKey);
  const encryptedJSON = JSON.stringify(encryptedObj);
  return new Buffer(encryptedJSON).toString('hex');
}
/**
 * Decrypts the hex encrypted private key
 * @param  {String} privateKey  the private key corresponding to the public
 * key for which the ciphertext was encrypted
 * @param  {String} hexedEncrypted the ciphertext
 * @return {String}  the decrypted private key
 * @throws {Error} if unable to decrypt
 *
 * @private
 */


function decryptPrivateKey(privateKey, hexedEncrypted) {
  const unhexedString = new Buffer(hexedEncrypted, 'hex').toString();
  const encryptedObj = JSON.parse(unhexedString);
  const decrypted = (0, _ec.decryptECIES)(privateKey, encryptedObj);

  if (typeof decrypted !== 'string') {
    throw new Error('Unable to correctly decrypt private key');
  } else {
    return decrypted;
  }
}
/**
 * Generates a signed authentication response token for an app. This
 * token is sent back to apps which use contents to access the
 * resources and data requested by the app.
 *
 * @param  {String} privateKey the identity key of the Blockstack ID generating
 * the authentication response
 * @param  {Object} profile the profile object for the Blockstack ID
 * @param  {String} username the username of the Blockstack ID if any, otherwise `null`
 * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication
 * response including `email` if requested and available and a URL to the profile
 * @param  {String} coreToken core session token when responding to a legacy auth request
 * or `null` for current direct to gaia authentication requests
 * @param  {String} appPrivateKey the application private key. This private key is
 * unique and specific for every Blockstack ID and application combination.
 * @param  {Number} expiresAt an integer in the same format as
 * `new Date().getTime()`, milliseconds since the Unix epoch
 * @param {String} transitPublicKey the public key provide by the app
 * in its authentication request with which secrets will be encrypted
 * @param {String} hubUrl URL to the write path of the user's Gaia hub
 * @param {String} blockstackAPIUrl URL to the API endpoint to use
 * @param {String} associationToken JWT that binds the app key to the identity key
 * @return {String} signed and encoded authentication response token
 * @private
 */


function makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = (0, _index.nextMonth)().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {
  /* Convert the private key to a public key to an issuer */
  const publicKey = _jsontokens.SECP256K1Client.derivePublicKey(privateKey);

  const address = (0, _index.publicKeyToAddress)(publicKey);
  /* See if we should encrypt with the transit key */

  let privateKeyPayload = appPrivateKey;
  let coreTokenPayload = coreToken;
  let additionalProperties = {};

  if (appPrivateKey !== undefined && appPrivateKey !== null) {
    _logger.Logger.info(`blockstack.js: generating v${VERSION} auth response`);

    if (transitPublicKey !== undefined && transitPublicKey !== null) {
      privateKeyPayload = encryptPrivateKey(transitPublicKey, appPrivateKey);

      if (coreToken !== undefined && coreToken !== null) {
        coreTokenPayload = encryptPrivateKey(transitPublicKey, coreToken);
      }
    }

    additionalProperties = {
      email: metadata.email ? metadata.email : null,
      profile_url: metadata.profileUrl ? metadata.profileUrl : null,
      hubUrl,
      blockstackAPIUrl,
      associationToken,
      version: VERSION
    };
  } else {
    _logger.Logger.info('blockstack.js: generating legacy auth response');
  }
  /* Create the payload */


  const payload = Object.assign({}, {
    jti: (0, _index.makeUUID4)(),
    iat: Math.floor(new Date().getTime() / 1000),
    // JWT times are in seconds
    exp: Math.floor(expiresAt / 1000),
    // JWT times are in seconds
    iss: (0, _index.makeDIDFromAddress)(address),
    private_key: privateKeyPayload,
    public_keys: [publicKey],
    profile,
    username,
    core_token: coreTokenPayload
  }, additionalProperties);
  /* Sign and return the token */

  const tokenSigner = new _jsontokens.TokenSigner('ES256k', privateKey);
  return tokenSigner.sign(payload);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdXRoL2F1dGhNZXNzYWdlcy5qcyJdLCJuYW1lcyI6WyJWRVJTSU9OIiwiZ2VuZXJhdGVUcmFuc2l0S2V5IiwidHJhbnNpdEtleSIsIm1ha2VBdXRoUmVxdWVzdEltcGwiLCJ0cmFuc2l0UHJpdmF0ZUtleSIsInJlZGlyZWN0VVJJIiwibWFuaWZlc3RVUkkiLCJzY29wZXMiLCJhcHBEb21haW4iLCJ3aW5kb3ciLCJsb2NhdGlvbiIsIm9yaWdpbiIsImV4cGlyZXNBdCIsImV4dHJhUGFyYW1zIiwicGF5bG9hZCIsIk9iamVjdCIsImFzc2lnbiIsImp0aSIsImlhdCIsIk1hdGgiLCJmbG9vciIsIkRhdGUiLCJnZXRUaW1lIiwiZXhwIiwiaXNzIiwicHVibGljX2tleXMiLCJkb21haW5fbmFtZSIsIm1hbmlmZXN0X3VyaSIsInJlZGlyZWN0X3VyaSIsInZlcnNpb24iLCJkb19ub3RfaW5jbHVkZV9wcm9maWxlIiwic3VwcG9ydHNfaHViX3VybCIsIkxvZ2dlciIsImluZm8iLCJwdWJsaWNLZXkiLCJTRUNQMjU2SzFDbGllbnQiLCJkZXJpdmVQdWJsaWNLZXkiLCJhZGRyZXNzIiwidG9rZW5TaWduZXIiLCJUb2tlblNpZ25lciIsInRva2VuIiwic2lnbiIsImVuY3J5cHRQcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsImVuY3J5cHRlZE9iaiIsImVuY3J5cHRlZEpTT04iLCJKU09OIiwic3RyaW5naWZ5IiwiQnVmZmVyIiwidG9TdHJpbmciLCJkZWNyeXB0UHJpdmF0ZUtleSIsImhleGVkRW5jcnlwdGVkIiwidW5oZXhlZFN0cmluZyIsInBhcnNlIiwiZGVjcnlwdGVkIiwiRXJyb3IiLCJtYWtlQXV0aFJlc3BvbnNlIiwicHJvZmlsZSIsInVzZXJuYW1lIiwibWV0YWRhdGEiLCJjb3JlVG9rZW4iLCJhcHBQcml2YXRlS2V5IiwidHJhbnNpdFB1YmxpY0tleSIsImh1YlVybCIsImJsb2Nrc3RhY2tBUElVcmwiLCJhc3NvY2lhdGlvblRva2VuIiwicHJpdmF0ZUtleVBheWxvYWQiLCJjb3JlVG9rZW5QYXlsb2FkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJ1bmRlZmluZWQiLCJlbWFpbCIsInByb2ZpbGVfdXJsIiwicHJvZmlsZVVybCIsInByaXZhdGVfa2V5IiwiY29yZV90b2tlbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7O0FBRUE7O0FBS0E7O0FBTUE7O0FBRUE7O0FBRUEsTUFBTUEsT0FBTyxHQUFHLE9BQWhCOztBQU9BOzs7Ozs7O0FBT08sU0FBU0Msa0JBQVQsR0FBOEI7QUFDbkMsUUFBTUMsVUFBVSxHQUFHLDhCQUFuQjtBQUNBLFNBQU9BLFVBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQk8sU0FBU0MsbUJBQVQsQ0FBNkJDLGlCQUE3QixFQUM2QkMsV0FEN0IsRUFFNkJDLFdBRjdCLEVBRzZCQyxNQUg3QixFQUk2QkMsU0FBaUIsR0FBR0MsTUFBTSxDQUFDQyxRQUFQLENBQWdCQyxNQUpqRSxFQUs2QkMsU0FMN0IsRUFNNkJDLFdBQW1CLEdBQUcsRUFObkQsRUFNK0Q7QUFDcEU7QUFDQSxRQUFNQyxPQUFPLEdBQUdDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjLEVBQWQsRUFBa0JILFdBQWxCLEVBQStCO0FBQzdDSSxJQUFBQSxHQUFHLEVBQUUsdUJBRHdDO0FBRTdDQyxJQUFBQSxHQUFHLEVBQUVDLElBQUksQ0FBQ0MsS0FBTCxDQUFXLElBQUlDLElBQUosR0FBV0MsT0FBWCxLQUF1QixJQUFsQyxDQUZ3QztBQUVDO0FBQzlDQyxJQUFBQSxHQUFHLEVBQUVKLElBQUksQ0FBQ0MsS0FBTCxDQUFXUixTQUFTLEdBQUcsSUFBdkIsQ0FId0M7QUFHVjtBQUNuQ1ksSUFBQUEsR0FBRyxFQUFFLElBSndDO0FBSzdDQyxJQUFBQSxXQUFXLEVBQUUsRUFMZ0M7QUFNN0NDLElBQUFBLFdBQVcsRUFBRWxCLFNBTmdDO0FBTzdDbUIsSUFBQUEsWUFBWSxFQUFFckIsV0FQK0I7QUFRN0NzQixJQUFBQSxZQUFZLEVBQUV2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QUFXLEVBQUUsQ0FBQ1MsU0FBRCxDQU5tQjtBQU9oQ3VCLElBQUFBLE9BUGdDO0FBUWhDQyxJQUFBQSxRQVJnQztBQVNoQ2dCLElBQUFBLFVBQVUsRUFBRVA7QUFUb0IsR0FBbEIsRUFVYkMsb0JBVmEsQ0FBaEI7QUFZQTs7QUFDQSxRQUFNOUIsV0FBVyxHQUFHLElBQUlDLHVCQUFKLENBQWdCLFFBQWhCLEVBQTBCSSxVQUExQixDQUFwQjtBQUNBLFNBQU9MLFdBQVcsQ0FBQ0csSUFBWixDQUFpQjNCLE9BQWpCLENBQVA7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qIEBmbG93ICovXG5pbXBvcnQgJ2Nyb3NzLWZldGNoL3BvbHlmaWxsJ1xuXG5pbXBvcnQge1xuICBUb2tlblNpZ25lcixcbiAgU0VDUDI1NksxQ2xpZW50XG59IGZyb20gJ2pzb250b2tlbnMnXG5cbmltcG9ydCB7XG4gIG1ha2VESURGcm9tQWRkcmVzcywgbWFrZVVVSUQ0LFxuICBuZXh0TW9udGgsIHB1YmxpY0tleVRvQWRkcmVzcyxcbiAgbWFrZUVDUHJpdmF0ZUtleVxufSBmcm9tICcuLi9pbmRleCdcblxuaW1wb3J0IHsgZW5jcnlwdEVDSUVTLCBkZWNyeXB0RUNJRVMgfSBmcm9tICcuLi9lbmNyeXB0aW9uL2VjJ1xuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInXG5cbmNvbnN0IFZFUlNJT04gPSAnMS4zLjEnXG5cbnR5cGUgQXV0aE1ldGFkYXRhID0ge1xuICBlbWFpbDogP3N0cmluZyxcbiAgcHJvZmlsZVVybDogP3N0cmluZ1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIEVDRFNBIGtleXBhaXIgdG9cbiAqIHVzZSBhcyB0aGUgZXBoZW1lcmFsIGFwcCB0cmFuc2l0IHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge1Nlc3Npb25EYXRhfSBzZXNzaW9uIC0gc2Vzc2lvbiBvYmplY3QgaW4gd2hpY2gga2V5IHdpbGwgYmUgc3RvcmVkXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBoZXggZW5jb2RlZCBwcml2YXRlIGtleVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlVHJhbnNpdEtleSgpIHtcbiAgY29uc3QgdHJhbnNpdEtleSA9IG1ha2VFQ1ByaXZhdGVLZXkoKVxuICByZXR1cm4gdHJhbnNpdEtleVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IHRoYXQgY2FuIGJlIHNlbnQgdG8gdGhlIEJsb2Nrc3RhY2tcbiAqIGJyb3dzZXIgZm9yIHRoZSB1c2VyIHRvIGFwcHJvdmUgc2lnbiBpbi4gVGhpcyBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGNhblxuICogdGhlbiBiZSB1c2VkIGZvciBzaWduIGluIGJ5IHBhc3NpbmcgaXQgdG8gdGhlIGByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0YFxuICogbWV0aG9kLlxuICpcbiAqICpOb3RlOiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSB1c2VkIGlmIHlvdSB3YW50IHRvIHJvbGwgeW91ciBvd24gYXV0aGVudGljYXRpb25cbiAqIGZsb3cuIFR5cGljYWxseSB5b3UnZCB1c2UgYHJlZGlyZWN0VG9TaWduSW5gIHdoaWNoIHRha2VzIGNhcmUgb2YgdGhpc1xuICogdW5kZXIgdGhlIGhvb2QuKlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHJhbnNpdFByaXZhdGVLZXkgLSBoZXggZW5jb2RlZCB0cmFuc2l0IHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gcmVkaXJlY3RVUkkgLSBsb2NhdGlvbiB0byByZWRpcmVjdCB1c2VyIHRvIGFmdGVyIHNpZ24gaW4gYXBwcm92YWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBtYW5pZmVzdFVSSSAtIGxvY2F0aW9uIG9mIHRoaXMgYXBwJ3MgbWFuaWZlc3QgZmlsZVxuICogQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBzY29wZXMgLSB0aGUgcGVybWlzc2lvbnMgdGhpcyBhcHAgaXMgcmVxdWVzdGluZ1xuICogQHBhcmFtIHtTdHJpbmd9IGFwcERvbWFpbiAtIHRoZSBvcmlnaW4gb2YgdGhpcyBhcHBcbiAqIEBwYXJhbSB7TnVtYmVyfSBleHBpcmVzQXQgLSB0aGUgdGltZSBhdCB3aGljaCB0aGlzIHJlcXVlc3QgaXMgbm8gbG9uZ2VyIHZhbGlkXG4gKiBAcGFyYW0ge09iamVjdH0gZXh0cmFQYXJhbXMgLSBBbnkgZXh0cmEgcGFyYW1ldGVycyB5b3UnZCBsaWtlIHRvIHBhc3MgdG8gdGhlIGF1dGhlbnRpY2F0b3IuXG4gKiBVc2UgdGhpcyB0byBwYXNzIG9wdGlvbnMgdGhhdCBhcmVuJ3QgcGFydCBvZiB0aGUgQmxvY2tzdGFjayBhdXRoIHNwZWMsIGJ1dCBtaWdodCBiZSBzdXBwb3J0ZWRcbiAqIGJ5IHNwZWNpYWwgYXV0aGVudGljYXRvcnMuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0SW1wbCh0cmFuc2l0UHJpdmF0ZUtleTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3RVUkk6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0VVJJOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZXM6IEFycmF5PHN0cmluZz4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBEb21haW46IHN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzQXQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiBPYmplY3QgPSB7fSk6IHN0cmluZyB7XG4gIC8qIENyZWF0ZSB0aGUgcGF5bG9hZCAqL1xuICBjb25zdCBwYXlsb2FkID0gT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMsIHtcbiAgICBqdGk6IG1ha2VVVUlENCgpLFxuICAgIGlhdDogTWF0aC5mbG9vcihuZXcgRGF0ZSgpLmdldFRpbWUoKSAvIDEwMDApLCAvLyBKV1QgdGltZXMgYXJlIGluIHNlY29uZHNcbiAgICBleHA6IE1hdGguZmxvb3IoZXhwaXJlc0F0IC8gMTAwMCksIC8vIEpXVCB0aW1lcyBhcmUgaW4gc2Vjb25kc1xuICAgIGlzczogbnVsbCxcbiAgICBwdWJsaWNfa2V5czogW10sXG4gICAgZG9tYWluX25hbWU6IGFwcERvbWFpbixcbiAgICBtYW5pZmVzdF91cmk6IG1hbmlmZXN0VVJJLFxuICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVUkksXG4gICAgdmVyc2lvbjogVkVSU0lPTixcbiAgICBkb19ub3RfaW5jbHVkZV9wcm9maWxlOiB0cnVlLFxuICAgIHN1cHBvcnRzX2h1Yl91cmw6IHRydWUsXG4gICAgc2NvcGVzXG4gIH0pXG5cbiAgTG9nZ2VyLmluZm8oYGJsb2Nrc3RhY2suanM6IGdlbmVyYXRpbmcgdiR7VkVSU0lPTn0gYXV0aCByZXF1ZXN0YClcblxuICAvKiBDb252ZXJ0IHRoZSBwcml2YXRlIGtleSB0byBhIHB1YmxpYyBrZXkgdG8gYW4gaXNzdWVyICovXG4gIGNvbnN0IHB1YmxpY0tleSA9IFNFQ1AyNTZLMUNsaWVudC5kZXJpdmVQdWJsaWNLZXkodHJhbnNpdFByaXZhdGVLZXkpXG4gIHBheWxvYWQucHVibGljX2tleXMgPSBbcHVibGljS2V5XVxuICBjb25zdCBhZGRyZXNzID0gcHVibGljS2V5VG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgcGF5bG9hZC5pc3MgPSBtYWtlRElERnJvbUFkZHJlc3MoYWRkcmVzcylcblxuICAvKiBTaWduIGFuZCByZXR1cm4gdGhlIHRva2VuICovXG4gIGNvbnN0IHRva2VuU2lnbmVyID0gbmV3IFRva2VuU2lnbmVyKCdFUzI1NmsnLCB0cmFuc2l0UHJpdmF0ZUtleSlcbiAgY29uc3QgdG9rZW4gPSB0b2tlblNpZ25lci5zaWduKHBheWxvYWQpXG5cbiAgcmV0dXJuIHRva2VuXG59XG5cbi8qKlxuICogRW5jcnlwdHMgdGhlIHByaXZhdGUga2V5IGZvciBkZWNyeXB0aW9uIGJ5IHRoZSBnaXZlblxuICogcHVibGljIGtleS5cbiAqIEBwYXJhbSAge1N0cmluZ30gcHVibGljS2V5ICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHByaXZhdGVLZXkgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7U3RyaW5nfSBoZXggZW5jb2RlZCBjaXBoZXJ0ZXh0XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdFByaXZhdGVLZXkocHVibGljS2V5OiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpdmF0ZUtleTogc3RyaW5nKTogc3RyaW5nIHwgbnVsbCB7XG4gIGNvbnN0IGVuY3J5cHRlZE9iaiA9IGVuY3J5cHRFQ0lFUyhwdWJsaWNLZXksIHByaXZhdGVLZXkpXG4gIGNvbnN0IGVuY3J5cHRlZEpTT04gPSBKU09OLnN0cmluZ2lmeShlbmNyeXB0ZWRPYmopXG4gIHJldHVybiAobmV3IEJ1ZmZlcihlbmNyeXB0ZWRKU09OKSkudG9TdHJpbmcoJ2hleCcpXG59XG5cbi8qKlxuICogRGVjcnlwdHMgdGhlIGhleCBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJpdmF0ZUtleSAgdGhlIHByaXZhdGUga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHB1YmxpY1xuICoga2V5IGZvciB3aGljaCB0aGUgY2lwaGVydGV4dCB3YXMgZW5jcnlwdGVkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGhleGVkRW5jcnlwdGVkIHRoZSBjaXBoZXJ0ZXh0XG4gKiBAcmV0dXJuIHtTdHJpbmd9ICB0aGUgZGVjcnlwdGVkIHByaXZhdGUga2V5XG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdW5hYmxlIHRvIGRlY3J5cHRcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdFByaXZhdGVLZXkocHJpdmF0ZUtleTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleGVkRW5jcnlwdGVkOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgY29uc3QgdW5oZXhlZFN0cmluZyA9IG5ldyBCdWZmZXIoaGV4ZWRFbmNyeXB0ZWQsICdoZXgnKS50b1N0cmluZygpXG4gIGNvbnN0IGVuY3J5cHRlZE9iaiA9IEpTT04ucGFyc2UodW5oZXhlZFN0cmluZylcbiAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdEVDSUVTKHByaXZhdGVLZXksIGVuY3J5cHRlZE9iailcbiAgaWYgKHR5cGVvZiBkZWNyeXB0ZWQgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gY29ycmVjdGx5IGRlY3J5cHQgcHJpdmF0ZSBrZXknKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBkZWNyeXB0ZWRcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNpZ25lZCBhdXRoZW50aWNhdGlvbiByZXNwb25zZSB0b2tlbiBmb3IgYW4gYXBwLiBUaGlzXG4gKiB0b2tlbiBpcyBzZW50IGJhY2sgdG8gYXBwcyB3aGljaCB1c2UgY29udGVudHMgdG8gYWNjZXNzIHRoZVxuICogcmVzb3VyY2VzIGFuZCBkYXRhIHJlcXVlc3RlZCBieSB0aGUgYXBwLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gcHJpdmF0ZUtleSB0aGUgaWRlbnRpdHkga2V5IG9mIHRoZSBCbG9ja3N0YWNrIElEIGdlbmVyYXRpbmdcbiAqIHRoZSBhdXRoZW50aWNhdGlvbiByZXNwb25zZVxuICogQHBhcmFtICB7T2JqZWN0fSBwcm9maWxlIHRoZSBwcm9maWxlIG9iamVjdCBmb3IgdGhlIEJsb2Nrc3RhY2sgSURcbiAqIEBwYXJhbSAge1N0cmluZ30gdXNlcm5hbWUgdGhlIHVzZXJuYW1lIG9mIHRoZSBCbG9ja3N0YWNrIElEIGlmIGFueSwgb3RoZXJ3aXNlIGBudWxsYFxuICogQHBhcmFtICB7QXV0aE1ldGFkYXRhfSBtZXRhZGF0YSBhbiBvYmplY3QgY29udGFpbmluZyBtZXRhZGF0YSBzZW50IGFzIHBhcnQgb2YgdGhlIGF1dGhlbnRpY2F0aW9uXG4gKiByZXNwb25zZSBpbmNsdWRpbmcgYGVtYWlsYCBpZiByZXF1ZXN0ZWQgYW5kIGF2YWlsYWJsZSBhbmQgYSBVUkwgdG8gdGhlIHByb2ZpbGVcbiAqIEBwYXJhbSAge1N0cmluZ30gY29yZVRva2VuIGNvcmUgc2Vzc2lvbiB0b2tlbiB3aGVuIHJlc3BvbmRpbmcgdG8gYSBsZWdhY3kgYXV0aCByZXF1ZXN0XG4gKiBvciBgbnVsbGAgZm9yIGN1cnJlbnQgZGlyZWN0IHRvIGdhaWEgYXV0aGVudGljYXRpb24gcmVxdWVzdHNcbiAqIEBwYXJhbSAge1N0cmluZ30gYXBwUHJpdmF0ZUtleSB0aGUgYXBwbGljYXRpb24gcHJpdmF0ZSBrZXkuIFRoaXMgcHJpdmF0ZSBrZXkgaXNcbiAqIHVuaXF1ZSBhbmQgc3BlY2lmaWMgZm9yIGV2ZXJ5IEJsb2Nrc3RhY2sgSUQgYW5kIGFwcGxpY2F0aW9uIGNvbWJpbmF0aW9uLlxuICogQHBhcmFtICB7TnVtYmVyfSBleHBpcmVzQXQgYW4gaW50ZWdlciBpbiB0aGUgc2FtZSBmb3JtYXQgYXNcbiAqIGBuZXcgRGF0ZSgpLmdldFRpbWUoKWAsIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgVW5peCBlcG9jaFxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zaXRQdWJsaWNLZXkgdGhlIHB1YmxpYyBrZXkgcHJvdmlkZSBieSB0aGUgYXBwXG4gKiBpbiBpdHMgYXV0aGVudGljYXRpb24gcmVxdWVzdCB3aXRoIHdoaWNoIHNlY3JldHMgd2lsbCBiZSBlbmNyeXB0ZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBodWJVcmwgVVJMIHRvIHRoZSB3cml0ZSBwYXRoIG9mIHRoZSB1c2VyJ3MgR2FpYSBodWJcbiAqIEBwYXJhbSB7U3RyaW5nfSBibG9ja3N0YWNrQVBJVXJsIFVSTCB0byB0aGUgQVBJIGVuZHBvaW50IHRvIHVzZVxuICogQHBhcmFtIHtTdHJpbmd9IGFzc29jaWF0aW9uVG9rZW4gSldUIHRoYXQgYmluZHMgdGhlIGFwcCBrZXkgdG8gdGhlIGlkZW50aXR5IGtleVxuICogQHJldHVybiB7U3RyaW5nfSBzaWduZWQgYW5kIGVuY29kZWQgYXV0aGVudGljYXRpb24gcmVzcG9uc2UgdG9rZW5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQXV0aFJlc3BvbnNlKHByaXZhdGVLZXk6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2ZpbGU6IHt9ID0ge30sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VybmFtZTogP3N0cmluZyA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogQXV0aE1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29yZVRva2VuOiA/c3RyaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcFByaXZhdGVLZXk6ID9zdHJpbmcgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBudW1iZXIgPSBuZXh0TW9udGgoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0UHVibGljS2V5OiA/c3RyaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGh1YlVybDogP3N0cmluZyA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3N0YWNrQVBJVXJsOiA/c3RyaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc29jaWF0aW9uVG9rZW46ID9zdHJpbmcgPSBudWxsKTogc3RyaW5nIHtcbiAgLyogQ29udmVydCB0aGUgcHJpdmF0ZSBrZXkgdG8gYSBwdWJsaWMga2V5IHRvIGFuIGlzc3VlciAqL1xuICBjb25zdCBwdWJsaWNLZXkgPSBTRUNQMjU2SzFDbGllbnQuZGVyaXZlUHVibGljS2V5KHByaXZhdGVLZXkpXG4gIGNvbnN0IGFkZHJlc3MgPSBwdWJsaWNLZXlUb0FkZHJlc3MocHVibGljS2V5KVxuXG4gIC8qIFNlZSBpZiB3ZSBzaG91bGQgZW5jcnlwdCB3aXRoIHRoZSB0cmFuc2l0IGtleSAqL1xuICBsZXQgcHJpdmF0ZUtleVBheWxvYWQgPSBhcHBQcml2YXRlS2V5XG4gIGxldCBjb3JlVG9rZW5QYXlsb2FkID0gY29yZVRva2VuXG4gIGxldCBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHt9XG4gIGlmIChhcHBQcml2YXRlS2V5ICE9PSB1bmRlZmluZWQgJiYgYXBwUHJpdmF0ZUtleSAhPT0gbnVsbCkge1xuICAgIExvZ2dlci5pbmZvKGBibG9ja3N0YWNrLmpzOiBnZW5lcmF0aW5nIHYke1ZFUlNJT059IGF1dGggcmVzcG9uc2VgKVxuICAgIGlmICh0cmFuc2l0UHVibGljS2V5ICE9PSB1bmRlZmluZWQgJiYgdHJhbnNpdFB1YmxpY0tleSAhPT0gbnVsbCkge1xuICAgICAgcHJpdmF0ZUtleVBheWxvYWQgPSBlbmNyeXB0UHJpdmF0ZUtleSh0cmFuc2l0UHVibGljS2V5LCBhcHBQcml2YXRlS2V5KVxuICAgICAgaWYgKGNvcmVUb2tlbiAhPT0gdW5kZWZpbmVkICYmIGNvcmVUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgICBjb3JlVG9rZW5QYXlsb2FkID0gZW5jcnlwdFByaXZhdGVLZXkodHJhbnNpdFB1YmxpY0tleSwgY29yZVRva2VuKVxuICAgICAgfVxuICAgIH1cbiAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHtcbiAgICAgIGVtYWlsOiBtZXRhZGF0YS5lbWFpbCA/IG1ldGFkYXRhLmVtYWlsIDogbnVsbCxcbiAgICAgIHByb2ZpbGVfdXJsOiBtZXRhZGF0YS5wcm9maWxlVXJsID8gbWV0YWRhdGEucHJvZmlsZVVybCA6IG51bGwsXG4gICAgICBodWJVcmwsXG4gICAgICBibG9ja3N0YWNrQVBJVXJsLFxuICAgICAgYXNzb2NpYXRpb25Ub2tlbixcbiAgICAgIHZlcnNpb246IFZFUlNJT05cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTG9nZ2VyLmluZm8oJ2Jsb2Nrc3RhY2suanM6IGdlbmVyYXRpbmcgbGVnYWN5IGF1dGggcmVzcG9uc2UnKVxuICB9XG5cbiAgLyogQ3JlYXRlIHRoZSBwYXlsb2FkICovXG4gIGNvbnN0IHBheWxvYWQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAganRpOiBtYWtlVVVJRDQoKSxcbiAgICBpYXQ6IE1hdGguZmxvb3IobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKSwgLy8gSldUIHRpbWVzIGFyZSBpbiBzZWNvbmRzXG4gICAgZXhwOiBNYXRoLmZsb29yKGV4cGlyZXNBdCAvIDEwMDApLCAvLyBKV1QgdGltZXMgYXJlIGluIHNlY29uZHNcbiAgICBpc3M6IG1ha2VESURGcm9tQWRkcmVzcyhhZGRyZXNzKSxcbiAgICBwcml2YXRlX2tleTogcHJpdmF0ZUtleVBheWxvYWQsXG4gICAgcHVibGljX2tleXM6IFtwdWJsaWNLZXldLFxuICAgIHByb2ZpbGUsXG4gICAgdXNlcm5hbWUsXG4gICAgY29yZV90b2tlbjogY29yZVRva2VuUGF5bG9hZFxuICB9LCBhZGRpdGlvbmFsUHJvcGVydGllcylcblxuICAvKiBTaWduIGFuZCByZXR1cm4gdGhlIHRva2VuICovXG4gIGNvbnN0IHRva2VuU2lnbmVyID0gbmV3IFRva2VuU2lnbmVyKCdFUzI1NmsnLCBwcml2YXRlS2V5KVxuICByZXR1cm4gdG9rZW5TaWduZXIuc2lnbihwYXlsb2FkKVxufVxuIl19