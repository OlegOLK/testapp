"use strict";

exports.__esModule = true;
exports.transactions = void 0;

var _bitcoinjsLib = _interopRequireDefault(require("bitcoinjs-lib"));

var _bigi = _interopRequireDefault(require("bigi"));

var _utils = require("./utils");

var _skeletons = require("./skeletons");

var _config = require("../config");

var _errors = require("../errors");

var _signers = require("./signers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';
const dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';

function addOwnerInput(utxos, ownerAddress, txB, addChangeOut = true) {
  // add an owner UTXO and a change out.
  if (utxos.length <= 0) {
    throw new Error('Owner has no UTXOs for UPDATE.');
  }

  utxos.sort((a, b) => a.value - b.value);
  const ownerUTXO = utxos[0];
  const ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);

  if (addChangeOut) {
    txB.addOutput(ownerAddress, ownerUTXO.value);
  }

  return {
    index: ownerInput,
    value: ownerUTXO.value
  };
}

function fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts, changeIndex = null) {
  // change index for the payer.
  if (changeIndex === null) {
    changeIndex = txB.addOutput(paymentAddress, _utils.DUST_MINIMUM);
  } // fund the transaction fee.


  const txFee = (0, _utils.estimateTXBytes)(txB, 0, 0) * feeRate;
  const outAmounts = (0, _utils.sumOutputValues)(txB);
  const change = (0, _utils.addUTXOsToFund)(txB, utxos, txFee + outAmounts - inAmounts, feeRate);
  txB.__tx.outs[changeIndex].value += change;
  return txB;
}

function returnTransactionHex(txB, buildIncomplete = false) {
  if (buildIncomplete) {
    return txB.buildIncomplete().toHex();
  } else {
    return txB.build().toHex();
  }
}

function getTransactionSigner(input) {
  if (typeof input === 'string') {
    return _signers.PubkeyHashSigner.fromHexString(input);
  } else {
    return input;
  }
}
/**
 * Estimates cost of a preorder transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to preorder
 * @param {String} destinationAddress - the address to receive the name (this
 *    must be passed as the 'registrationAddress' in the register transaction)
 * @param {String} paymentAddress - the address funding the preorder
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the preorder. This includes a 5500 satoshi dust output for the preorder.
 *    Even though this is a change output, the payer must supply enough funds
 *    to generate this output, so we include it in the cost.
 * @private
 */


function estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress, paymentUtxos = 1) {
  const network = _config.config.network;
  const preorderPromise = network.getNamePrice(fullyQualifiedName).then(namePrice => (0, _skeletons.makePreorderSkeleton)(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress));
  return Promise.all([network.getFeeRate(), preorderPromise]).then(([feeRate, preorderTX]) => {
    const outputsValue = (0, _utils.sumOutputValues)(preorderTX);
    const txFee = feeRate * (0, _utils.estimateTXBytes)(preorderTX, paymentUtxos, 0);
    return txFee + outputsValue;
  });
}
/**
 * Estimates cost of a register transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to register
 * @param {String} registerAddress - the address to receive the name
 * @param {String} paymentAddress - the address funding the register
 * @param {Boolean} includingZonefile - whether or not we will broadcast
 *    a zonefile hash as part  of the register
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the register.
 * @private
 */


function estimateRegister(fullyQualifiedName, registerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {
  const network = _config.config.network;
  let valueHash;

  if (includingZonefile) {
    valueHash = dummyZonefileHash;
  }

  const registerTX = (0, _skeletons.makeRegisterSkeleton)(fullyQualifiedName, registerAddress, valueHash);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(registerTX); // 1 additional output for payer change

    const txFee = feeRate * (0, _utils.estimateTXBytes)(registerTX, paymentUtxos, 1);
    return txFee + outputsValue;
  });
}
/**
 * Estimates cost of an update transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to update
 * @param {String} ownerAddress - the owner of the name
 * @param {String} paymentAddress - the address funding the update
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the update.
 * @private
 */


function estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {
  const network = _config.config.network;
  const updateTX = (0, _skeletons.makeUpdateSkeleton)(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(updateTX); // 1 additional input for the owner
    // 2 additional outputs for owner / payer change

    const txFee = feeRate * (0, _utils.estimateTXBytes)(updateTX, 1 + paymentUtxos, 2);
    return txFee + outputsValue;
  });
}
/**
 * Estimates cost of an transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to transfer
 * @param {String} destinationAddress - the next owner of the name
 * @param {String} ownerAddress - the current owner of the name
 * @param {String} paymentAddress - the address funding the transfer
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the transfer.
 * @private
 */


function estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, paymentUtxos = 1) {
  const network = _config.config.network;
  const transferTX = (0, _skeletons.makeTransferSkeleton)(fullyQualifiedName, dummyConsensusHash, destinationAddress);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(transferTX); // 1 additional input for the owner
    // 2 additional outputs for owner / payer change

    const txFee = feeRate * (0, _utils.estimateTXBytes)(transferTX, 1 + paymentUtxos, 2);
    return txFee + outputsValue;
  });
}
/**
 * Estimates cost of an transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to renew
 * @param {String} destinationAddress - the next owner of the name
 * @param {String} ownerAddress - the current owner of the name
 * @param {String} paymentAddress - the address funding the transfer
 * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash
      in the renewal operation
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the transfer.
 * @private
 */


function estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {
  const network = _config.config.network;
  let valueHash;

  if (includingZonefile) {
    valueHash = dummyZonefileHash;
  }

  const renewalPromise = network.getNamePrice(fullyQualifiedName).then(namePrice => (0, _skeletons.makeRenewalSkeleton)(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash));
  return Promise.all([network.getFeeRate(), renewalPromise]).then(([feeRate, renewalTX]) => {
    const outputsValue = (0, _utils.sumOutputValues)(renewalTX); // 1 additional input for the owner
    // and renewal skeleton includes all outputs for owner change, but not for payer change.

    const txFee = feeRate * (0, _utils.estimateTXBytes)(renewalTX, 1 + paymentUtxos, 1);
    return txFee + outputsValue - 5500; // don't count the dust change for old owner.
  });
}
/**
 * Estimates cost of a revoke transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to revoke
 * @param {String} ownerAddress - the current owner of the name
 * @param {String} paymentAddress  the address funding the revoke
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund the
 *    revoke.
 * @private
 */


function estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {
  const network = _config.config.network;
  const revokeTX = (0, _skeletons.makeRevokeSkeleton)(fullyQualifiedName);
  return Promise.all([network.getFeeRate()]).then(([feeRate]) => {
    const outputsValue = (0, _utils.sumOutputValues)(revokeTX); // 1 additional input for owner
    // 1 additional output for payer change

    const txFee = feeRate * (0, _utils.estimateTXBytes)(revokeTX, 1 + paymentUtxos, 2);
    return txFee + outputsValue;
  });
}
/**
 * Estimates cost of a namespace preorder transaction for a namespace
 * @param {String} namespaceID - the namespace to preorder
 * @param {String} revealAddress - the address to receive the namespace (this
 *    must be passed as the 'revealAddress' in the namespace-reveal transaction)
 * @param {String} paymentAddress - the address funding the preorder
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address.
 * @returns {Promise} - a promise which resolves to the satoshi cost to fund
 *    the preorder. This includes a 5500 satoshi dust output for the preorder.
 *    Even though this is a change output, the payer must supply enough funds
 *    to generate this output, so we include it in the cost.
 * @private
 */


function estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress, paymentUtxos = 1) {
  const network = _config.config.network;
  const preorderPromise = network.getNamespacePrice(namespaceID).then(namespacePrice => (0, _skeletons.makeNamespacePreorderSkeleton)(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice));
  return Promise.all([network.getFeeRate(), preorderPromise]).then(([feeRate, preorderTX]) => {
    const outputsValue = (0, _utils.sumOutputValues)(preorderTX);
    const txFee = feeRate * (0, _utils.estimateTXBytes)(preorderTX, paymentUtxos, 0);
    return txFee + outputsValue;
  });
}
/**
 * Estimates cost of a namesapce reveal transaction for a namespace
 * @param {BlockstackNamespace} namespace - the namespace to reveal
 * @param {String} revealAddress - the address to receive the namespace
 *    (this must have been passed as 'revealAddress' to a prior namespace
 *    preorder)
 * @param {String} paymentAddress - the address that pays for this transaction
 * @param {Number} paymentUtxos - the number of UTXOs we expect will be required
 *    from the payment address
 * @returns {Promise} - a promise which resolves to the satoshi cost to
 *    fund the reveal.  This includes a 5500 satoshi dust output for the
 *    preorder.  Even though this is a change output, the payer must have
 *    enough funds to generate this output, so we include it in the cost.
 * @private
 */


function estimateNamespaceReveal(namespace, revealAddress, paymentAddress, paymentUtxos = 1) {
  const network = _config.config.network;
  const revealTX = (0, _skeletons.makeNamespaceRevealSkeleton)(namespace, revealAddress);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(revealTX); // 1 additional output for payer change

    const txFee = feeRate * (0, _utils.estimateTXBytes)(revealTX, paymentUtxos, 1);
    return txFee + outputsValue;
  });
}
/**
 * Estimates the cost of a namespace-ready transaction for a namespace
 * @param {String} namespaceID - the namespace to ready
 * @param {Number} revealUtxos - the number of UTXOs we expect will
 *  be required from the reveal address
 * @returns {Promise} - a promise which resolves to the satoshi cost to
 *  fund this namespacey-ready transaction.
 * @private
 */


function estimateNamespaceReady(namespaceID, revealUtxos = 1) {
  const network = _config.config.network;
  const readyTX = (0, _skeletons.makeNamespaceReadySkeleton)(namespaceID);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(readyTX);
    const txFee = feeRate * (0, _utils.estimateTXBytes)(readyTX, revealUtxos, 1);
    return txFee + outputsValue;
  });
}
/**
 * Estimates the cost of a name-import transaction
 * @param {String} name - the fully-qualified name
 * @param {String} recipientAddr - the recipient
 * @param {String} zonefileHash - the zone file hash
 * @param {Number} importUtxos - the number of UTXOs we expect will
 *  be required from the importer address
 * @returns {Promise} - a promise which resolves to the satoshi cost
 *  to fund this name-import transaction
 * @private
 */


function estimateNameImport(name, recipientAddr, zonefileHash, importUtxos = 1) {
  const network = _config.config.network;
  const importTX = (0, _skeletons.makeNameImportSkeleton)(name, recipientAddr, zonefileHash);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(importTX);
    const txFee = feeRate * (0, _utils.estimateTXBytes)(importTX, importUtxos, 1);
    return txFee + outputsValue;
  });
}
/**
 * Estimates the cost of an announce transaction
 * @param {String} messageHash - the hash of the message
 * @param {Number} senderUtxos - the number of utxos we expect will
 *  be required from the importer address
 * @returns {Promise} - a promise which resolves to the satoshi cost
 *  to fund this announce transaction
 * @private
 */


function estimateAnnounce(messageHash, senderUtxos = 1) {
  const network = _config.config.network;
  const announceTX = (0, _skeletons.makeAnnounceSkeleton)(messageHash);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(announceTX);
    const txFee = feeRate * (0, _utils.estimateTXBytes)(announceTX, senderUtxos, 1);
    return txFee + outputsValue;
  });
}
/**
 * Estimates the cost of a token-transfer transaction
 * @param {String} recipientAddress - the recipient of the tokens
 * @param {String} tokenType - the type of token to spend
 * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens
 *   to spend
 * @param {String} scratchArea - an arbitrary string to store with the transaction
 * @param {Number} senderUtxos - the number of utxos we expect will
 *  be required from the importer address
 * @param {Number} additionalOutputs - the number of outputs we expect to add beyond
 *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)
 * @returns {Promise} - a promise which resolves to the satoshi cost to
 *  fund this token-transfer transaction
 * @private
 */


function estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderUtxos = 1, additionalOutputs = 1) {
  const network = _config.config.network;
  const tokenTransferTX = (0, _skeletons.makeTokenTransferSkeleton)(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);
  return network.getFeeRate().then(feeRate => {
    const outputsValue = (0, _utils.sumOutputValues)(tokenTransferTX);
    const txFee = feeRate * (0, _utils.estimateTXBytes)(tokenTransferTX, senderUtxos, additionalOutputs);
    return txFee + outputsValue;
  });
}
/**
 * Generates a preorder transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to pre-order
 * @param {String} destinationAddress - the address to receive the name (this
 *    must be passed as the 'registrationAddress' in the register transaction)
 * @param {String | TransactionSigner} paymentKeyIn - a hex string of
 *    the private key used to fund the transaction or a transaction signer object
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 * indicating whether the function should attempt to return an unsigned (or not fully signed)
 * transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const namespace = fullyQualifiedName.split('.').pop();
  const paymentKey = getTransactionSigner(paymentKeyIn);
  return paymentKey.getAddress().then(preorderAddress => {
    const preorderPromise = Promise.all([network.getConsensusHash(), network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(([consensusHash, namePrice, burnAddress]) => (0, _skeletons.makePreorderSkeleton)(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress));
    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(([utxos, feeRate, preorderSkeleton]) => {
      const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);

      txB.setVersion(1);
      const changeIndex = 1; // preorder skeleton always creates a change output at index = 1

      const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);
      return (0, _utils.signInputs)(signingTxB, paymentKey);
    }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
  });
}
/**
 * Generates an update transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to update
 * @param {String | TransactionSigner} ownerKeyIn - a hex string of the
 *    owner key, or a transaction signer object. This will provide one
 *    UTXO input, and also recieve a dust output.
 * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a
 *    transaction signer object, of the private key used to fund the
 *    transaction's txfees
 * @param {String} zonefile - the zonefile data to update (this will be hashed
 *    to include in the transaction), the zonefile itself must be published
 *    after the UPDATE propagates.
 * @param {String} valueHash - if given, this is the hash to store (instead of
 *    zonefile).  zonefile will be ignored if this is given.
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *    indicating whether the function should attempt to return an unsigned (or not fully signed)
 *    transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile, valueHash = '', buildIncomplete = false) {
  const network = _config.config.network;

  if (!valueHash && !zonefile) {
    return Promise.reject(new Error('Need zonefile or valueHash arguments'));
  }

  if (valueHash.length === 0) {
    if (!zonefile) {
      return Promise.reject(new Error('Need zonefile or valueHash arguments'));
    }

    valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString('hex');
  } else if (valueHash.length !== 40) {
    return Promise.reject(new Error(`Invalid valueHash ${valueHash}`));
  }

  const paymentKey = getTransactionSigner(paymentKeyIn);
  const ownerKey = getTransactionSigner(ownerKeyIn);
  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {
    const txPromise = network.getConsensusHash().then(consensusHash => (0, _skeletons.makeUpdateSkeleton)(fullyQualifiedName, consensusHash, valueHash)).then(updateTX => {
      const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(updateTX, network.layer1);

      txB.setVersion(1);
      return txB;
    });
    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
      return (0, _utils.signInputs)(signingTxB, paymentKey, [{
        index: ownerInput.index,
        signer: ownerKey
      }]);
    });
  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a register transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to register
 * @param {String} registerAddress - the address to receive the name (this
 *    must have been passed as the 'destinationAddress' in the preorder transaction)
 *    this address will receive a dust UTXO
 * @param {String | TransactionSigner} paymentKeyIn - a hex string of
 *    the private key (or a TransactionSigner object) used to fund the
 *    transaction (this *must* be the same as the payment address used
 *    to fund the preorder)
 * @param {String} zonefile - the zonefile data to include (this will be hashed
 *    to include in the transaction), the zonefile itself must be published
 *    after the UPDATE propagates.
 * @param {String} valueHash - the hash of the zone file data to include.
 *    It will be used instead of zonefile, if given
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *    indicating whether the function should attempt to return an unsigned (or not fully signed)
 *    transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {
  const network = _config.config.network;

  if (!valueHash && !!zonefile) {
    valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString('hex');
  } else if (!!valueHash && valueHash.length !== 40) {
    return Promise.reject(new Error(`Invalid zonefile hash ${valueHash}`));
  }

  const registerSkeleton = (0, _skeletons.makeRegisterSkeleton)(fullyQualifiedName, registerAddress, valueHash);

  const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);

  txB.setVersion(1);
  const paymentKey = getTransactionSigner(paymentKeyIn);
  return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {
    const signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);
    return (0, _utils.signInputs)(signingTxB, paymentKey);
  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a transfer transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to transfer
 * @param {String} destinationAddress - the address to receive the name.
 *    this address will receive a dust UTXO
 * @param {String | TransactionSigner} ownerKeyIn - a hex string of
 *    the current owner's private key (or a TransactionSigner object)
 * @param {String | TransactionSigner} paymentKeyIn - a hex string of
 *    the private key used to fund the transaction (or a
 *    TransactionSigner object)
 * @param {Boolean} keepZonefile - if true, then preserve the name's zone file
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *   indicating whether the function should attempt to return an unsigned (or not fully signed)
 *   transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, keepZonefile = false, buildIncomplete = false) {
  const network = _config.config.network;
  const paymentKey = getTransactionSigner(paymentKeyIn);
  const ownerKey = getTransactionSigner(ownerKeyIn);
  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {
    const txPromise = network.getConsensusHash().then(consensusHash => (0, _skeletons.makeTransferSkeleton)(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile)).then(transferTX => {
      const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(transferTX, network.layer1);

      txB.setVersion(1);
      return txB;
    });
    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
      return (0, _utils.signInputs)(signingTxB, paymentKey, [{
        index: ownerInput.index,
        signer: ownerKey
      }]);
    });
  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a revoke transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to revoke
 * @param {String | TransactionSigner} ownerKeyIn - a hex string of
 *    the current owner's private key (or a TransactionSigner object)
 * @param {String | TransactionSigner} paymentKeyIn - a hex string of
 *    the private key used to fund the transaction (or a
 *    TransactionSigner object)
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *    indicating whether the function should attempt to return an unsigned (or not fully signed)
 *    transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const paymentKey = getTransactionSigner(paymentKeyIn);
  const ownerKey = getTransactionSigner(ownerKeyIn);
  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {
    const revokeTX = (0, _skeletons.makeRevokeSkeleton)(fullyQualifiedName);

    const txPromise = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(revokeTX, network.layer1);

    txPromise.setVersion(1);
    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);
      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
      return (0, _utils.signInputs)(signingTxB, paymentKey, [{
        index: ownerInput.index,
        signer: ownerKey
      }]);
    });
  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a renewal transaction for a domain name.
 * @param {String} fullyQualifiedName - the name to transfer
 * @param {String} destinationAddress - the address to receive the name after renewal
 *    this address will receive a dust UTXO
 * @param {String | TransactionSigner} ownerKeyIn - a hex string of
 *    the current owner's private key (or a TransactionSigner object)
 * @param {String | TransactionSigner} paymentKeyIn - a hex string of
 *    the private key used to fund the renewal (or a TransactionSigner
 *    object)
 * @param {String} zonefile - the zonefile data to include, if given (this will be hashed
 *    to include in the transaction), the zonefile itself must be published
 *    after the RENEWAL propagates.
 * @param {String} valueHash - the raw zone file hash to include (this will be used
 *    instead of zonefile, if given).
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *    indicating whether the function should attempt to return an unsigned (or not fully signed)
 *    transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {
  const network = _config.config.network;

  if (!valueHash && !!zonefile) {
    valueHash = (0, _utils.hash160)(Buffer.from(zonefile)).toString('hex');
  }

  const namespace = fullyQualifiedName.split('.').pop();
  const paymentKey = getTransactionSigner(paymentKeyIn);
  const ownerKey = getTransactionSigner(ownerKeyIn);
  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {
    const txPromise = Promise.all([network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(([namePrice, burnAddress]) => (0, _skeletons.makeRenewalSkeleton)(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash)).then(tx => {
      const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(tx, network.layer1);

      txB.setVersion(1);
      return txB;
    });
    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {
      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);
      const ownerOutput = txB.__tx.outs[2];

      const ownerOutputAddr = _bitcoinjsLib.default.address.fromOutputScript(ownerOutput.script, network.layer1);

      if (ownerOutputAddr !== ownerAddress) {
        return Promise.reject(new Error(`Original owner ${ownerAddress} should have an output at ` + `index 2 in transaction was ${ownerOutputAddr}`));
      }

      ownerOutput.value = ownerInput.value;
      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);
      return (0, _utils.signInputs)(signingTxB, paymentKey, [{
        index: ownerInput.index,
        signer: ownerKey
      }]);
    });
  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a namespace preorder transaction for a namespace
 * @param {String} namespaceID - the namespace to pre-order
 * @param {String} revealAddress - the address to receive the namespace (this
 *    must be passed as the 'revealAddress' in the namespace-reveal transaction)
 * @param {String | TransactionSigner} paymentKeyIn - a hex string of
 *    the private key used to fund the transaction (or a
 *    TransactionSigner object)
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *    indicating whether the function should attempt to return an unsigned (or not fully signed)
 *    transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *    this function *does not* perform the requisite safety checks -- please see
 *    the safety module for those.
 * @private
 */


function makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const paymentKey = getTransactionSigner(paymentKeyIn);
  return paymentKey.getAddress().then(preorderAddress => {
    const preorderPromise = Promise.all([network.getConsensusHash(), network.getNamespacePrice(namespaceID)]).then(([consensusHash, namespacePrice]) => (0, _skeletons.makeNamespacePreorderSkeleton)(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice));
    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(([utxos, feeRate, preorderSkeleton]) => {
      const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);

      txB.setVersion(1);
      const changeIndex = 1; // preorder skeleton always creates a change output at index = 1

      const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);
      return (0, _utils.signInputs)(signingTxB, paymentKey);
    }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
  });
}
/**
 * Generates a namespace reveal transaction for a namespace
 * @param {BlockstackNamespace} namespace - the namespace to reveal
 * @param {String} revealAddress - the address to receive the namespace (this
 *   must be passed as the 'revealAddress' in the namespace-reveal transaction)
 * @param {String | TransactionSigner} paymentKeyIn - a hex string (or
 *   a TransactionSigner object) of the private key used to fund the
 *   transaction
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *   indicating whether the function should attempt to return an unsigned (or not fully signed)
 *   transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *   this function *does not* perform the requisite safety checks -- please see
 *   the safety module for those.
 * @private
 */


function makeNamespaceReveal(namespace, revealAddress, paymentKeyIn, buildIncomplete = false) {
  const network = _config.config.network;

  if (!namespace.check()) {
    return Promise.reject(new Error('Invalid namespace'));
  }

  const namespaceRevealTX = (0, _skeletons.makeNamespaceRevealSkeleton)(namespace, revealAddress);
  const paymentKey = getTransactionSigner(paymentKeyIn);
  return paymentKey.getAddress().then(preorderAddress => Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {
    const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(namespaceRevealTX, network.layer1);

    txB.setVersion(1);
    const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);
    return (0, _utils.signInputs)(signingTxB, paymentKey);
  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a namespace ready transaction for a namespace
 * @param {String} namespaceID - the namespace to launch
 * @param {String | TransactionSigner} revealKeyIn - the private key
 *  of the 'revealAddress' used to reveal the namespace
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *  indicating whether the function should attempt to return an unsigned (or not fully signed)
 *  transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 *  this function *does not* perform the requisite safety checks -- please see
 *  the safety module for those.
 * @private
 */


function makeNamespaceReady(namespaceID, revealKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const namespaceReadyTX = (0, _skeletons.makeNamespaceReadySkeleton)(namespaceID);
  const revealKey = getTransactionSigner(revealKeyIn);
  return revealKey.getAddress().then(revealAddress => Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {
    const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);

    txB.setVersion(1);
    const signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);
    return (0, _utils.signInputs)(signingTxB, revealKey);
  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a name import transaction for a namespace
 * @param {String} name - the name to import
 * @param {String} recipientAddr - the address to receive the name
 * @param {String} zonefileHash - the hash of the zonefile to give this name
 * @param {String | TransactionSigner} importerKeyIn - the private key
 * that pays for the import
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 * indicating whether the function should attempt to return an unsigned (or not fully signed)
 * transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 * this function does not perform the requisite safety checks -- please see
 * the safety module for those.
 * @private
 */


function makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const nameImportTX = (0, _skeletons.makeNameImportSkeleton)(name, recipientAddr, zonefileHash);
  const importerKey = getTransactionSigner(importerKeyIn);
  return importerKey.getAddress().then(importerAddress => Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {
    const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);

    const signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);
    return (0, _utils.signInputs)(signingTxB, importerKey);
  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates an announce transaction
 * @param {String} messageHash - the hash of the message to send.  Should be
 *  an already-announced zone file hash
 * @param {String | TransactionSigner} senderKeyIn - the private key
 *  that pays for the transaction.  Should be the key that owns the
 *  name that the message recipients subscribe to
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 * indicating whether the function should attempt to return an unsigned (or not fully signed)
 * transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 * this function does not perform the requisite safety checks -- please see the
 * safety module for those.
 * @private
 */


function makeAnnounce(messageHash, senderKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const announceTX = (0, _skeletons.makeAnnounceSkeleton)(messageHash);
  const senderKey = getTransactionSigner(senderKeyIn);
  return senderKey.getAddress().then(senderAddress => Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {
    const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(announceTX, network.layer1);

    const signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);
    return (0, _utils.signInputs)(signingTxB, senderKey);
  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a token-transfer transaction
 * @param {String} recipientAddress - the address to receive the tokens
 * @param {String} tokenType - the type of tokens to send
 * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of
 *  tokens to send
 * @param {String} scratchArea - an arbitrary string to include with the transaction
 * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send
 *   the tokens
 * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund
 *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to
 *   fund with sender key.
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 *   indicating whether the function should attempt to return an unsigned (or not fully signed)
 *   transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 * This function does not perform the requisite safety checks -- please see the
 * safety module for those.
 * @private
 */


function makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn, buildIncomplete = false) {
  const network = _config.config.network;
  const separateFunder = !!btcFunderKeyIn;
  const senderKey = getTransactionSigner(senderKeyIn);
  const btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;
  const txPromise = network.getConsensusHash().then(consensusHash => (0, _skeletons.makeTokenTransferSkeleton)(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea));
  return Promise.all([senderKey.getAddress(), btcKey.getAddress()]).then(([senderAddress, btcAddress]) => {
    const btcUTXOsPromise = separateFunder ? network.getUTXOs(btcAddress) : Promise.resolve([]);
    const networkPromises = [network.getUTXOs(senderAddress), btcUTXOsPromise, network.getFeeRate(), txPromise];
    return Promise.all(networkPromises).then(([senderUTXOs, btcUTXOs, feeRate, tokenTransferTX]) => {
      const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);

      if (separateFunder) {
        const payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);
        const signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);
        return (0, _utils.signInputs)(signingTxB, btcKey, [{
          index: payerInput.index,
          signer: senderKey
        }]);
      } else {
        const signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);
        return (0, _utils.signInputs)(signingTxB, senderKey);
      }
    });
  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}
/**
 * Generates a bitcoin spend to a specified address. This will fund up to `amount`
 *   of satoshis from the payer's UTXOs. It will generate a change output if and only
 *   if the amount of leftover change is *greater* than the additional fees associated
 *   with the extra output. If the requested amount is not enough to fund the transaction's
 *   associated fees, then this will reject with a InvalidAmountError
 *
 * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated
 *   with their own input will not be included.
 *
 * If you specify an amount > the total balance of the payer address, then this will
 *   generate a maximum spend transaction
 *
 * @param {String} destinationAddress - the address to receive the bitcoin payment
 * @param {String | TransactionSigner} paymentKeyIn - the private key
 *    used to fund the bitcoin spend
 * @param {number} amount - the amount in satoshis for the payment address to
 *    spend in this transaction
 * @param {boolean} buildIncomplete - optional boolean, defaults to false,
 * indicating whether the function should attempt to return an unsigned (or not fully signed)
 * transaction. Useful for passing around a TX for multi-sig input signing.
 * @returns {Promise} - a promise which resolves to the hex-encoded transaction.
 * @private
 */


function makeBitcoinSpend(destinationAddress, paymentKeyIn, amount, buildIncomplete = false) {
  if (amount <= 0) {
    return Promise.reject(new _errors.InvalidParameterError('amount', 'amount must be greater than zero'));
  }

  const network = _config.config.network;
  const paymentKey = getTransactionSigner(paymentKeyIn);
  return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {
    const txB = new _bitcoinjsLib.default.TransactionBuilder(network.layer1);
    txB.setVersion(1);
    const destinationIndex = txB.addOutput(destinationAddress, 0); // will add utxos up to _amount_ and return the amount of leftover _change_

    let change;

    try {
      change = (0, _utils.addUTXOsToFund)(txB, utxos, amount, feeRate, false);
    } catch (err) {
      if (err.name === 'NotEnoughFundsError') {
        // actual amount funded = amount requested - remainder
        amount -= err.leftToFund;
        change = 0;
      } else {
        throw err;
      }
    }

    let feesToPay = feeRate * (0, _utils.estimateTXBytes)(txB, 0, 0);
    const feeForChange = feeRate * (0, _utils.estimateTXBytes)(txB, 0, 1) - feesToPay; // it's worthwhile to add a change output

    if (change > feeForChange) {
      feesToPay += feeForChange;
      txB.addOutput(paymentAddress, change);
    } // now let's compute how much output is leftover once we pay the fees.


    const outputAmount = amount - feesToPay;

    if (outputAmount < _utils.DUST_MINIMUM) {
      throw new _errors.InvalidAmountError(feesToPay, amount);
    } // we need to manually set the output values now


    txB.__tx.outs[destinationIndex].value = outputAmount; // ready to sign.

    return (0, _utils.signInputs)(txB, paymentKey);
  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));
}

const transactions = {
  makeRenewal,
  makeUpdate,
  makePreorder,
  makeRegister,
  makeTransfer,
  makeRevoke,
  makeNamespacePreorder,
  makeNamespaceReveal,
  makeNamespaceReady,
  makeBitcoinSpend,
  makeNameImport,
  makeAnnounce,
  makeTokenTransfer,
  BlockstackNamespace: _skeletons.BlockstackNamespace,
  estimatePreorder,
  estimateRegister,
  estimateTransfer,
  estimateUpdate,
  estimateRenewal,
  estimateRevoke,
  estimateNamespacePreorder,
  estimateNamespaceReveal,
  estimateNamespaceReady,
  estimateNameImport,
  estimateAnnounce,
  estimateTokenTransfer
};
exports.transactions = transactions;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9vcGVyYXRpb25zL3R4YnVpbGQuanMiXSwibmFtZXMiOlsiZHVtbXlDb25zZW5zdXNIYXNoIiwiZHVtbXlab25lZmlsZUhhc2giLCJhZGRPd25lcklucHV0IiwidXR4b3MiLCJvd25lckFkZHJlc3MiLCJ0eEIiLCJhZGRDaGFuZ2VPdXQiLCJsZW5ndGgiLCJFcnJvciIsInNvcnQiLCJhIiwiYiIsInZhbHVlIiwib3duZXJVVFhPIiwib3duZXJJbnB1dCIsImFkZElucHV0IiwidHhfaGFzaCIsInR4X291dHB1dF9uIiwiYWRkT3V0cHV0IiwiaW5kZXgiLCJmdW5kVHJhbnNhY3Rpb24iLCJwYXltZW50QWRkcmVzcyIsImZlZVJhdGUiLCJpbkFtb3VudHMiLCJjaGFuZ2VJbmRleCIsIkRVU1RfTUlOSU1VTSIsInR4RmVlIiwib3V0QW1vdW50cyIsImNoYW5nZSIsIl9fdHgiLCJvdXRzIiwicmV0dXJuVHJhbnNhY3Rpb25IZXgiLCJidWlsZEluY29tcGxldGUiLCJ0b0hleCIsImJ1aWxkIiwiZ2V0VHJhbnNhY3Rpb25TaWduZXIiLCJpbnB1dCIsIlB1YmtleUhhc2hTaWduZXIiLCJmcm9tSGV4U3RyaW5nIiwiZXN0aW1hdGVQcmVvcmRlciIsImZ1bGx5UXVhbGlmaWVkTmFtZSIsImRlc3RpbmF0aW9uQWRkcmVzcyIsInBheW1lbnRVdHhvcyIsIm5ldHdvcmsiLCJjb25maWciLCJwcmVvcmRlclByb21pc2UiLCJnZXROYW1lUHJpY2UiLCJ0aGVuIiwibmFtZVByaWNlIiwiZ2V0RGVmYXVsdEJ1cm5BZGRyZXNzIiwiUHJvbWlzZSIsImFsbCIsImdldEZlZVJhdGUiLCJwcmVvcmRlclRYIiwib3V0cHV0c1ZhbHVlIiwiZXN0aW1hdGVSZWdpc3RlciIsInJlZ2lzdGVyQWRkcmVzcyIsImluY2x1ZGluZ1pvbmVmaWxlIiwidmFsdWVIYXNoIiwicmVnaXN0ZXJUWCIsImVzdGltYXRlVXBkYXRlIiwidXBkYXRlVFgiLCJlc3RpbWF0ZVRyYW5zZmVyIiwidHJhbnNmZXJUWCIsImVzdGltYXRlUmVuZXdhbCIsInJlbmV3YWxQcm9taXNlIiwicmVuZXdhbFRYIiwiZXN0aW1hdGVSZXZva2UiLCJyZXZva2VUWCIsImVzdGltYXRlTmFtZXNwYWNlUHJlb3JkZXIiLCJuYW1lc3BhY2VJRCIsInJldmVhbEFkZHJlc3MiLCJnZXROYW1lc3BhY2VQcmljZSIsIm5hbWVzcGFjZVByaWNlIiwiZXN0aW1hdGVOYW1lc3BhY2VSZXZlYWwiLCJuYW1lc3BhY2UiLCJyZXZlYWxUWCIsImVzdGltYXRlTmFtZXNwYWNlUmVhZHkiLCJyZXZlYWxVdHhvcyIsInJlYWR5VFgiLCJlc3RpbWF0ZU5hbWVJbXBvcnQiLCJuYW1lIiwicmVjaXBpZW50QWRkciIsInpvbmVmaWxlSGFzaCIsImltcG9ydFV0eG9zIiwiaW1wb3J0VFgiLCJlc3RpbWF0ZUFubm91bmNlIiwibWVzc2FnZUhhc2giLCJzZW5kZXJVdHhvcyIsImFubm91bmNlVFgiLCJlc3RpbWF0ZVRva2VuVHJhbnNmZXIiLCJyZWNpcGllbnRBZGRyZXNzIiwidG9rZW5UeXBlIiwidG9rZW5BbW91bnQiLCJzY3JhdGNoQXJlYSIsImFkZGl0aW9uYWxPdXRwdXRzIiwidG9rZW5UcmFuc2ZlclRYIiwibWFrZVByZW9yZGVyIiwicGF5bWVudEtleUluIiwic3BsaXQiLCJwb3AiLCJwYXltZW50S2V5IiwiZ2V0QWRkcmVzcyIsInByZW9yZGVyQWRkcmVzcyIsImdldENvbnNlbnN1c0hhc2giLCJnZXROYW1lc3BhY2VCdXJuQWRkcmVzcyIsImNvbnNlbnN1c0hhc2giLCJidXJuQWRkcmVzcyIsImdldFVUWE9zIiwicHJlb3JkZXJTa2VsZXRvbiIsImJpdGNvaW5qcyIsIlRyYW5zYWN0aW9uQnVpbGRlciIsImZyb21UcmFuc2FjdGlvbiIsImxheWVyMSIsInNldFZlcnNpb24iLCJzaWduaW5nVHhCIiwibWFrZVVwZGF0ZSIsIm93bmVyS2V5SW4iLCJ6b25lZmlsZSIsInJlamVjdCIsIkJ1ZmZlciIsImZyb20iLCJ0b1N0cmluZyIsIm93bmVyS2V5IiwidHhQcm9taXNlIiwicGF5ZXJVdHhvcyIsIm93bmVyVXR4b3MiLCJzaWduZXIiLCJtYWtlUmVnaXN0ZXIiLCJyZWdpc3RlclNrZWxldG9uIiwibWFrZVRyYW5zZmVyIiwia2VlcFpvbmVmaWxlIiwibWFrZVJldm9rZSIsIm1ha2VSZW5ld2FsIiwidHgiLCJvd25lck91dHB1dCIsIm93bmVyT3V0cHV0QWRkciIsImFkZHJlc3MiLCJmcm9tT3V0cHV0U2NyaXB0Iiwic2NyaXB0IiwibWFrZU5hbWVzcGFjZVByZW9yZGVyIiwibWFrZU5hbWVzcGFjZVJldmVhbCIsImNoZWNrIiwibmFtZXNwYWNlUmV2ZWFsVFgiLCJtYWtlTmFtZXNwYWNlUmVhZHkiLCJyZXZlYWxLZXlJbiIsIm5hbWVzcGFjZVJlYWR5VFgiLCJyZXZlYWxLZXkiLCJtYWtlTmFtZUltcG9ydCIsImltcG9ydGVyS2V5SW4iLCJuYW1lSW1wb3J0VFgiLCJpbXBvcnRlcktleSIsImltcG9ydGVyQWRkcmVzcyIsIm1ha2VBbm5vdW5jZSIsInNlbmRlcktleUluIiwic2VuZGVyS2V5Iiwic2VuZGVyQWRkcmVzcyIsIm1ha2VUb2tlblRyYW5zZmVyIiwiYnRjRnVuZGVyS2V5SW4iLCJzZXBhcmF0ZUZ1bmRlciIsImJ0Y0tleSIsImJ0Y0FkZHJlc3MiLCJidGNVVFhPc1Byb21pc2UiLCJyZXNvbHZlIiwibmV0d29ya1Byb21pc2VzIiwic2VuZGVyVVRYT3MiLCJidGNVVFhPcyIsInBheWVySW5wdXQiLCJtYWtlQml0Y29pblNwZW5kIiwiYW1vdW50IiwiSW52YWxpZFBhcmFtZXRlckVycm9yIiwiZGVzdGluYXRpb25JbmRleCIsImVyciIsImxlZnRUb0Z1bmQiLCJmZWVzVG9QYXkiLCJmZWVGb3JDaGFuZ2UiLCJvdXRwdXRBbW91bnQiLCJJbnZhbGlkQW1vdW50RXJyb3IiLCJ0cmFuc2FjdGlvbnMiLCJCbG9ja3N0YWNrTmFtZXNwYWNlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUVBOztBQUNBOztBQUVBOztBQUlBOztBQVNBOztBQUNB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QUEsWUFIMEI7QUFJMUIrQixFQUFBQSxZQUowQjtBQUsxQkUsRUFBQUEsWUFMMEI7QUFNMUJFLEVBQUFBLFVBTjBCO0FBTzFCUSxFQUFBQSxxQkFQMEI7QUFRMUJDLEVBQUFBLG1CQVIwQjtBQVMxQkcsRUFBQUEsa0JBVDBCO0FBVTFCd0IsRUFBQUEsZ0JBVjBCO0FBVzFCcEIsRUFBQUEsY0FYMEI7QUFZMUJLLEVBQUFBLFlBWjBCO0FBYTFCSSxFQUFBQSxpQkFiMEI7QUFjMUJzQixFQUFBQSxtQkFBbUIsRUFBbkJBLDhCQWQwQjtBQWUxQjVJLEVBQUFBLGdCQWYwQjtBQWdCMUJnQixFQUFBQSxnQkFoQjBCO0FBaUIxQk8sRUFBQUEsZ0JBakIwQjtBQWtCMUJGLEVBQUFBLGNBbEIwQjtBQW1CMUJJLEVBQUFBLGVBbkIwQjtBQW9CMUJHLEVBQUFBLGNBcEIwQjtBQXFCMUJFLEVBQUFBLHlCQXJCMEI7QUFzQjFCSyxFQUFBQSx1QkF0QjBCO0FBdUIxQkcsRUFBQUEsc0JBdkIwQjtBQXdCMUJHLEVBQUFBLGtCQXhCMEI7QUF5QjFCTSxFQUFBQSxnQkF6QjBCO0FBMEIxQkksRUFBQUE7QUExQjBCLENBQXJCIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cblxuaW1wb3J0IGJpdGNvaW5qcyBmcm9tICdiaXRjb2luanMtbGliJ1xuaW1wb3J0IEJpZ0ludGVnZXIgZnJvbSAnYmlnaSdcblxuaW1wb3J0IHtcbiAgYWRkVVRYT3NUb0Z1bmQsIERVU1RfTUlOSU1VTSxcbiAgZXN0aW1hdGVUWEJ5dGVzLCBzdW1PdXRwdXRWYWx1ZXMsIGhhc2gxNjAsIHNpZ25JbnB1dHNcbn0gZnJvbSAnLi91dGlscydcbmltcG9ydCB7XG4gIG1ha2VQcmVvcmRlclNrZWxldG9uLCBtYWtlUmVnaXN0ZXJTa2VsZXRvbixcbiAgbWFrZVVwZGF0ZVNrZWxldG9uLCBtYWtlVHJhbnNmZXJTa2VsZXRvbiwgbWFrZVJlbmV3YWxTa2VsZXRvbixcbiAgbWFrZVJldm9rZVNrZWxldG9uLCBtYWtlTmFtZXNwYWNlUHJlb3JkZXJTa2VsZXRvbixcbiAgbWFrZU5hbWVzcGFjZVJldmVhbFNrZWxldG9uLCBtYWtlTmFtZXNwYWNlUmVhZHlTa2VsZXRvbixcbiAgbWFrZU5hbWVJbXBvcnRTa2VsZXRvbiwgbWFrZUFubm91bmNlU2tlbGV0b24sXG4gIG1ha2VUb2tlblRyYW5zZmVyU2tlbGV0b24sIEJsb2Nrc3RhY2tOYW1lc3BhY2Vcbn0gZnJvbSAnLi9za2VsZXRvbnMnXG5cbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gJy4uL2NvbmZpZydcbmltcG9ydCB7IEludmFsaWRBbW91bnRFcnJvciwgSW52YWxpZFBhcmFtZXRlckVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJ1xuaW1wb3J0IHsgVHJhbnNhY3Rpb25TaWduZXIsIFB1YmtleUhhc2hTaWduZXIgfSBmcm9tICcuL3NpZ25lcnMnXG5cbmNvbnN0IGR1bW15Q29uc2Vuc3VzSGFzaCA9ICdhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYSdcbmNvbnN0IGR1bW15Wm9uZWZpbGVIYXNoICA9ICdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJ1xuXG5mdW5jdGlvbiBhZGRPd25lcklucHV0KHV0eG9zOiBPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgIG93bmVyQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICB0eEI6IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgIGFkZENoYW5nZU91dDogYm9vbGVhbiA9IHRydWVcbikge1xuICAvLyBhZGQgYW4gb3duZXIgVVRYTyBhbmQgYSBjaGFuZ2Ugb3V0LlxuICBpZiAodXR4b3MubGVuZ3RoIDw9IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ093bmVyIGhhcyBubyBVVFhPcyBmb3IgVVBEQVRFLicpXG4gIH1cblxuICB1dHhvcy5zb3J0KChhLCBiKSA9PiBhLnZhbHVlIC0gYi52YWx1ZSlcbiAgY29uc3Qgb3duZXJVVFhPID0gdXR4b3NbMF1cbiAgY29uc3Qgb3duZXJJbnB1dCA9IHR4Qi5hZGRJbnB1dChvd25lclVUWE8udHhfaGFzaCwgb3duZXJVVFhPLnR4X291dHB1dF9uKVxuICBpZiAoYWRkQ2hhbmdlT3V0KSB7XG4gICAgdHhCLmFkZE91dHB1dChvd25lckFkZHJlc3MsIG93bmVyVVRYTy52YWx1ZSlcbiAgfVxuICByZXR1cm4geyBpbmRleDogb3duZXJJbnB1dCwgdmFsdWU6IG93bmVyVVRYTy52YWx1ZSB9XG59XG5cbmZ1bmN0aW9uIGZ1bmRUcmFuc2FjdGlvbih0eEI6IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIsIHBheW1lbnRBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgdXR4b3M6IEFycmF5PHt2YWx1ZTogbnVtYmVyLCB0eF9oYXNoOiBzdHJpbmcsIHR4X291dHB1dF9uOiBudW1iZXJ9PixcbiAgICAgICAgICAgICAgICAgICAgICAgICBmZWVSYXRlOiBudW1iZXIsIGluQW1vdW50czogbnVtYmVyLCBjaGFuZ2VJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGxcbikge1xuICAvLyBjaGFuZ2UgaW5kZXggZm9yIHRoZSBwYXllci5cbiAgaWYgKGNoYW5nZUluZGV4ID09PSBudWxsKSB7XG4gICAgY2hhbmdlSW5kZXggPSB0eEIuYWRkT3V0cHV0KHBheW1lbnRBZGRyZXNzLCBEVVNUX01JTklNVU0pXG4gIH1cbiAgLy8gZnVuZCB0aGUgdHJhbnNhY3Rpb24gZmVlLlxuICBjb25zdCB0eEZlZSA9IGVzdGltYXRlVFhCeXRlcyh0eEIsIDAsIDApICogZmVlUmF0ZVxuICBjb25zdCBvdXRBbW91bnRzID0gc3VtT3V0cHV0VmFsdWVzKHR4QilcbiAgY29uc3QgY2hhbmdlID0gYWRkVVRYT3NUb0Z1bmQodHhCLCB1dHhvcywgdHhGZWUgKyBvdXRBbW91bnRzIC0gaW5BbW91bnRzLCBmZWVSYXRlKVxuICB0eEIuX190eC5vdXRzW2NoYW5nZUluZGV4XS52YWx1ZSArPSBjaGFuZ2VcbiAgcmV0dXJuIHR4QlxufVxuXG5mdW5jdGlvbiByZXR1cm5UcmFuc2FjdGlvbkhleCh0eEI6IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZEluY29tcGxldGU/OiBib29sZWFuID0gZmFsc2Vcbikge1xuICBpZiAoYnVpbGRJbmNvbXBsZXRlKSB7XG4gICAgcmV0dXJuIHR4Qi5idWlsZEluY29tcGxldGUoKS50b0hleCgpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHR4Qi5idWlsZCgpLnRvSGV4KClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblNpZ25lcihpbnB1dDogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIpOiBUcmFuc2FjdGlvblNpZ25lciB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFB1YmtleUhhc2hTaWduZXIuZnJvbUhleFN0cmluZyhpbnB1dClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaW5wdXRcbiAgfVxufVxuXG4vKipcbiAqIEVzdGltYXRlcyBjb3N0IG9mIGEgcHJlb3JkZXIgdHJhbnNhY3Rpb24gZm9yIGEgZG9tYWluIG5hbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZnVsbHlRdWFsaWZpZWROYW1lIC0gdGhlIG5hbWUgdG8gcHJlb3JkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0aW5hdGlvbkFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBuYW1lICh0aGlzXG4gKiAgICBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgJ3JlZ2lzdHJhdGlvbkFkZHJlc3MnIGluIHRoZSByZWdpc3RlciB0cmFuc2FjdGlvbilcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXltZW50QWRkcmVzcyAtIHRoZSBhZGRyZXNzIGZ1bmRpbmcgdGhlIHByZW9yZGVyXG4gKiBAcGFyYW0ge051bWJlcn0gcGF5bWVudFV0eG9zIC0gdGhlIG51bWJlciBvZiBVVFhPcyB3ZSBleHBlY3Qgd2lsbCBiZSByZXF1aXJlZFxuICogICAgZnJvbSB0aGUgcGF5bWVudCBhZGRyZXNzLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBzYXRvc2hpIGNvc3QgdG8gZnVuZFxuICogICAgdGhlIHByZW9yZGVyLiBUaGlzIGluY2x1ZGVzIGEgNTUwMCBzYXRvc2hpIGR1c3Qgb3V0cHV0IGZvciB0aGUgcHJlb3JkZXIuXG4gKiAgICBFdmVuIHRob3VnaCB0aGlzIGlzIGEgY2hhbmdlIG91dHB1dCwgdGhlIHBheWVyIG11c3Qgc3VwcGx5IGVub3VnaCBmdW5kc1xuICogICAgdG8gZ2VuZXJhdGUgdGhpcyBvdXRwdXQsIHNvIHdlIGluY2x1ZGUgaXQgaW4gdGhlIGNvc3QuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZVByZW9yZGVyKGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bWVudFV0eG9zOiBudW1iZXIgPSAxXG4pIDogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG4gIGNvbnN0IHByZW9yZGVyUHJvbWlzZSA9IG5ldHdvcmsuZ2V0TmFtZVByaWNlKGZ1bGx5UXVhbGlmaWVkTmFtZSlcbiAgICAudGhlbihuYW1lUHJpY2UgPT4gbWFrZVByZW9yZGVyU2tlbGV0b24oXG4gICAgICBmdWxseVF1YWxpZmllZE5hbWUsIGR1bW15Q29uc2Vuc3VzSGFzaCwgcGF5bWVudEFkZHJlc3MsXG4gICAgICBuZXR3b3JrLmdldERlZmF1bHRCdXJuQWRkcmVzcygpLCBuYW1lUHJpY2UsXG4gICAgICBkZXN0aW5hdGlvbkFkZHJlc3NcbiAgICApKVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChbbmV0d29yay5nZXRGZWVSYXRlKCksIHByZW9yZGVyUHJvbWlzZV0pXG4gICAgLnRoZW4oKFtmZWVSYXRlLCBwcmVvcmRlclRYXSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0c1ZhbHVlID0gc3VtT3V0cHV0VmFsdWVzKHByZW9yZGVyVFgpXG4gICAgICBjb25zdCB0eEZlZSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXMocHJlb3JkZXJUWCwgcGF5bWVudFV0eG9zLCAwKVxuICAgICAgcmV0dXJuIHR4RmVlICsgb3V0cHV0c1ZhbHVlXG4gICAgfSlcbn1cblxuLyoqXG4gKiBFc3RpbWF0ZXMgY29zdCBvZiBhIHJlZ2lzdGVyIHRyYW5zYWN0aW9uIGZvciBhIGRvbWFpbiBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSAtIHRoZSBuYW1lIHRvIHJlZ2lzdGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVnaXN0ZXJBZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHBheW1lbnRBZGRyZXNzIC0gdGhlIGFkZHJlc3MgZnVuZGluZyB0aGUgcmVnaXN0ZXJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5jbHVkaW5nWm9uZWZpbGUgLSB3aGV0aGVyIG9yIG5vdCB3ZSB3aWxsIGJyb2FkY2FzdFxuICogICAgYSB6b25lZmlsZSBoYXNoIGFzIHBhcnQgIG9mIHRoZSByZWdpc3RlclxuICogQHBhcmFtIHtOdW1iZXJ9IHBheW1lbnRVdHhvcyAtIHRoZSBudW1iZXIgb2YgVVRYT3Mgd2UgZXhwZWN0IHdpbGwgYmUgcmVxdWlyZWRcbiAqICAgIGZyb20gdGhlIHBheW1lbnQgYWRkcmVzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgc2F0b3NoaSBjb3N0IHRvIGZ1bmRcbiAqICAgIHRoZSByZWdpc3Rlci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlUmVnaXN0ZXIoZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50QWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRpbmdab25lZmlsZTogYm9vbGVhbiA9IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50VXR4b3M6IG51bWJlciA9IDFcbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBsZXQgdmFsdWVIYXNoXG4gIGlmIChpbmNsdWRpbmdab25lZmlsZSkge1xuICAgIHZhbHVlSGFzaCA9IGR1bW15Wm9uZWZpbGVIYXNoXG4gIH1cblxuICBjb25zdCByZWdpc3RlclRYID0gbWFrZVJlZ2lzdGVyU2tlbGV0b24oXG4gICAgZnVsbHlRdWFsaWZpZWROYW1lLCByZWdpc3RlckFkZHJlc3MsIHZhbHVlSGFzaFxuICApXG5cbiAgcmV0dXJuIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXG4gICAgLnRoZW4oKGZlZVJhdGUpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dHNWYWx1ZSA9IHN1bU91dHB1dFZhbHVlcyhyZWdpc3RlclRYKVxuICAgICAgLy8gMSBhZGRpdGlvbmFsIG91dHB1dCBmb3IgcGF5ZXIgY2hhbmdlXG4gICAgICBjb25zdCB0eEZlZSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXMocmVnaXN0ZXJUWCwgcGF5bWVudFV0eG9zLCAxKVxuICAgICAgcmV0dXJuIHR4RmVlICsgb3V0cHV0c1ZhbHVlXG4gICAgfSlcbn1cblxuLyoqXG4gKiBFc3RpbWF0ZXMgY29zdCBvZiBhbiB1cGRhdGUgdHJhbnNhY3Rpb24gZm9yIGEgZG9tYWluIG5hbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZnVsbHlRdWFsaWZpZWROYW1lIC0gdGhlIG5hbWUgdG8gdXBkYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gb3duZXJBZGRyZXNzIC0gdGhlIG93bmVyIG9mIHRoZSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF5bWVudEFkZHJlc3MgLSB0aGUgYWRkcmVzcyBmdW5kaW5nIHRoZSB1cGRhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXltZW50VXR4b3MgLSB0aGUgbnVtYmVyIG9mIFVUWE9zIHdlIGV4cGVjdCB3aWxsIGJlIHJlcXVpcmVkXG4gKiAgICBmcm9tIHRoZSBwYXltZW50IGFkZHJlc3MuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHNhdG9zaGkgY29zdCB0byBmdW5kXG4gKiAgICB0aGUgdXBkYXRlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXN0aW1hdGVVcGRhdGUoZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvd25lckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50VXR4b3M6IG51bWJlciA9IDFcbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBjb25zdCB1cGRhdGVUWCA9IG1ha2VVcGRhdGVTa2VsZXRvbihcbiAgICBmdWxseVF1YWxpZmllZE5hbWUsIGR1bW15Q29uc2Vuc3VzSGFzaCwgZHVtbXlab25lZmlsZUhhc2hcbiAgKVxuXG4gIHJldHVybiBuZXR3b3JrLmdldEZlZVJhdGUoKVxuICAgIC50aGVuKChmZWVSYXRlKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRzVmFsdWUgPSBzdW1PdXRwdXRWYWx1ZXModXBkYXRlVFgpXG4gICAgICAvLyAxIGFkZGl0aW9uYWwgaW5wdXQgZm9yIHRoZSBvd25lclxuICAgICAgLy8gMiBhZGRpdGlvbmFsIG91dHB1dHMgZm9yIG93bmVyIC8gcGF5ZXIgY2hhbmdlXG4gICAgICBjb25zdCB0eEZlZSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXModXBkYXRlVFgsIDEgKyBwYXltZW50VXR4b3MsIDIpXG4gICAgICByZXR1cm4gdHhGZWUgKyBvdXRwdXRzVmFsdWVcbiAgICB9KVxufVxuXG4vKipcbiAqIEVzdGltYXRlcyBjb3N0IG9mIGFuIHRyYW5zZmVyIHRyYW5zYWN0aW9uIGZvciBhIGRvbWFpbiBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSAtIHRoZSBuYW1lIHRvIHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdGluYXRpb25BZGRyZXNzIC0gdGhlIG5leHQgb3duZXIgb2YgdGhlIG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBvd25lckFkZHJlc3MgLSB0aGUgY3VycmVudCBvd25lciBvZiB0aGUgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IHBheW1lbnRBZGRyZXNzIC0gdGhlIGFkZHJlc3MgZnVuZGluZyB0aGUgdHJhbnNmZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXltZW50VXR4b3MgLSB0aGUgbnVtYmVyIG9mIFVUWE9zIHdlIGV4cGVjdCB3aWxsIGJlIHJlcXVpcmVkXG4gKiAgICBmcm9tIHRoZSBwYXltZW50IGFkZHJlc3MuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHNhdG9zaGkgY29zdCB0byBmdW5kXG4gKiAgICB0aGUgdHJhbnNmZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZVRyYW5zZmVyKGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRVdHhvczogbnVtYmVyID0gMVxuKSA6IFByb21pc2U8bnVtYmVyPiB7XG4gIGNvbnN0IG5ldHdvcmsgPSBjb25maWcubmV0d29ya1xuXG4gIGNvbnN0IHRyYW5zZmVyVFggPSBtYWtlVHJhbnNmZXJTa2VsZXRvbihmdWxseVF1YWxpZmllZE5hbWUsIGR1bW15Q29uc2Vuc3VzSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQWRkcmVzcylcblxuICByZXR1cm4gbmV0d29yay5nZXRGZWVSYXRlKClcbiAgICAudGhlbigoZmVlUmF0ZSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0c1ZhbHVlID0gc3VtT3V0cHV0VmFsdWVzKHRyYW5zZmVyVFgpXG4gICAgICAvLyAxIGFkZGl0aW9uYWwgaW5wdXQgZm9yIHRoZSBvd25lclxuICAgICAgLy8gMiBhZGRpdGlvbmFsIG91dHB1dHMgZm9yIG93bmVyIC8gcGF5ZXIgY2hhbmdlXG4gICAgICBjb25zdCB0eEZlZSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXModHJhbnNmZXJUWCwgMSArIHBheW1lbnRVdHhvcywgMilcbiAgICAgIHJldHVybiB0eEZlZSArIG91dHB1dHNWYWx1ZVxuICAgIH0pXG59XG5cbi8qKlxuICogRXN0aW1hdGVzIGNvc3Qgb2YgYW4gdHJhbnNmZXIgdHJhbnNhY3Rpb24gZm9yIGEgZG9tYWluIG5hbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZnVsbHlRdWFsaWZpZWROYW1lIC0gdGhlIG5hbWUgdG8gcmVuZXdcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0aW5hdGlvbkFkZHJlc3MgLSB0aGUgbmV4dCBvd25lciBvZiB0aGUgbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG93bmVyQWRkcmVzcyAtIHRoZSBjdXJyZW50IG93bmVyIG9mIHRoZSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF5bWVudEFkZHJlc3MgLSB0aGUgYWRkcmVzcyBmdW5kaW5nIHRoZSB0cmFuc2ZlclxuICogQHBhcmFtIHtCb29sZWFufSBpbmNsdWRpbmdab25lZmlsZSAtIHdoZXRoZXIgb3Igbm90IHdlIHdpbGwgYnJvYWRjYXN0IGEgem9uZWZpbGUgaGFzaFxuICAgICAgaW4gdGhlIHJlbmV3YWwgb3BlcmF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gcGF5bWVudFV0eG9zIC0gdGhlIG51bWJlciBvZiBVVFhPcyB3ZSBleHBlY3Qgd2lsbCBiZSByZXF1aXJlZFxuICogICAgZnJvbSB0aGUgcGF5bWVudCBhZGRyZXNzLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBzYXRvc2hpIGNvc3QgdG8gZnVuZFxuICogICAgdGhlIHRyYW5zZmVyLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXN0aW1hdGVSZW5ld2FsKGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVkaW5nWm9uZWZpbGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50VXR4b3M6IG51bWJlciA9IDFcbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBsZXQgdmFsdWVIYXNoXG4gIGlmIChpbmNsdWRpbmdab25lZmlsZSkge1xuICAgIHZhbHVlSGFzaCA9IGR1bW15Wm9uZWZpbGVIYXNoXG4gIH1cblxuICBjb25zdCByZW5ld2FsUHJvbWlzZSA9IG5ldHdvcmsuZ2V0TmFtZVByaWNlKGZ1bGx5UXVhbGlmaWVkTmFtZSlcbiAgICAudGhlbihuYW1lUHJpY2UgPT4gbWFrZVJlbmV3YWxTa2VsZXRvbihcbiAgICAgIGZ1bGx5UXVhbGlmaWVkTmFtZSwgZGVzdGluYXRpb25BZGRyZXNzLCBvd25lckFkZHJlc3MsXG4gICAgICBuZXR3b3JrLmdldERlZmF1bHRCdXJuQWRkcmVzcygpLCBuYW1lUHJpY2UsIHZhbHVlSGFzaFxuICAgICkpXG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtuZXR3b3JrLmdldEZlZVJhdGUoKSwgcmVuZXdhbFByb21pc2VdKVxuICAgIC50aGVuKChbZmVlUmF0ZSwgcmVuZXdhbFRYXSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0c1ZhbHVlID0gc3VtT3V0cHV0VmFsdWVzKHJlbmV3YWxUWClcbiAgICAgIC8vIDEgYWRkaXRpb25hbCBpbnB1dCBmb3IgdGhlIG93bmVyXG4gICAgICAvLyBhbmQgcmVuZXdhbCBza2VsZXRvbiBpbmNsdWRlcyBhbGwgb3V0cHV0cyBmb3Igb3duZXIgY2hhbmdlLCBidXQgbm90IGZvciBwYXllciBjaGFuZ2UuXG4gICAgICBjb25zdCB0eEZlZSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXMocmVuZXdhbFRYLCAxICsgcGF5bWVudFV0eG9zLCAxKVxuICAgICAgcmV0dXJuIHR4RmVlICsgb3V0cHV0c1ZhbHVlIC0gNTUwMCAvLyBkb24ndCBjb3VudCB0aGUgZHVzdCBjaGFuZ2UgZm9yIG9sZCBvd25lci5cbiAgICB9KVxufVxuXG4vKipcbiAqIEVzdGltYXRlcyBjb3N0IG9mIGEgcmV2b2tlIHRyYW5zYWN0aW9uIGZvciBhIGRvbWFpbiBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSAtIHRoZSBuYW1lIHRvIHJldm9rZVxuICogQHBhcmFtIHtTdHJpbmd9IG93bmVyQWRkcmVzcyAtIHRoZSBjdXJyZW50IG93bmVyIG9mIHRoZSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF5bWVudEFkZHJlc3MgIHRoZSBhZGRyZXNzIGZ1bmRpbmcgdGhlIHJldm9rZVxuICogQHBhcmFtIHtOdW1iZXJ9IHBheW1lbnRVdHhvcyAtIHRoZSBudW1iZXIgb2YgVVRYT3Mgd2UgZXhwZWN0IHdpbGwgYmUgcmVxdWlyZWRcbiAqICAgIGZyb20gdGhlIHBheW1lbnQgYWRkcmVzcy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgc2F0b3NoaSBjb3N0IHRvIGZ1bmQgdGhlXG4gKiAgICByZXZva2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZVJldm9rZShmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG93bmVyQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRVdHhvczogbnVtYmVyID0gMVxuKSA6IFByb21pc2U8bnVtYmVyPiAge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcbiAgY29uc3QgcmV2b2tlVFggPSBtYWtlUmV2b2tlU2tlbGV0b24oZnVsbHlRdWFsaWZpZWROYW1lKVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChbbmV0d29yay5nZXRGZWVSYXRlKCldKVxuICAgIC50aGVuKChbZmVlUmF0ZV0pID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dHNWYWx1ZSA9IHN1bU91dHB1dFZhbHVlcyhyZXZva2VUWClcbiAgICAgIC8vIDEgYWRkaXRpb25hbCBpbnB1dCBmb3Igb3duZXJcbiAgICAgIC8vIDEgYWRkaXRpb25hbCBvdXRwdXQgZm9yIHBheWVyIGNoYW5nZVxuICAgICAgY29uc3QgdHhGZWUgPSBmZWVSYXRlICogZXN0aW1hdGVUWEJ5dGVzKHJldm9rZVRYLCAxICsgcGF5bWVudFV0eG9zLCAyKVxuICAgICAgcmV0dXJuIHR4RmVlICsgb3V0cHV0c1ZhbHVlXG4gICAgfSlcbn1cblxuLyoqXG4gKiBFc3RpbWF0ZXMgY29zdCBvZiBhIG5hbWVzcGFjZSBwcmVvcmRlciB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VJRCAtIHRoZSBuYW1lc3BhY2UgdG8gcHJlb3JkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXZlYWxBZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgbmFtZXNwYWNlICh0aGlzXG4gKiAgICBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgJ3JldmVhbEFkZHJlc3MnIGluIHRoZSBuYW1lc3BhY2UtcmV2ZWFsIHRyYW5zYWN0aW9uKVxuICogQHBhcmFtIHtTdHJpbmd9IHBheW1lbnRBZGRyZXNzIC0gdGhlIGFkZHJlc3MgZnVuZGluZyB0aGUgcHJlb3JkZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBwYXltZW50VXR4b3MgLSB0aGUgbnVtYmVyIG9mIFVUWE9zIHdlIGV4cGVjdCB3aWxsIGJlIHJlcXVpcmVkXG4gKiAgICBmcm9tIHRoZSBwYXltZW50IGFkZHJlc3MuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHNhdG9zaGkgY29zdCB0byBmdW5kXG4gKiAgICB0aGUgcHJlb3JkZXIuIFRoaXMgaW5jbHVkZXMgYSA1NTAwIHNhdG9zaGkgZHVzdCBvdXRwdXQgZm9yIHRoZSBwcmVvcmRlci5cbiAqICAgIEV2ZW4gdGhvdWdoIHRoaXMgaXMgYSBjaGFuZ2Ugb3V0cHV0LCB0aGUgcGF5ZXIgbXVzdCBzdXBwbHkgZW5vdWdoIGZ1bmRzXG4gKiAgICB0byBnZW5lcmF0ZSB0aGlzIG91dHB1dCwgc28gd2UgaW5jbHVkZSBpdCBpbiB0aGUgY29zdC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlTmFtZXNwYWNlUHJlb3JkZXIobmFtZXNwYWNlSUQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZWFsQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50QWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50VXR4b3M6IG51bWJlciA9IDFcbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBjb25zdCBwcmVvcmRlclByb21pc2UgPSBuZXR3b3JrLmdldE5hbWVzcGFjZVByaWNlKG5hbWVzcGFjZUlEKVxuICAgIC50aGVuKG5hbWVzcGFjZVByaWNlID0+IG1ha2VOYW1lc3BhY2VQcmVvcmRlclNrZWxldG9uKFxuICAgICAgbmFtZXNwYWNlSUQsIGR1bW15Q29uc2Vuc3VzSGFzaCwgcGF5bWVudEFkZHJlc3MsIHJldmVhbEFkZHJlc3MsXG4gICAgICBuYW1lc3BhY2VQcmljZVxuICAgICkpXG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtuZXR3b3JrLmdldEZlZVJhdGUoKSwgcHJlb3JkZXJQcm9taXNlXSlcbiAgICAudGhlbigoW2ZlZVJhdGUsIHByZW9yZGVyVFhdKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRzVmFsdWUgPSBzdW1PdXRwdXRWYWx1ZXMocHJlb3JkZXJUWClcbiAgICAgIGNvbnN0IHR4RmVlID0gZmVlUmF0ZSAqIGVzdGltYXRlVFhCeXRlcyhwcmVvcmRlclRYLCBwYXltZW50VXR4b3MsIDApXG4gICAgICByZXR1cm4gdHhGZWUgKyBvdXRwdXRzVmFsdWVcbiAgICB9KVxufVxuXG4vKipcbiAqIEVzdGltYXRlcyBjb3N0IG9mIGEgbmFtZXNhcGNlIHJldmVhbCB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7QmxvY2tzdGFja05hbWVzcGFjZX0gbmFtZXNwYWNlIC0gdGhlIG5hbWVzcGFjZSB0byByZXZlYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXZlYWxBZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgbmFtZXNwYWNlXG4gKiAgICAodGhpcyBtdXN0IGhhdmUgYmVlbiBwYXNzZWQgYXMgJ3JldmVhbEFkZHJlc3MnIHRvIGEgcHJpb3IgbmFtZXNwYWNlXG4gKiAgICBwcmVvcmRlcilcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXltZW50QWRkcmVzcyAtIHRoZSBhZGRyZXNzIHRoYXQgcGF5cyBmb3IgdGhpcyB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHBheW1lbnRVdHhvcyAtIHRoZSBudW1iZXIgb2YgVVRYT3Mgd2UgZXhwZWN0IHdpbGwgYmUgcmVxdWlyZWRcbiAqICAgIGZyb20gdGhlIHBheW1lbnQgYWRkcmVzc1xuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBzYXRvc2hpIGNvc3QgdG9cbiAqICAgIGZ1bmQgdGhlIHJldmVhbC4gIFRoaXMgaW5jbHVkZXMgYSA1NTAwIHNhdG9zaGkgZHVzdCBvdXRwdXQgZm9yIHRoZVxuICogICAgcHJlb3JkZXIuICBFdmVuIHRob3VnaCB0aGlzIGlzIGEgY2hhbmdlIG91dHB1dCwgdGhlIHBheWVyIG11c3QgaGF2ZVxuICogICAgZW5vdWdoIGZ1bmRzIHRvIGdlbmVyYXRlIHRoaXMgb3V0cHV0LCBzbyB3ZSBpbmNsdWRlIGl0IGluIHRoZSBjb3N0LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXN0aW1hdGVOYW1lc3BhY2VSZXZlYWwobmFtZXNwYWNlOiBCbG9ja3N0YWNrTmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZWFsQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRVdHhvczogbnVtYmVyID0gMVxuKSA6IFByb21pc2U8bnVtYmVyPiB7XG4gIGNvbnN0IG5ldHdvcmsgPSBjb25maWcubmV0d29ya1xuICBjb25zdCByZXZlYWxUWCA9IG1ha2VOYW1lc3BhY2VSZXZlYWxTa2VsZXRvbihuYW1lc3BhY2UsIHJldmVhbEFkZHJlc3MpXG5cbiAgcmV0dXJuIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXG4gICAgLnRoZW4oKGZlZVJhdGUpID0+IHtcbiAgICAgIGNvbnN0IG91dHB1dHNWYWx1ZSA9IHN1bU91dHB1dFZhbHVlcyhyZXZlYWxUWClcbiAgICAgIC8vIDEgYWRkaXRpb25hbCBvdXRwdXQgZm9yIHBheWVyIGNoYW5nZVxuICAgICAgY29uc3QgdHhGZWUgPSBmZWVSYXRlICogZXN0aW1hdGVUWEJ5dGVzKHJldmVhbFRYLCBwYXltZW50VXR4b3MsIDEpXG4gICAgICByZXR1cm4gdHhGZWUgKyBvdXRwdXRzVmFsdWVcbiAgICB9KVxufVxuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgY29zdCBvZiBhIG5hbWVzcGFjZS1yZWFkeSB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VJRCAtIHRoZSBuYW1lc3BhY2UgdG8gcmVhZHlcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXZlYWxVdHhvcyAtIHRoZSBudW1iZXIgb2YgVVRYT3Mgd2UgZXhwZWN0IHdpbGxcbiAqICBiZSByZXF1aXJlZCBmcm9tIHRoZSByZXZlYWwgYWRkcmVzc1xuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBzYXRvc2hpIGNvc3QgdG9cbiAqICBmdW5kIHRoaXMgbmFtZXNwYWNleS1yZWFkeSB0cmFuc2FjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVzdGltYXRlTmFtZXNwYWNlUmVhZHkobmFtZXNwYWNlSUQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV2ZWFsVXR4b3M6IG51bWJlciA9IDFcbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcbiAgY29uc3QgcmVhZHlUWCA9IG1ha2VOYW1lc3BhY2VSZWFkeVNrZWxldG9uKG5hbWVzcGFjZUlEKVxuXG4gIHJldHVybiBuZXR3b3JrLmdldEZlZVJhdGUoKVxuICAgIC50aGVuKChmZWVSYXRlKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRzVmFsdWUgPSBzdW1PdXRwdXRWYWx1ZXMocmVhZHlUWClcbiAgICAgIGNvbnN0IHR4RmVlID0gZmVlUmF0ZSAqIGVzdGltYXRlVFhCeXRlcyhyZWFkeVRYLCByZXZlYWxVdHhvcywgMSlcbiAgICAgIHJldHVybiB0eEZlZSArIG91dHB1dHNWYWx1ZVxuICAgIH0pXG59XG5cbi8qKlxuICogRXN0aW1hdGVzIHRoZSBjb3N0IG9mIGEgbmFtZS1pbXBvcnQgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVjaXBpZW50QWRkciAtIHRoZSByZWNpcGllbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSB6b25lZmlsZUhhc2ggLSB0aGUgem9uZSBmaWxlIGhhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSBpbXBvcnRVdHhvcyAtIHRoZSBudW1iZXIgb2YgVVRYT3Mgd2UgZXhwZWN0IHdpbGxcbiAqICBiZSByZXF1aXJlZCBmcm9tIHRoZSBpbXBvcnRlciBhZGRyZXNzXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHNhdG9zaGkgY29zdFxuICogIHRvIGZ1bmQgdGhpcyBuYW1lLWltcG9ydCB0cmFuc2FjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXN0aW1hdGVOYW1lSW1wb3J0KG5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNpcGllbnRBZGRyOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9uZWZpbGVIYXNoOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1wb3J0VXR4b3M6IG51bWJlciA9IDFcbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcbiAgY29uc3QgaW1wb3J0VFggPSBtYWtlTmFtZUltcG9ydFNrZWxldG9uKG5hbWUsIHJlY2lwaWVudEFkZHIsIHpvbmVmaWxlSGFzaClcblxuICByZXR1cm4gbmV0d29yay5nZXRGZWVSYXRlKClcbiAgICAudGhlbigoZmVlUmF0ZSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0c1ZhbHVlID0gc3VtT3V0cHV0VmFsdWVzKGltcG9ydFRYKVxuICAgICAgY29uc3QgdHhGZWUgPSBmZWVSYXRlICogZXN0aW1hdGVUWEJ5dGVzKGltcG9ydFRYLCBpbXBvcnRVdHhvcywgMSlcbiAgICAgIHJldHVybiB0eEZlZSArIG91dHB1dHNWYWx1ZVxuICAgIH0pXG59XG5cbi8qKlxuICogRXN0aW1hdGVzIHRoZSBjb3N0IG9mIGFuIGFubm91bmNlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZUhhc2ggLSB0aGUgaGFzaCBvZiB0aGUgbWVzc2FnZVxuICogQHBhcmFtIHtOdW1iZXJ9IHNlbmRlclV0eG9zIC0gdGhlIG51bWJlciBvZiB1dHhvcyB3ZSBleHBlY3Qgd2lsbFxuICogIGJlIHJlcXVpcmVkIGZyb20gdGhlIGltcG9ydGVyIGFkZHJlc3NcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgc2F0b3NoaSBjb3N0XG4gKiAgdG8gZnVuZCB0aGlzIGFubm91bmNlIHRyYW5zYWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZUFubm91bmNlKG1lc3NhZ2VIYXNoOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlclV0eG9zOiBudW1iZXIgPSAxXG4pIDogUHJvbWlzZTxudW1iZXI+IHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG4gIGNvbnN0IGFubm91bmNlVFggPSBtYWtlQW5ub3VuY2VTa2VsZXRvbihtZXNzYWdlSGFzaClcblxuICByZXR1cm4gbmV0d29yay5nZXRGZWVSYXRlKClcbiAgICAudGhlbigoZmVlUmF0ZSkgPT4ge1xuICAgICAgY29uc3Qgb3V0cHV0c1ZhbHVlID0gc3VtT3V0cHV0VmFsdWVzKGFubm91bmNlVFgpXG4gICAgICBjb25zdCB0eEZlZSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXMoYW5ub3VuY2VUWCwgc2VuZGVyVXR4b3MsIDEpXG4gICAgICByZXR1cm4gdHhGZWUgKyBvdXRwdXRzVmFsdWVcbiAgICB9KVxufVxuXG4vKipcbiAqIEVzdGltYXRlcyB0aGUgY29zdCBvZiBhIHRva2VuLXRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVjaXBpZW50QWRkcmVzcyAtIHRoZSByZWNpcGllbnQgb2YgdGhlIHRva2Vuc1xuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuVHlwZSAtIHRoZSB0eXBlIG9mIHRva2VuIHRvIHNwZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gdG9rZW5BbW91bnQgLSBhIDY0LWJpdCB1bnNpZ25lZCBCaWdJbnRlZ2VyIGVuY29kaW5nIHRoZSBudW1iZXIgb2YgdG9rZW5zXG4gKiAgIHRvIHNwZW5kXG4gKiBAcGFyYW0ge1N0cmluZ30gc2NyYXRjaEFyZWEgLSBhbiBhcmJpdHJhcnkgc3RyaW5nIHRvIHN0b3JlIHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gc2VuZGVyVXR4b3MgLSB0aGUgbnVtYmVyIG9mIHV0eG9zIHdlIGV4cGVjdCB3aWxsXG4gKiAgYmUgcmVxdWlyZWQgZnJvbSB0aGUgaW1wb3J0ZXIgYWRkcmVzc1xuICogQHBhcmFtIHtOdW1iZXJ9IGFkZGl0aW9uYWxPdXRwdXRzIC0gdGhlIG51bWJlciBvZiBvdXRwdXRzIHdlIGV4cGVjdCB0byBhZGQgYmV5b25kXG4gKiAganVzdCB0aGUgcmVjaXBpZW50IG91dHB1dCAoZGVmYXVsdCA9IDEsIGlmIHRoZSB0b2tlbiBvd25lciBpcyBhbHNvIHRoZSBiaXRjb2luIGZ1bmRlcilcbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgc2F0b3NoaSBjb3N0IHRvXG4gKiAgZnVuZCB0aGlzIHRva2VuLXRyYW5zZmVyIHRyYW5zYWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlc3RpbWF0ZVRva2VuVHJhbnNmZXIocmVjaXBpZW50QWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuQW1vdW50OiBCaWdJbnRlZ2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcmF0Y2hBcmVhOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyVXR4b3M6IG51bWJlciA9IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbE91dHB1dHM6IG51bWJlciA9IDFcbikge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcbiAgY29uc3QgdG9rZW5UcmFuc2ZlclRYID0gbWFrZVRva2VuVHJhbnNmZXJTa2VsZXRvbihcbiAgICByZWNpcGllbnRBZGRyZXNzLCBkdW1teUNvbnNlbnN1c0hhc2gsIHRva2VuVHlwZSwgdG9rZW5BbW91bnQsIHNjcmF0Y2hBcmVhKVxuXG4gIHJldHVybiBuZXR3b3JrLmdldEZlZVJhdGUoKVxuICAgIC50aGVuKChmZWVSYXRlKSA9PiB7XG4gICAgICBjb25zdCBvdXRwdXRzVmFsdWUgPSBzdW1PdXRwdXRWYWx1ZXModG9rZW5UcmFuc2ZlclRYKVxuICAgICAgY29uc3QgdHhGZWUgPSBmZWVSYXRlICogZXN0aW1hdGVUWEJ5dGVzKHRva2VuVHJhbnNmZXJUWCwgc2VuZGVyVXR4b3MsIGFkZGl0aW9uYWxPdXRwdXRzKVxuICAgICAgcmV0dXJuIHR4RmVlICsgb3V0cHV0c1ZhbHVlXG4gICAgfSlcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwcmVvcmRlciB0cmFuc2FjdGlvbiBmb3IgYSBkb21haW4gbmFtZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmdWxseVF1YWxpZmllZE5hbWUgLSB0aGUgbmFtZSB0byBwcmUtb3JkZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXN0aW5hdGlvbkFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBuYW1lICh0aGlzXG4gKiAgICBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgJ3JlZ2lzdHJhdGlvbkFkZHJlc3MnIGluIHRoZSByZWdpc3RlciB0cmFuc2FjdGlvbilcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IHBheW1lbnRLZXlJbiAtIGEgaGV4IHN0cmluZyBvZlxuICogICAgdGhlIHByaXZhdGUga2V5IHVzZWQgdG8gZnVuZCB0aGUgdHJhbnNhY3Rpb24gb3IgYSB0cmFuc2FjdGlvbiBzaWduZXIgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJ1aWxkSW5jb21wbGV0ZSAtIG9wdGlvbmFsIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLFxuICogaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBzaG91bGQgYXR0ZW1wdCB0byByZXR1cm4gYW4gdW5zaWduZWQgKG9yIG5vdCBmdWxseSBzaWduZWQpXG4gKiB0cmFuc2FjdGlvbi4gVXNlZnVsIGZvciBwYXNzaW5nIGFyb3VuZCBhIFRYIGZvciBtdWx0aS1zaWcgaW5wdXQgc2lnbmluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaGV4LWVuY29kZWQgdHJhbnNhY3Rpb24uXG4gKiAgICB0aGlzIGZ1bmN0aW9uICpkb2VzIG5vdCogcGVyZm9ybSB0aGUgcmVxdWlzaXRlIHNhZmV0eSBjaGVja3MgLS0gcGxlYXNlIHNlZVxuICogICAgdGhlIHNhZmV0eSBtb2R1bGUgZm9yIHRob3NlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVByZW9yZGVyKGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgIHBheW1lbnRLZXlJbjogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIsXG4gICAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG5cbiAgY29uc3QgbmFtZXNwYWNlID0gZnVsbHlRdWFsaWZpZWROYW1lLnNwbGl0KCcuJykucG9wKClcblxuICBjb25zdCBwYXltZW50S2V5ID0gZ2V0VHJhbnNhY3Rpb25TaWduZXIocGF5bWVudEtleUluKVxuXG4gIHJldHVybiBwYXltZW50S2V5LmdldEFkZHJlc3MoKS50aGVuKChwcmVvcmRlckFkZHJlc3MpID0+IHtcbiAgICBjb25zdCBwcmVvcmRlclByb21pc2UgPSBQcm9taXNlLmFsbChbbmV0d29yay5nZXRDb25zZW5zdXNIYXNoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsuZ2V0TmFtZVByaWNlKGZ1bGx5UXVhbGlmaWVkTmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsuZ2V0TmFtZXNwYWNlQnVybkFkZHJlc3MobmFtZXNwYWNlKV0pXG4gICAgICAudGhlbigoW2NvbnNlbnN1c0hhc2gsIG5hbWVQcmljZSwgYnVybkFkZHJlc3NdKSA9PiBtYWtlUHJlb3JkZXJTa2VsZXRvbihcbiAgICAgICAgZnVsbHlRdWFsaWZpZWROYW1lLCBjb25zZW5zdXNIYXNoLCBwcmVvcmRlckFkZHJlc3MsIGJ1cm5BZGRyZXNzLFxuICAgICAgICBuYW1lUHJpY2UsIGRlc3RpbmF0aW9uQWRkcmVzc1xuICAgICAgKSlcblxuICAgIHJldHVybiBQcm9taXNlLmFsbChbbmV0d29yay5nZXRVVFhPcyhwcmVvcmRlckFkZHJlc3MpLCBuZXR3b3JrLmdldEZlZVJhdGUoKSwgcHJlb3JkZXJQcm9taXNlXSlcbiAgICAgIC50aGVuKChbdXR4b3MsIGZlZVJhdGUsIHByZW9yZGVyU2tlbGV0b25dKSA9PiB7XG4gICAgICAgIGNvbnN0IHR4QiA9IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHByZW9yZGVyU2tlbGV0b24sIG5ldHdvcmsubGF5ZXIxKVxuICAgICAgICB0eEIuc2V0VmVyc2lvbigxKVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gMSAvLyBwcmVvcmRlciBza2VsZXRvbiBhbHdheXMgY3JlYXRlcyBhIGNoYW5nZSBvdXRwdXQgYXQgaW5kZXggPSAxXG4gICAgICAgIGNvbnN0IHNpZ25pbmdUeEIgPSBmdW5kVHJhbnNhY3Rpb24odHhCLCBwcmVvcmRlckFkZHJlc3MsIHV0eG9zLCBmZWVSYXRlLCAwLCBjaGFuZ2VJbmRleClcblxuICAgICAgICByZXR1cm4gc2lnbklucHV0cyhzaWduaW5nVHhCLCBwYXltZW50S2V5KVxuICAgICAgfSlcbiAgICAgIC50aGVuKHNpZ25pbmdUeEIgPT4gcmV0dXJuVHJhbnNhY3Rpb25IZXgoc2lnbmluZ1R4QiwgYnVpbGRJbmNvbXBsZXRlKSlcbiAgfSlcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gdXBkYXRlIHRyYW5zYWN0aW9uIGZvciBhIGRvbWFpbiBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSAtIHRoZSBuYW1lIHRvIHVwZGF0ZVxuICogQHBhcmFtIHtTdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcn0gb3duZXJLZXlJbiAtIGEgaGV4IHN0cmluZyBvZiB0aGVcbiAqICAgIG93bmVyIGtleSwgb3IgYSB0cmFuc2FjdGlvbiBzaWduZXIgb2JqZWN0LiBUaGlzIHdpbGwgcHJvdmlkZSBvbmVcbiAqICAgIFVUWE8gaW5wdXQsIGFuZCBhbHNvIHJlY2lldmUgYSBkdXN0IG91dHB1dC5cbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IHBheW1lbnRLZXlJbiAtIGEgaGV4IHN0cmluZywgb3IgYVxuICogICAgdHJhbnNhY3Rpb24gc2lnbmVyIG9iamVjdCwgb2YgdGhlIHByaXZhdGUga2V5IHVzZWQgdG8gZnVuZCB0aGVcbiAqICAgIHRyYW5zYWN0aW9uJ3MgdHhmZWVzXG4gKiBAcGFyYW0ge1N0cmluZ30gem9uZWZpbGUgLSB0aGUgem9uZWZpbGUgZGF0YSB0byB1cGRhdGUgKHRoaXMgd2lsbCBiZSBoYXNoZWRcbiAqICAgIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9uKSwgdGhlIHpvbmVmaWxlIGl0c2VsZiBtdXN0IGJlIHB1Ymxpc2hlZFxuICogICAgYWZ0ZXIgdGhlIFVQREFURSBwcm9wYWdhdGVzLlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlSGFzaCAtIGlmIGdpdmVuLCB0aGlzIGlzIHRoZSBoYXNoIHRvIHN0b3JlIChpbnN0ZWFkIG9mXG4gKiAgICB6b25lZmlsZSkuICB6b25lZmlsZSB3aWxsIGJlIGlnbm9yZWQgaWYgdGhpcyBpcyBnaXZlbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnVpbGRJbmNvbXBsZXRlIC0gb3B0aW9uYWwgYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UsXG4gKiAgICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGZ1bmN0aW9uIHNob3VsZCBhdHRlbXB0IHRvIHJldHVybiBhbiB1bnNpZ25lZCAob3Igbm90IGZ1bGx5IHNpZ25lZClcbiAqICAgIHRyYW5zYWN0aW9uLiBVc2VmdWwgZm9yIHBhc3NpbmcgYXJvdW5kIGEgVFggZm9yIG11bHRpLXNpZyBpbnB1dCBzaWduaW5nLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBoZXgtZW5jb2RlZCB0cmFuc2FjdGlvbi5cbiAqICAgIHRoaXMgZnVuY3Rpb24gKmRvZXMgbm90KiBwZXJmb3JtIHRoZSByZXF1aXNpdGUgc2FmZXR5IGNoZWNrcyAtLSBwbGVhc2Ugc2VlXG4gKiAgICB0aGUgc2FmZXR5IG1vZHVsZSBmb3IgdGhvc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVXBkYXRlKGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBvd25lcktleUluOiBzdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgcGF5bWVudEtleUluOiBzdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgem9uZWZpbGU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVIYXNoOiBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG4gIGlmICghdmFsdWVIYXNoICYmICF6b25lZmlsZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgIG5ldyBFcnJvcignTmVlZCB6b25lZmlsZSBvciB2YWx1ZUhhc2ggYXJndW1lbnRzJylcbiAgICApXG4gIH1cbiAgaWYgKHZhbHVlSGFzaC5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoIXpvbmVmaWxlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXG4gICAgICAgIG5ldyBFcnJvcignTmVlZCB6b25lZmlsZSBvciB2YWx1ZUhhc2ggYXJndW1lbnRzJylcbiAgICAgIClcbiAgICB9XG4gICAgdmFsdWVIYXNoID0gaGFzaDE2MChCdWZmZXIuZnJvbSh6b25lZmlsZSkpLnRvU3RyaW5nKCdoZXgnKVxuICB9IGVsc2UgaWYgKHZhbHVlSGFzaC5sZW5ndGggIT09IDQwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlSGFzaCAke3ZhbHVlSGFzaH1gKVxuICAgIClcbiAgfVxuXG4gIGNvbnN0IHBheW1lbnRLZXkgPSBnZXRUcmFuc2FjdGlvblNpZ25lcihwYXltZW50S2V5SW4pXG4gIGNvbnN0IG93bmVyS2V5ID0gZ2V0VHJhbnNhY3Rpb25TaWduZXIob3duZXJLZXlJbilcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW293bmVyS2V5LmdldEFkZHJlc3MoKSwgcGF5bWVudEtleS5nZXRBZGRyZXNzKCldKVxuICAgIC50aGVuKChbb3duZXJBZGRyZXNzLCBwYXltZW50QWRkcmVzc10pID0+IHtcbiAgICAgIGNvbnN0IHR4UHJvbWlzZSA9IG5ldHdvcmsuZ2V0Q29uc2Vuc3VzSGFzaCgpXG4gICAgICAgIC50aGVuKGNvbnNlbnN1c0hhc2ggPT4gbWFrZVVwZGF0ZVNrZWxldG9uKGZ1bGx5UXVhbGlmaWVkTmFtZSwgY29uc2Vuc3VzSGFzaCwgdmFsdWVIYXNoKSlcbiAgICAgICAgLnRoZW4oKHVwZGF0ZVRYKSA9PiB7XG4gICAgICAgICAgY29uc3QgdHhCID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24odXBkYXRlVFgsIG5ldHdvcmsubGF5ZXIxKVxuICAgICAgICAgIHR4Qi5zZXRWZXJzaW9uKDEpXG4gICAgICAgICAgcmV0dXJuIHR4QlxuICAgICAgICB9KVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3R4UHJvbWlzZSwgbmV0d29yay5nZXRVVFhPcyhwYXltZW50QWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsuZ2V0VVRYT3Mob3duZXJBZGRyZXNzKSwgbmV0d29yay5nZXRGZWVSYXRlKCldKVxuICAgICAgICAudGhlbigoW3R4QiwgcGF5ZXJVdHhvcywgb3duZXJVdHhvcywgZmVlUmF0ZV0pID0+IHtcbiAgICAgICAgICBjb25zdCBvd25lcklucHV0ID0gYWRkT3duZXJJbnB1dChvd25lclV0eG9zLCBvd25lckFkZHJlc3MsIHR4QilcbiAgICAgICAgICBjb25zdCBzaWduaW5nVHhCID0gZnVuZFRyYW5zYWN0aW9uKHR4QiwgcGF5bWVudEFkZHJlc3MsIHBheWVyVXR4b3MsIGZlZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcklucHV0LnZhbHVlKVxuXG4gICAgICAgICAgcmV0dXJuIHNpZ25JbnB1dHMoc2lnbmluZ1R4QiwgcGF5bWVudEtleSwgW3sgaW5kZXg6IG93bmVySW5wdXQuaW5kZXgsIHNpZ25lcjogb3duZXJLZXkgfV0pXG4gICAgICAgIH0pXG4gICAgfSlcbiAgICAudGhlbihzaWduaW5nVHhCID0+IHJldHVyblRyYW5zYWN0aW9uSGV4KHNpZ25pbmdUeEIsIGJ1aWxkSW5jb21wbGV0ZSkpXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmVnaXN0ZXIgdHJhbnNhY3Rpb24gZm9yIGEgZG9tYWluIG5hbWUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZnVsbHlRdWFsaWZpZWROYW1lIC0gdGhlIG5hbWUgdG8gcmVnaXN0ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWdpc3RlckFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byByZWNlaXZlIHRoZSBuYW1lICh0aGlzXG4gKiAgICBtdXN0IGhhdmUgYmVlbiBwYXNzZWQgYXMgdGhlICdkZXN0aW5hdGlvbkFkZHJlc3MnIGluIHRoZSBwcmVvcmRlciB0cmFuc2FjdGlvbilcbiAqICAgIHRoaXMgYWRkcmVzcyB3aWxsIHJlY2VpdmUgYSBkdXN0IFVUWE9cbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IHBheW1lbnRLZXlJbiAtIGEgaGV4IHN0cmluZyBvZlxuICogICAgdGhlIHByaXZhdGUga2V5IChvciBhIFRyYW5zYWN0aW9uU2lnbmVyIG9iamVjdCkgdXNlZCB0byBmdW5kIHRoZVxuICogICAgdHJhbnNhY3Rpb24gKHRoaXMgKm11c3QqIGJlIHRoZSBzYW1lIGFzIHRoZSBwYXltZW50IGFkZHJlc3MgdXNlZFxuICogICAgdG8gZnVuZCB0aGUgcHJlb3JkZXIpXG4gKiBAcGFyYW0ge1N0cmluZ30gem9uZWZpbGUgLSB0aGUgem9uZWZpbGUgZGF0YSB0byBpbmNsdWRlICh0aGlzIHdpbGwgYmUgaGFzaGVkXG4gKiAgICB0byBpbmNsdWRlIGluIHRoZSB0cmFuc2FjdGlvbiksIHRoZSB6b25lZmlsZSBpdHNlbGYgbXVzdCBiZSBwdWJsaXNoZWRcbiAqICAgIGFmdGVyIHRoZSBVUERBVEUgcHJvcGFnYXRlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZUhhc2ggLSB0aGUgaGFzaCBvZiB0aGUgem9uZSBmaWxlIGRhdGEgdG8gaW5jbHVkZS5cbiAqICAgIEl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHpvbmVmaWxlLCBpZiBnaXZlblxuICogQHBhcmFtIHtib29sZWFufSBidWlsZEluY29tcGxldGUgLSBvcHRpb25hbCBib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSxcbiAqICAgIGluZGljYXRpbmcgd2hldGhlciB0aGUgZnVuY3Rpb24gc2hvdWxkIGF0dGVtcHQgdG8gcmV0dXJuIGFuIHVuc2lnbmVkIChvciBub3QgZnVsbHkgc2lnbmVkKVxuICogICAgdHJhbnNhY3Rpb24uIFVzZWZ1bCBmb3IgcGFzc2luZyBhcm91bmQgYSBUWCBmb3IgbXVsdGktc2lnIGlucHV0IHNpZ25pbmcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGhleC1lbmNvZGVkIHRyYW5zYWN0aW9uLlxuICogICAgdGhpcyBmdW5jdGlvbiAqZG9lcyBub3QqIHBlcmZvcm0gdGhlIHJlcXVpc2l0ZSBzYWZldHkgY2hlY2tzIC0tIHBsZWFzZSBzZWVcbiAqICAgIHRoZSBzYWZldHkgbW9kdWxlIGZvciB0aG9zZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1ha2VSZWdpc3RlcihmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICBwYXltZW50S2V5SW46IHN0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgIHpvbmVmaWxlOiA/c3RyaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc2g6ID9zdHJpbmcgPSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkSW5jb21wbGV0ZT86IGJvb2xlYW4gPSBmYWxzZVxuKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBjb25maWcubmV0d29ya1xuICBpZiAoIXZhbHVlSGFzaCAmJiAhIXpvbmVmaWxlKSB7XG4gICAgdmFsdWVIYXNoID0gaGFzaDE2MChCdWZmZXIuZnJvbSh6b25lZmlsZSkpLnRvU3RyaW5nKCdoZXgnKVxuICB9IGVsc2UgaWYgKCEhdmFsdWVIYXNoICYmIHZhbHVlSGFzaC5sZW5ndGggIT09IDQwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgbmV3IEVycm9yKGBJbnZhbGlkIHpvbmVmaWxlIGhhc2ggJHt2YWx1ZUhhc2h9YClcbiAgICApXG4gIH1cblxuICBjb25zdCByZWdpc3RlclNrZWxldG9uID0gbWFrZVJlZ2lzdGVyU2tlbGV0b24oXG4gICAgZnVsbHlRdWFsaWZpZWROYW1lLCByZWdpc3RlckFkZHJlc3MsIHZhbHVlSGFzaFxuICApXG5cbiAgY29uc3QgdHhCID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24ocmVnaXN0ZXJTa2VsZXRvbiwgbmV0d29yay5sYXllcjEpXG4gIHR4Qi5zZXRWZXJzaW9uKDEpXG5cbiAgY29uc3QgcGF5bWVudEtleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKHBheW1lbnRLZXlJbilcblxuICByZXR1cm4gcGF5bWVudEtleS5nZXRBZGRyZXNzKCkudGhlbihcbiAgICBwYXltZW50QWRkcmVzcyA9PiBQcm9taXNlLmFsbChbbmV0d29yay5nZXRVVFhPcyhwYXltZW50QWRkcmVzcyksIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXSlcbiAgICAgIC50aGVuKChbdXR4b3MsIGZlZVJhdGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpZ25pbmdUeEIgPSBmdW5kVHJhbnNhY3Rpb24odHhCLCBwYXltZW50QWRkcmVzcywgdXR4b3MsIGZlZVJhdGUsIDApXG5cbiAgICAgICAgcmV0dXJuIHNpZ25JbnB1dHMoc2lnbmluZ1R4QiwgcGF5bWVudEtleSlcbiAgICAgIH0pXG4gIClcbiAgICAudGhlbihzaWduaW5nVHhCID0+IHJldHVyblRyYW5zYWN0aW9uSGV4KHNpZ25pbmdUeEIsIGJ1aWxkSW5jb21wbGV0ZSkpXG59XG5cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0cmFuc2ZlciB0cmFuc2FjdGlvbiBmb3IgYSBkb21haW4gbmFtZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBmdWxseVF1YWxpZmllZE5hbWUgLSB0aGUgbmFtZSB0byB0cmFuc2ZlclxuICogQHBhcmFtIHtTdHJpbmd9IGRlc3RpbmF0aW9uQWRkcmVzcyAtIHRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIG5hbWUuXG4gKiAgICB0aGlzIGFkZHJlc3Mgd2lsbCByZWNlaXZlIGEgZHVzdCBVVFhPXG4gKiBAcGFyYW0ge1N0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyfSBvd25lcktleUluIC0gYSBoZXggc3RyaW5nIG9mXG4gKiAgICB0aGUgY3VycmVudCBvd25lcidzIHByaXZhdGUga2V5IChvciBhIFRyYW5zYWN0aW9uU2lnbmVyIG9iamVjdClcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IHBheW1lbnRLZXlJbiAtIGEgaGV4IHN0cmluZyBvZlxuICogICAgdGhlIHByaXZhdGUga2V5IHVzZWQgdG8gZnVuZCB0aGUgdHJhbnNhY3Rpb24gKG9yIGFcbiAqICAgIFRyYW5zYWN0aW9uU2lnbmVyIG9iamVjdClcbiAqIEBwYXJhbSB7Qm9vbGVhbn0ga2VlcFpvbmVmaWxlIC0gaWYgdHJ1ZSwgdGhlbiBwcmVzZXJ2ZSB0aGUgbmFtZSdzIHpvbmUgZmlsZVxuICogQHBhcmFtIHtib29sZWFufSBidWlsZEluY29tcGxldGUgLSBvcHRpb25hbCBib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSxcbiAqICAgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBzaG91bGQgYXR0ZW1wdCB0byByZXR1cm4gYW4gdW5zaWduZWQgKG9yIG5vdCBmdWxseSBzaWduZWQpXG4gKiAgIHRyYW5zYWN0aW9uLiBVc2VmdWwgZm9yIHBhc3NpbmcgYXJvdW5kIGEgVFggZm9yIG11bHRpLXNpZyBpbnB1dCBzaWduaW5nLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBoZXgtZW5jb2RlZCB0cmFuc2FjdGlvbi5cbiAqICAgIHRoaXMgZnVuY3Rpb24gKmRvZXMgbm90KiBwZXJmb3JtIHRoZSByZXF1aXNpdGUgc2FmZXR5IGNoZWNrcyAtLSBwbGVhc2Ugc2VlXG4gKiAgICB0aGUgc2FmZXR5IG1vZHVsZSBmb3IgdGhvc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVHJhbnNmZXIoZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25BZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgb3duZXJLZXlJbjogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIsXG4gICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEtleUluOiBzdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgICBrZWVwWm9uZWZpbGU6IGJvb2xlYW4gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICBidWlsZEluY29tcGxldGU/OiBib29sZWFuID0gZmFsc2Vcbikge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBjb25zdCBwYXltZW50S2V5ID0gZ2V0VHJhbnNhY3Rpb25TaWduZXIocGF5bWVudEtleUluKVxuICBjb25zdCBvd25lcktleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKG93bmVyS2V5SW4pXG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtvd25lcktleS5nZXRBZGRyZXNzKCksIHBheW1lbnRLZXkuZ2V0QWRkcmVzcygpXSlcbiAgICAudGhlbigoW293bmVyQWRkcmVzcywgcGF5bWVudEFkZHJlc3NdKSA9PiB7XG4gICAgICBjb25zdCB0eFByb21pc2UgPSBuZXR3b3JrLmdldENvbnNlbnN1c0hhc2goKVxuICAgICAgICAudGhlbihjb25zZW5zdXNIYXNoID0+IG1ha2VUcmFuc2ZlclNrZWxldG9uKFxuICAgICAgICAgIGZ1bGx5UXVhbGlmaWVkTmFtZSwgY29uc2Vuc3VzSGFzaCwgZGVzdGluYXRpb25BZGRyZXNzLCBrZWVwWm9uZWZpbGVcbiAgICAgICAgKSlcbiAgICAgICAgLnRoZW4oKHRyYW5zZmVyVFgpID0+IHtcbiAgICAgICAgICBjb25zdCB0eEIgPSBiaXRjb2luanMuVHJhbnNhY3Rpb25CdWlsZGVyXG4gICAgICAgICAgICAuZnJvbVRyYW5zYWN0aW9uKHRyYW5zZmVyVFgsIG5ldHdvcmsubGF5ZXIxKVxuICAgICAgICAgIHR4Qi5zZXRWZXJzaW9uKDEpXG4gICAgICAgICAgcmV0dXJuIHR4QlxuICAgICAgICB9KVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW3R4UHJvbWlzZSwgbmV0d29yay5nZXRVVFhPcyhwYXltZW50QWRkcmVzcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsuZ2V0VVRYT3Mob3duZXJBZGRyZXNzKSwgbmV0d29yay5nZXRGZWVSYXRlKCldKVxuICAgICAgICAudGhlbigoW3R4QiwgcGF5ZXJVdHhvcywgb3duZXJVdHhvcywgZmVlUmF0ZV0pID0+IHtcbiAgICAgICAgICBjb25zdCBvd25lcklucHV0ID0gYWRkT3duZXJJbnB1dChvd25lclV0eG9zLCBvd25lckFkZHJlc3MsIHR4QilcbiAgICAgICAgICBjb25zdCBzaWduaW5nVHhCID0gZnVuZFRyYW5zYWN0aW9uKHR4QiwgcGF5bWVudEFkZHJlc3MsIHBheWVyVXR4b3MsIGZlZVJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lcklucHV0LnZhbHVlKVxuXG4gICAgICAgICAgcmV0dXJuIHNpZ25JbnB1dHMoc2lnbmluZ1R4QiwgcGF5bWVudEtleSwgW3sgaW5kZXg6IG93bmVySW5wdXQuaW5kZXgsIHNpZ25lcjogb3duZXJLZXkgfV0pXG4gICAgICAgIH0pXG4gICAgfSlcbiAgICAudGhlbihzaWduaW5nVHhCID0+IHJldHVyblRyYW5zYWN0aW9uSGV4KHNpZ25pbmdUeEIsIGJ1aWxkSW5jb21wbGV0ZSkpXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmV2b2tlIHRyYW5zYWN0aW9uIGZvciBhIGRvbWFpbiBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSAtIHRoZSBuYW1lIHRvIHJldm9rZVxuICogQHBhcmFtIHtTdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcn0gb3duZXJLZXlJbiAtIGEgaGV4IHN0cmluZyBvZlxuICogICAgdGhlIGN1cnJlbnQgb3duZXIncyBwcml2YXRlIGtleSAob3IgYSBUcmFuc2FjdGlvblNpZ25lciBvYmplY3QpXG4gKiBAcGFyYW0ge1N0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyfSBwYXltZW50S2V5SW4gLSBhIGhleCBzdHJpbmcgb2ZcbiAqICAgIHRoZSBwcml2YXRlIGtleSB1c2VkIHRvIGZ1bmQgdGhlIHRyYW5zYWN0aW9uIChvciBhXG4gKiAgICBUcmFuc2FjdGlvblNpZ25lciBvYmplY3QpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJ1aWxkSW5jb21wbGV0ZSAtIG9wdGlvbmFsIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLFxuICogICAgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBzaG91bGQgYXR0ZW1wdCB0byByZXR1cm4gYW4gdW5zaWduZWQgKG9yIG5vdCBmdWxseSBzaWduZWQpXG4gKiAgICB0cmFuc2FjdGlvbi4gVXNlZnVsIGZvciBwYXNzaW5nIGFyb3VuZCBhIFRYIGZvciBtdWx0aS1zaWcgaW5wdXQgc2lnbmluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaGV4LWVuY29kZWQgdHJhbnNhY3Rpb24uXG4gKiAgICB0aGlzIGZ1bmN0aW9uICpkb2VzIG5vdCogcGVyZm9ybSB0aGUgcmVxdWlzaXRlIHNhZmV0eSBjaGVja3MgLS0gcGxlYXNlIHNlZVxuICogICAgdGhlIHNhZmV0eSBtb2R1bGUgZm9yIHRob3NlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJldm9rZShmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgb3duZXJLZXlJbjogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIsXG4gICAgICAgICAgICAgICAgICAgIHBheW1lbnRLZXlJbjogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIsXG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkSW5jb21wbGV0ZT86IGJvb2xlYW4gPSBmYWxzZVxuKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBjb25maWcubmV0d29ya1xuXG4gIGNvbnN0IHBheW1lbnRLZXkgPSBnZXRUcmFuc2FjdGlvblNpZ25lcihwYXltZW50S2V5SW4pXG4gIGNvbnN0IG93bmVyS2V5ID0gZ2V0VHJhbnNhY3Rpb25TaWduZXIob3duZXJLZXlJbilcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW293bmVyS2V5LmdldEFkZHJlc3MoKSwgcGF5bWVudEtleS5nZXRBZGRyZXNzKCldKVxuICAgIC50aGVuKChbb3duZXJBZGRyZXNzLCBwYXltZW50QWRkcmVzc10pID0+IHtcbiAgICAgIGNvbnN0IHJldm9rZVRYID0gbWFrZVJldm9rZVNrZWxldG9uKGZ1bGx5UXVhbGlmaWVkTmFtZSlcbiAgICAgIGNvbnN0IHR4UHJvbWlzZSA9IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHJldm9rZVRYLCBuZXR3b3JrLmxheWVyMSlcbiAgICAgIHR4UHJvbWlzZS5zZXRWZXJzaW9uKDEpXG5cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt0eFByb21pc2UsIG5ldHdvcmsuZ2V0VVRYT3MocGF5bWVudEFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrLmdldFVUWE9zKG93bmVyQWRkcmVzcyksIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXSlcbiAgICAgICAgLnRoZW4oKFt0eEIsIHBheWVyVXR4b3MsIG93bmVyVXR4b3MsIGZlZVJhdGVdKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3duZXJJbnB1dCA9IGFkZE93bmVySW5wdXQob3duZXJVdHhvcywgb3duZXJBZGRyZXNzLCB0eEIpXG4gICAgICAgICAgY29uc3Qgc2lnbmluZ1R4QiA9IGZ1bmRUcmFuc2FjdGlvbih0eEIsIHBheW1lbnRBZGRyZXNzLCBwYXllclV0eG9zLCBmZWVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJbnB1dC52YWx1ZSlcbiAgICAgICAgICByZXR1cm4gc2lnbklucHV0cyhzaWduaW5nVHhCLCBwYXltZW50S2V5LCBbeyBpbmRleDogb3duZXJJbnB1dC5pbmRleCwgc2lnbmVyOiBvd25lcktleSB9XSlcbiAgICAgICAgfSlcbiAgICB9KVxuICAgIC50aGVuKHNpZ25pbmdUeEIgPT4gcmV0dXJuVHJhbnNhY3Rpb25IZXgoc2lnbmluZ1R4QiwgYnVpbGRJbmNvbXBsZXRlKSlcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByZW5ld2FsIHRyYW5zYWN0aW9uIGZvciBhIGRvbWFpbiBuYW1lLlxuICogQHBhcmFtIHtTdHJpbmd9IGZ1bGx5UXVhbGlmaWVkTmFtZSAtIHRoZSBuYW1lIHRvIHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZGVzdGluYXRpb25BZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgbmFtZSBhZnRlciByZW5ld2FsXG4gKiAgICB0aGlzIGFkZHJlc3Mgd2lsbCByZWNlaXZlIGEgZHVzdCBVVFhPXG4gKiBAcGFyYW0ge1N0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyfSBvd25lcktleUluIC0gYSBoZXggc3RyaW5nIG9mXG4gKiAgICB0aGUgY3VycmVudCBvd25lcidzIHByaXZhdGUga2V5IChvciBhIFRyYW5zYWN0aW9uU2lnbmVyIG9iamVjdClcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IHBheW1lbnRLZXlJbiAtIGEgaGV4IHN0cmluZyBvZlxuICogICAgdGhlIHByaXZhdGUga2V5IHVzZWQgdG8gZnVuZCB0aGUgcmVuZXdhbCAob3IgYSBUcmFuc2FjdGlvblNpZ25lclxuICogICAgb2JqZWN0KVxuICogQHBhcmFtIHtTdHJpbmd9IHpvbmVmaWxlIC0gdGhlIHpvbmVmaWxlIGRhdGEgdG8gaW5jbHVkZSwgaWYgZ2l2ZW4gKHRoaXMgd2lsbCBiZSBoYXNoZWRcbiAqICAgIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9uKSwgdGhlIHpvbmVmaWxlIGl0c2VsZiBtdXN0IGJlIHB1Ymxpc2hlZFxuICogICAgYWZ0ZXIgdGhlIFJFTkVXQUwgcHJvcGFnYXRlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZUhhc2ggLSB0aGUgcmF3IHpvbmUgZmlsZSBoYXNoIHRvIGluY2x1ZGUgKHRoaXMgd2lsbCBiZSB1c2VkXG4gKiAgICBpbnN0ZWFkIG9mIHpvbmVmaWxlLCBpZiBnaXZlbikuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJ1aWxkSW5jb21wbGV0ZSAtIG9wdGlvbmFsIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLFxuICogICAgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBzaG91bGQgYXR0ZW1wdCB0byByZXR1cm4gYW4gdW5zaWduZWQgKG9yIG5vdCBmdWxseSBzaWduZWQpXG4gKiAgICB0cmFuc2FjdGlvbi4gVXNlZnVsIGZvciBwYXNzaW5nIGFyb3VuZCBhIFRYIGZvciBtdWx0aS1zaWcgaW5wdXQgc2lnbmluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaGV4LWVuY29kZWQgdHJhbnNhY3Rpb24uXG4gKiAgICB0aGlzIGZ1bmN0aW9uICpkb2VzIG5vdCogcGVyZm9ybSB0aGUgcmVxdWlzaXRlIHNhZmV0eSBjaGVja3MgLS0gcGxlYXNlIHNlZVxuICogICAgdGhlIHNhZmV0eSBtb2R1bGUgZm9yIHRob3NlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZVJlbmV3YWwoZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbkFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgIG93bmVyS2V5SW46IHN0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEtleUluOiBzdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgIHpvbmVmaWxlOiA/c3RyaW5nID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzaDogP3N0cmluZyA9IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICBidWlsZEluY29tcGxldGU/OiBib29sZWFuID0gZmFsc2Vcbikge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBpZiAoIXZhbHVlSGFzaCAmJiAhIXpvbmVmaWxlKSB7XG4gICAgdmFsdWVIYXNoID0gaGFzaDE2MChCdWZmZXIuZnJvbSh6b25lZmlsZSkpLnRvU3RyaW5nKCdoZXgnKVxuICB9XG5cbiAgY29uc3QgbmFtZXNwYWNlID0gZnVsbHlRdWFsaWZpZWROYW1lLnNwbGl0KCcuJykucG9wKClcblxuICBjb25zdCBwYXltZW50S2V5ID0gZ2V0VHJhbnNhY3Rpb25TaWduZXIocGF5bWVudEtleUluKVxuICBjb25zdCBvd25lcktleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKG93bmVyS2V5SW4pXG5cbiAgcmV0dXJuIFByb21pc2UuYWxsKFtvd25lcktleS5nZXRBZGRyZXNzKCksIHBheW1lbnRLZXkuZ2V0QWRkcmVzcygpXSlcbiAgICAudGhlbigoW293bmVyQWRkcmVzcywgcGF5bWVudEFkZHJlc3NdKSA9PiB7XG4gICAgICBjb25zdCB0eFByb21pc2UgPSBQcm9taXNlLmFsbChbbmV0d29yay5nZXROYW1lUHJpY2UoZnVsbHlRdWFsaWZpZWROYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrLmdldE5hbWVzcGFjZUJ1cm5BZGRyZXNzKG5hbWVzcGFjZSldKVxuICAgICAgICAudGhlbigoW25hbWVQcmljZSwgYnVybkFkZHJlc3NdKSA9PiBtYWtlUmVuZXdhbFNrZWxldG9uKFxuICAgICAgICAgIGZ1bGx5UXVhbGlmaWVkTmFtZSwgZGVzdGluYXRpb25BZGRyZXNzLCBvd25lckFkZHJlc3MsXG4gICAgICAgICAgYnVybkFkZHJlc3MsIG5hbWVQcmljZSwgdmFsdWVIYXNoXG4gICAgICAgICkpXG4gICAgICAgIC50aGVuKCh0eCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHR4QiA9IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHR4LCBuZXR3b3JrLmxheWVyMSlcbiAgICAgICAgICB0eEIuc2V0VmVyc2lvbigxKVxuICAgICAgICAgIHJldHVybiB0eEJcbiAgICAgICAgfSlcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFt0eFByb21pc2UsIG5ldHdvcmsuZ2V0VVRYT3MocGF5bWVudEFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrLmdldFVUWE9zKG93bmVyQWRkcmVzcyksIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXSlcbiAgICAgICAgLnRoZW4oKFt0eEIsIHBheWVyVXR4b3MsIG93bmVyVXR4b3MsIGZlZVJhdGVdKSA9PiB7XG4gICAgICAgICAgY29uc3Qgb3duZXJJbnB1dCA9IGFkZE93bmVySW5wdXQob3duZXJVdHhvcywgb3duZXJBZGRyZXNzLCB0eEIsIGZhbHNlKVxuICAgICAgICAgIGNvbnN0IG93bmVyT3V0cHV0ID0gdHhCLl9fdHgub3V0c1syXVxuICAgICAgICAgIGNvbnN0IG93bmVyT3V0cHV0QWRkciA9IGJpdGNvaW5qcy5hZGRyZXNzLmZyb21PdXRwdXRTY3JpcHQoXG4gICAgICAgICAgICBvd25lck91dHB1dC5zY3JpcHQsIG5ldHdvcmsubGF5ZXIxXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChvd25lck91dHB1dEFkZHIgIT09IG93bmVyQWRkcmVzcykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoYE9yaWdpbmFsIG93bmVyICR7b3duZXJBZGRyZXNzfSBzaG91bGQgaGF2ZSBhbiBvdXRwdXQgYXQgYFxuICAgICAgICAgICAgICAgICAgICAgICAgKyBgaW5kZXggMiBpbiB0cmFuc2FjdGlvbiB3YXMgJHtvd25lck91dHB1dEFkZHJ9YClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgb3duZXJPdXRwdXQudmFsdWUgPSBvd25lcklucHV0LnZhbHVlXG4gICAgICAgICAgY29uc3Qgc2lnbmluZ1R4QiA9IGZ1bmRUcmFuc2FjdGlvbih0eEIsIHBheW1lbnRBZGRyZXNzLCBwYXllclV0eG9zLCBmZWVSYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3duZXJJbnB1dC52YWx1ZSlcbiAgICAgICAgICByZXR1cm4gc2lnbklucHV0cyhzaWduaW5nVHhCLCBwYXltZW50S2V5LCBbeyBpbmRleDogb3duZXJJbnB1dC5pbmRleCwgc2lnbmVyOiBvd25lcktleSB9XSlcbiAgICAgICAgfSlcbiAgICB9KVxuICAgIC50aGVuKHNpZ25pbmdUeEIgPT4gcmV0dXJuVHJhbnNhY3Rpb25IZXgoc2lnbmluZ1R4QiwgYnVpbGRJbmNvbXBsZXRlKSlcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5hbWVzcGFjZSBwcmVvcmRlciB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VJRCAtIHRoZSBuYW1lc3BhY2UgdG8gcHJlLW9yZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmV2ZWFsQWRkcmVzcyAtIHRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIG5hbWVzcGFjZSAodGhpc1xuICogICAgbXVzdCBiZSBwYXNzZWQgYXMgdGhlICdyZXZlYWxBZGRyZXNzJyBpbiB0aGUgbmFtZXNwYWNlLXJldmVhbCB0cmFuc2FjdGlvbilcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IHBheW1lbnRLZXlJbiAtIGEgaGV4IHN0cmluZyBvZlxuICogICAgdGhlIHByaXZhdGUga2V5IHVzZWQgdG8gZnVuZCB0aGUgdHJhbnNhY3Rpb24gKG9yIGFcbiAqICAgIFRyYW5zYWN0aW9uU2lnbmVyIG9iamVjdClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnVpbGRJbmNvbXBsZXRlIC0gb3B0aW9uYWwgYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UsXG4gKiAgICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGZ1bmN0aW9uIHNob3VsZCBhdHRlbXB0IHRvIHJldHVybiBhbiB1bnNpZ25lZCAob3Igbm90IGZ1bGx5IHNpZ25lZClcbiAqICAgIHRyYW5zYWN0aW9uLiBVc2VmdWwgZm9yIHBhc3NpbmcgYXJvdW5kIGEgVFggZm9yIG11bHRpLXNpZyBpbnB1dCBzaWduaW5nLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBoZXgtZW5jb2RlZCB0cmFuc2FjdGlvbi5cbiAqICAgIHRoaXMgZnVuY3Rpb24gKmRvZXMgbm90KiBwZXJmb3JtIHRoZSByZXF1aXNpdGUgc2FmZXR5IGNoZWNrcyAtLSBwbGVhc2Ugc2VlXG4gKiAgICB0aGUgc2FmZXR5IG1vZHVsZSBmb3IgdGhvc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTmFtZXNwYWNlUHJlb3JkZXIobmFtZXNwYWNlSUQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlYWxBZGRyZXNzOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEtleUluOiBzdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWlsZEluY29tcGxldGU/OiBib29sZWFuID0gZmFsc2Vcbikge1xuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcblxuICBjb25zdCBwYXltZW50S2V5ID0gZ2V0VHJhbnNhY3Rpb25TaWduZXIocGF5bWVudEtleUluKVxuXG4gIHJldHVybiBwYXltZW50S2V5LmdldEFkZHJlc3MoKS50aGVuKChwcmVvcmRlckFkZHJlc3MpID0+IHtcbiAgICBjb25zdCBwcmVvcmRlclByb21pc2UgPSBQcm9taXNlLmFsbChbbmV0d29yay5nZXRDb25zZW5zdXNIYXNoKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsuZ2V0TmFtZXNwYWNlUHJpY2UobmFtZXNwYWNlSUQpXSlcbiAgICAgIC50aGVuKChbY29uc2Vuc3VzSGFzaCwgbmFtZXNwYWNlUHJpY2VdKSA9PiBtYWtlTmFtZXNwYWNlUHJlb3JkZXJTa2VsZXRvbihcbiAgICAgICAgbmFtZXNwYWNlSUQsIGNvbnNlbnN1c0hhc2gsIHByZW9yZGVyQWRkcmVzcywgcmV2ZWFsQWRkcmVzcyxcbiAgICAgICAgbmFtZXNwYWNlUHJpY2UpKVxuXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFtuZXR3b3JrLmdldFVUWE9zKHByZW9yZGVyQWRkcmVzcyksIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpLCBwcmVvcmRlclByb21pc2VdKVxuICAgICAgLnRoZW4oKFt1dHhvcywgZmVlUmF0ZSwgcHJlb3JkZXJTa2VsZXRvbl0pID0+IHtcbiAgICAgICAgY29uc3QgdHhCID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24ocHJlb3JkZXJTa2VsZXRvbiwgbmV0d29yay5sYXllcjEpXG4gICAgICAgIHR4Qi5zZXRWZXJzaW9uKDEpXG5cbiAgICAgICAgY29uc3QgY2hhbmdlSW5kZXggPSAxIC8vIHByZW9yZGVyIHNrZWxldG9uIGFsd2F5cyBjcmVhdGVzIGEgY2hhbmdlIG91dHB1dCBhdCBpbmRleCA9IDFcbiAgICAgICAgY29uc3Qgc2lnbmluZ1R4QiA9IGZ1bmRUcmFuc2FjdGlvbih0eEIsIHByZW9yZGVyQWRkcmVzcywgdXR4b3MsIGZlZVJhdGUsIDAsIGNoYW5nZUluZGV4KVxuXG4gICAgICAgIHJldHVybiBzaWduSW5wdXRzKHNpZ25pbmdUeEIsIHBheW1lbnRLZXkpXG4gICAgICB9KVxuICAgICAgLnRoZW4oc2lnbmluZ1R4QiA9PiByZXR1cm5UcmFuc2FjdGlvbkhleChzaWduaW5nVHhCLCBidWlsZEluY29tcGxldGUpKVxuICB9KVxufVxuXG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmFtZXNwYWNlIHJldmVhbCB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7QmxvY2tzdGFja05hbWVzcGFjZX0gbmFtZXNwYWNlIC0gdGhlIG5hbWVzcGFjZSB0byByZXZlYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXZlYWxBZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgbmFtZXNwYWNlICh0aGlzXG4gKiAgIG11c3QgYmUgcGFzc2VkIGFzIHRoZSAncmV2ZWFsQWRkcmVzcycgaW4gdGhlIG5hbWVzcGFjZS1yZXZlYWwgdHJhbnNhY3Rpb24pXG4gKiBAcGFyYW0ge1N0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyfSBwYXltZW50S2V5SW4gLSBhIGhleCBzdHJpbmcgKG9yXG4gKiAgIGEgVHJhbnNhY3Rpb25TaWduZXIgb2JqZWN0KSBvZiB0aGUgcHJpdmF0ZSBrZXkgdXNlZCB0byBmdW5kIHRoZVxuICogICB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBidWlsZEluY29tcGxldGUgLSBvcHRpb25hbCBib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSxcbiAqICAgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBzaG91bGQgYXR0ZW1wdCB0byByZXR1cm4gYW4gdW5zaWduZWQgKG9yIG5vdCBmdWxseSBzaWduZWQpXG4gKiAgIHRyYW5zYWN0aW9uLiBVc2VmdWwgZm9yIHBhc3NpbmcgYXJvdW5kIGEgVFggZm9yIG11bHRpLXNpZyBpbnB1dCBzaWduaW5nLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBoZXgtZW5jb2RlZCB0cmFuc2FjdGlvbi5cbiAqICAgdGhpcyBmdW5jdGlvbiAqZG9lcyBub3QqIHBlcmZvcm0gdGhlIHJlcXVpc2l0ZSBzYWZldHkgY2hlY2tzIC0tIHBsZWFzZSBzZWVcbiAqICAgdGhlIHNhZmV0eSBtb2R1bGUgZm9yIHRob3NlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZU5hbWVzcGFjZVJldmVhbChuYW1lc3BhY2U6IEJsb2Nrc3RhY2tOYW1lc3BhY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVhbEFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bWVudEtleUluOiBzdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG5cbiAgaWYgKCFuYW1lc3BhY2UuY2hlY2soKSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ludmFsaWQgbmFtZXNwYWNlJykpXG4gIH1cblxuICBjb25zdCBuYW1lc3BhY2VSZXZlYWxUWCA9IG1ha2VOYW1lc3BhY2VSZXZlYWxTa2VsZXRvbihuYW1lc3BhY2UsIHJldmVhbEFkZHJlc3MpXG5cbiAgY29uc3QgcGF5bWVudEtleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKHBheW1lbnRLZXlJbilcblxuICByZXR1cm4gcGF5bWVudEtleS5nZXRBZGRyZXNzKCkudGhlbihcbiAgICBwcmVvcmRlckFkZHJlc3MgPT4gUHJvbWlzZS5hbGwoW25ldHdvcmsuZ2V0VVRYT3MocHJlb3JkZXJBZGRyZXNzKSwgbmV0d29yay5nZXRGZWVSYXRlKCldKVxuICAgICAgLnRoZW4oKFt1dHhvcywgZmVlUmF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgdHhCID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlclxuICAgICAgICAgIC5mcm9tVHJhbnNhY3Rpb24obmFtZXNwYWNlUmV2ZWFsVFgsIG5ldHdvcmsubGF5ZXIxKVxuICAgICAgICB0eEIuc2V0VmVyc2lvbigxKVxuICAgICAgICBjb25zdCBzaWduaW5nVHhCID0gZnVuZFRyYW5zYWN0aW9uKHR4QiwgcHJlb3JkZXJBZGRyZXNzLCB1dHhvcywgZmVlUmF0ZSwgMClcblxuICAgICAgICByZXR1cm4gc2lnbklucHV0cyhzaWduaW5nVHhCLCBwYXltZW50S2V5KVxuICAgICAgfSlcbiAgKVxuICAgIC50aGVuKHNpZ25pbmdUeEIgPT4gcmV0dXJuVHJhbnNhY3Rpb25IZXgoc2lnbmluZ1R4QiwgYnVpbGRJbmNvbXBsZXRlKSlcbn1cblxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG5hbWVzcGFjZSByZWFkeSB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VJRCAtIHRoZSBuYW1lc3BhY2UgdG8gbGF1bmNoXG4gKiBAcGFyYW0ge1N0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyfSByZXZlYWxLZXlJbiAtIHRoZSBwcml2YXRlIGtleVxuICogIG9mIHRoZSAncmV2ZWFsQWRkcmVzcycgdXNlZCB0byByZXZlYWwgdGhlIG5hbWVzcGFjZVxuICogQHBhcmFtIHtib29sZWFufSBidWlsZEluY29tcGxldGUgLSBvcHRpb25hbCBib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSxcbiAqICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGZ1bmN0aW9uIHNob3VsZCBhdHRlbXB0IHRvIHJldHVybiBhbiB1bnNpZ25lZCAob3Igbm90IGZ1bGx5IHNpZ25lZClcbiAqICB0cmFuc2FjdGlvbi4gVXNlZnVsIGZvciBwYXNzaW5nIGFyb3VuZCBhIFRYIGZvciBtdWx0aS1zaWcgaW5wdXQgc2lnbmluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaGV4LWVuY29kZWQgdHJhbnNhY3Rpb24uXG4gKiAgdGhpcyBmdW5jdGlvbiAqZG9lcyBub3QqIHBlcmZvcm0gdGhlIHJlcXVpc2l0ZSBzYWZldHkgY2hlY2tzIC0tIHBsZWFzZSBzZWVcbiAqICB0aGUgc2FmZXR5IG1vZHVsZSBmb3IgdGhvc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTmFtZXNwYWNlUmVhZHkobmFtZXNwYWNlSUQ6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXZlYWxLZXlJbjogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG5cbiAgY29uc3QgbmFtZXNwYWNlUmVhZHlUWCA9IG1ha2VOYW1lc3BhY2VSZWFkeVNrZWxldG9uKG5hbWVzcGFjZUlEKVxuXG4gIGNvbnN0IHJldmVhbEtleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKHJldmVhbEtleUluKVxuXG4gIHJldHVybiByZXZlYWxLZXkuZ2V0QWRkcmVzcygpLnRoZW4oXG4gICAgcmV2ZWFsQWRkcmVzcyA9PiBQcm9taXNlLmFsbChbbmV0d29yay5nZXRVVFhPcyhyZXZlYWxBZGRyZXNzKSwgbmV0d29yay5nZXRGZWVSYXRlKCldKVxuICAgICAgLnRoZW4oKFt1dHhvcywgZmVlUmF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgdHhCID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24obmFtZXNwYWNlUmVhZHlUWCwgbmV0d29yay5sYXllcjEpXG4gICAgICAgIHR4Qi5zZXRWZXJzaW9uKDEpXG4gICAgICAgIGNvbnN0IHNpZ25pbmdUeEIgPSBmdW5kVHJhbnNhY3Rpb24odHhCLCByZXZlYWxBZGRyZXNzLCB1dHhvcywgZmVlUmF0ZSwgMClcbiAgICAgICAgcmV0dXJuIHNpZ25JbnB1dHMoc2lnbmluZ1R4QiwgcmV2ZWFsS2V5KVxuICAgICAgfSlcbiAgKVxuICAgIC50aGVuKHNpZ25pbmdUeEIgPT4gcmV0dXJuVHJhbnNhY3Rpb25IZXgoc2lnbmluZ1R4QiwgYnVpbGRJbmNvbXBsZXRlKSlcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBuYW1lIGltcG9ydCB0cmFuc2FjdGlvbiBmb3IgYSBuYW1lc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWUgdG8gaW1wb3J0XG4gKiBAcGFyYW0ge1N0cmluZ30gcmVjaXBpZW50QWRkciAtIHRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSB6b25lZmlsZUhhc2ggLSB0aGUgaGFzaCBvZiB0aGUgem9uZWZpbGUgdG8gZ2l2ZSB0aGlzIG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IGltcG9ydGVyS2V5SW4gLSB0aGUgcHJpdmF0ZSBrZXlcbiAqIHRoYXQgcGF5cyBmb3IgdGhlIGltcG9ydFxuICogQHBhcmFtIHtib29sZWFufSBidWlsZEluY29tcGxldGUgLSBvcHRpb25hbCBib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSxcbiAqIGluZGljYXRpbmcgd2hldGhlciB0aGUgZnVuY3Rpb24gc2hvdWxkIGF0dGVtcHQgdG8gcmV0dXJuIGFuIHVuc2lnbmVkIChvciBub3QgZnVsbHkgc2lnbmVkKVxuICogdHJhbnNhY3Rpb24uIFVzZWZ1bCBmb3IgcGFzc2luZyBhcm91bmQgYSBUWCBmb3IgbXVsdGktc2lnIGlucHV0IHNpZ25pbmcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGhleC1lbmNvZGVkIHRyYW5zYWN0aW9uLlxuICogdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIHRoZSByZXF1aXNpdGUgc2FmZXR5IGNoZWNrcyAtLSBwbGVhc2Ugc2VlXG4gKiB0aGUgc2FmZXR5IG1vZHVsZSBmb3IgdGhvc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlTmFtZUltcG9ydChuYW1lOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNpcGllbnRBZGRyOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB6b25lZmlsZUhhc2g6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcG9ydGVyS2V5SW46IHN0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG5cbiAgY29uc3QgbmFtZUltcG9ydFRYID0gbWFrZU5hbWVJbXBvcnRTa2VsZXRvbihuYW1lLCByZWNpcGllbnRBZGRyLCB6b25lZmlsZUhhc2gpXG5cbiAgY29uc3QgaW1wb3J0ZXJLZXkgPSBnZXRUcmFuc2FjdGlvblNpZ25lcihpbXBvcnRlcktleUluKVxuXG4gIHJldHVybiBpbXBvcnRlcktleS5nZXRBZGRyZXNzKCkudGhlbihcbiAgICBpbXBvcnRlckFkZHJlc3MgPT4gUHJvbWlzZS5hbGwoW25ldHdvcmsuZ2V0VVRYT3MoaW1wb3J0ZXJBZGRyZXNzKSwgbmV0d29yay5nZXRGZWVSYXRlKCldKVxuICAgICAgLnRoZW4oKFt1dHhvcywgZmVlUmF0ZV0pID0+IHtcbiAgICAgICAgY29uc3QgdHhCID0gYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24obmFtZUltcG9ydFRYLCBuZXR3b3JrLmxheWVyMSlcbiAgICAgICAgY29uc3Qgc2lnbmluZ1R4QiA9IGZ1bmRUcmFuc2FjdGlvbih0eEIsIGltcG9ydGVyQWRkcmVzcywgdXR4b3MsIGZlZVJhdGUsIDApXG4gICAgICAgIHJldHVybiBzaWduSW5wdXRzKHNpZ25pbmdUeEIsIGltcG9ydGVyS2V5KVxuICAgICAgfSlcbiAgKVxuICAgIC50aGVuKHNpZ25pbmdUeEIgPT4gcmV0dXJuVHJhbnNhY3Rpb25IZXgoc2lnbmluZ1R4QiwgYnVpbGRJbmNvbXBsZXRlKSlcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYW5ub3VuY2UgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlSGFzaCAtIHRoZSBoYXNoIG9mIHRoZSBtZXNzYWdlIHRvIHNlbmQuICBTaG91bGQgYmVcbiAqICBhbiBhbHJlYWR5LWFubm91bmNlZCB6b25lIGZpbGUgaGFzaFxuICogQHBhcmFtIHtTdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcn0gc2VuZGVyS2V5SW4gLSB0aGUgcHJpdmF0ZSBrZXlcbiAqICB0aGF0IHBheXMgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFNob3VsZCBiZSB0aGUga2V5IHRoYXQgb3ducyB0aGVcbiAqICBuYW1lIHRoYXQgdGhlIG1lc3NhZ2UgcmVjaXBpZW50cyBzdWJzY3JpYmUgdG9cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYnVpbGRJbmNvbXBsZXRlIC0gb3B0aW9uYWwgYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UsXG4gKiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGZ1bmN0aW9uIHNob3VsZCBhdHRlbXB0IHRvIHJldHVybiBhbiB1bnNpZ25lZCAob3Igbm90IGZ1bGx5IHNpZ25lZClcbiAqIHRyYW5zYWN0aW9uLiBVc2VmdWwgZm9yIHBhc3NpbmcgYXJvdW5kIGEgVFggZm9yIG11bHRpLXNpZyBpbnB1dCBzaWduaW5nLlxuICogQHJldHVybnMge1Byb21pc2V9IC0gYSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHRvIHRoZSBoZXgtZW5jb2RlZCB0cmFuc2FjdGlvbi5cbiAqIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcGVyZm9ybSB0aGUgcmVxdWlzaXRlIHNhZmV0eSBjaGVja3MgLS0gcGxlYXNlIHNlZSB0aGVcbiAqIHNhZmV0eSBtb2R1bGUgZm9yIHRob3NlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFrZUFubm91bmNlKG1lc3NhZ2VIYXNoOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgc2VuZGVyS2V5SW46IHN0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgIGJ1aWxkSW5jb21wbGV0ZT86IGJvb2xlYW4gPSBmYWxzZVxuKSB7XG4gIGNvbnN0IG5ldHdvcmsgPSBjb25maWcubmV0d29ya1xuXG4gIGNvbnN0IGFubm91bmNlVFggPSBtYWtlQW5ub3VuY2VTa2VsZXRvbihtZXNzYWdlSGFzaClcblxuICBjb25zdCBzZW5kZXJLZXkgPSBnZXRUcmFuc2FjdGlvblNpZ25lcihzZW5kZXJLZXlJbilcblxuICByZXR1cm4gc2VuZGVyS2V5LmdldEFkZHJlc3MoKS50aGVuKFxuICAgIHNlbmRlckFkZHJlc3MgPT4gUHJvbWlzZS5hbGwoW25ldHdvcmsuZ2V0VVRYT3Moc2VuZGVyQWRkcmVzcyksIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXSlcbiAgICAgIC50aGVuKChbdXR4b3MsIGZlZVJhdGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHR4QiA9IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKGFubm91bmNlVFgsIG5ldHdvcmsubGF5ZXIxKVxuICAgICAgICBjb25zdCBzaWduaW5nVHhCID0gZnVuZFRyYW5zYWN0aW9uKHR4Qiwgc2VuZGVyQWRkcmVzcywgdXR4b3MsIGZlZVJhdGUsIDApXG4gICAgICAgIHJldHVybiBzaWduSW5wdXRzKHNpZ25pbmdUeEIsIHNlbmRlcktleSlcbiAgICAgIH0pXG4gIClcbiAgICAudGhlbihzaWduaW5nVHhCID0+IHJldHVyblRyYW5zYWN0aW9uSGV4KHNpZ25pbmdUeEIsIGJ1aWxkSW5jb21wbGV0ZSkpXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdG9rZW4tdHJhbnNmZXIgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RyaW5nfSByZWNpcGllbnRBZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gcmVjZWl2ZSB0aGUgdG9rZW5zXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5UeXBlIC0gdGhlIHR5cGUgb2YgdG9rZW5zIHRvIHNlbmRcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbkFtb3VudCAtIHRoZSBCaWdJbnRlZ2VyIGVuY29kaW5nIG9mIGFuIHVuc2lnbmVkIDY0LWJpdCBudW1iZXIgb2ZcbiAqICB0b2tlbnMgdG8gc2VuZFxuICogQHBhcmFtIHtTdHJpbmd9IHNjcmF0Y2hBcmVhIC0gYW4gYXJiaXRyYXJ5IHN0cmluZyB0byBpbmNsdWRlIHdpdGggdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyfSBzZW5kZXJLZXlJbiAtIHRoZSBoZXgtZW5jb2RlZCBwcml2YXRlIGtleSB0byBzZW5kXG4gKiAgIHRoZSB0b2tlbnNcbiAqIEBwYXJhbSB7U3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXJ9IGJ0Y0Z1bmRlcktleUluIC0gdGhlIGhleC1lbmNvZGVkIHByaXZhdGUga2V5IHRvIGZ1bmRcbiAqICAgdGhlIGJpdGNvaW4gZmVlcyBmb3IgdGhlIHRyYW5zYWN0aW9uLiBPcHRpb25hbCAtLSBpZiBub3QgcGFzc2VkLCB3aWxsIGF0dGVtcHQgdG9cbiAqICAgZnVuZCB3aXRoIHNlbmRlciBrZXkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJ1aWxkSW5jb21wbGV0ZSAtIG9wdGlvbmFsIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLFxuICogICBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGZ1bmN0aW9uIHNob3VsZCBhdHRlbXB0IHRvIHJldHVybiBhbiB1bnNpZ25lZCAob3Igbm90IGZ1bGx5IHNpZ25lZClcbiAqICAgdHJhbnNhY3Rpb24uIFVzZWZ1bCBmb3IgcGFzc2luZyBhcm91bmQgYSBUWCBmb3IgbXVsdGktc2lnIGlucHV0IHNpZ25pbmcuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gLSBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIGhleC1lbmNvZGVkIHRyYW5zYWN0aW9uLlxuICogVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBwZXJmb3JtIHRoZSByZXF1aXNpdGUgc2FmZXR5IGNoZWNrcyAtLSBwbGVhc2Ugc2VlIHRoZVxuICogc2FmZXR5IG1vZHVsZSBmb3IgdGhvc2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlVG9rZW5UcmFuc2ZlcihyZWNpcGllbnRBZGRyZXNzOiBzdHJpbmcsIHRva2VuVHlwZTogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5BbW91bnQ6IEJpZ0ludGVnZXIsIHNjcmF0Y2hBcmVhOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXJLZXlJbjogc3RyaW5nIHwgVHJhbnNhY3Rpb25TaWduZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBidGNGdW5kZXJLZXlJbj86IHN0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG4gIGNvbnN0IHNlcGFyYXRlRnVuZGVyID0gISFidGNGdW5kZXJLZXlJblxuXG4gIGNvbnN0IHNlbmRlcktleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKHNlbmRlcktleUluKVxuICBjb25zdCBidGNLZXkgPSBidGNGdW5kZXJLZXlJbiA/IGdldFRyYW5zYWN0aW9uU2lnbmVyKGJ0Y0Z1bmRlcktleUluKSA6IHNlbmRlcktleVxuXG4gIGNvbnN0IHR4UHJvbWlzZSA9IG5ldHdvcmsuZ2V0Q29uc2Vuc3VzSGFzaCgpXG4gICAgLnRoZW4oY29uc2Vuc3VzSGFzaCA9PiAgbWFrZVRva2VuVHJhbnNmZXJTa2VsZXRvbihcbiAgICAgIHJlY2lwaWVudEFkZHJlc3MsIGNvbnNlbnN1c0hhc2gsIHRva2VuVHlwZSwgdG9rZW5BbW91bnQsIHNjcmF0Y2hBcmVhKSlcblxuICByZXR1cm4gUHJvbWlzZS5hbGwoW3NlbmRlcktleS5nZXRBZGRyZXNzKCksIGJ0Y0tleS5nZXRBZGRyZXNzKCldKVxuICAgIC50aGVuKChbc2VuZGVyQWRkcmVzcywgYnRjQWRkcmVzc10pID0+IHtcbiAgICAgIGNvbnN0IGJ0Y1VUWE9zUHJvbWlzZSA9IHNlcGFyYXRlRnVuZGVyXG4gICAgICAgID8gbmV0d29yay5nZXRVVFhPcyhidGNBZGRyZXNzKSA6IFByb21pc2UucmVzb2x2ZShbXSlcbiAgICAgIGNvbnN0IG5ldHdvcmtQcm9taXNlcyA9IFtuZXR3b3JrLmdldFVUWE9zKHNlbmRlckFkZHJlc3MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ0Y1VUWE9zUHJvbWlzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrLmdldEZlZVJhdGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eFByb21pc2VdXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwobmV0d29ya1Byb21pc2VzKVxuICAgICAgICAudGhlbigoW3NlbmRlclVUWE9zLCBidGNVVFhPcywgZmVlUmF0ZSwgdG9rZW5UcmFuc2ZlclRYXSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHR4QiA9IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIuZnJvbVRyYW5zYWN0aW9uKHRva2VuVHJhbnNmZXJUWCwgbmV0d29yay5sYXllcjEpXG5cbiAgICAgICAgICBpZiAoc2VwYXJhdGVGdW5kZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWVySW5wdXQgPSBhZGRPd25lcklucHV0KHNlbmRlclVUWE9zLCBzZW5kZXJBZGRyZXNzLCB0eEIpXG4gICAgICAgICAgICBjb25zdCBzaWduaW5nVHhCID0gZnVuZFRyYW5zYWN0aW9uKHR4QiwgYnRjQWRkcmVzcywgYnRjVVRYT3MsIGZlZVJhdGUsIHBheWVySW5wdXQudmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gc2lnbklucHV0cyhzaWduaW5nVHhCLCBidGNLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbeyBpbmRleDogcGF5ZXJJbnB1dC5pbmRleCwgc2lnbmVyOiBzZW5kZXJLZXkgfV0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdUeEIgPSBmdW5kVHJhbnNhY3Rpb24odHhCLCBzZW5kZXJBZGRyZXNzLCBzZW5kZXJVVFhPcywgZmVlUmF0ZSwgMClcbiAgICAgICAgICAgIHJldHVybiBzaWduSW5wdXRzKHNpZ25pbmdUeEIsIHNlbmRlcktleSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfSlcbiAgICAudGhlbihzaWduaW5nVHhCID0+IHJldHVyblRyYW5zYWN0aW9uSGV4KHNpZ25pbmdUeEIsIGJ1aWxkSW5jb21wbGV0ZSkpXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgYml0Y29pbiBzcGVuZCB0byBhIHNwZWNpZmllZCBhZGRyZXNzLiBUaGlzIHdpbGwgZnVuZCB1cCB0byBgYW1vdW50YFxuICogICBvZiBzYXRvc2hpcyBmcm9tIHRoZSBwYXllcidzIFVUWE9zLiBJdCB3aWxsIGdlbmVyYXRlIGEgY2hhbmdlIG91dHB1dCBpZiBhbmQgb25seVxuICogICBpZiB0aGUgYW1vdW50IG9mIGxlZnRvdmVyIGNoYW5nZSBpcyAqZ3JlYXRlciogdGhhbiB0aGUgYWRkaXRpb25hbCBmZWVzIGFzc29jaWF0ZWRcbiAqICAgd2l0aCB0aGUgZXh0cmEgb3V0cHV0LiBJZiB0aGUgcmVxdWVzdGVkIGFtb3VudCBpcyBub3QgZW5vdWdoIHRvIGZ1bmQgdGhlIHRyYW5zYWN0aW9uJ3NcbiAqICAgYXNzb2NpYXRlZCBmZWVzLCB0aGVuIHRoaXMgd2lsbCByZWplY3Qgd2l0aCBhIEludmFsaWRBbW91bnRFcnJvclxuICpcbiAqIFVUWE9zIGFyZSBzZWxlY3RlZCBsYXJnZXN0IHRvIHNtYWxsZXN0LCBhbmQgVVRYT3Mgd2hpY2ggY2Fubm90IGZ1bmQgdGhlIGZlZXMgYXNzb2NpYXRlZFxuICogICB3aXRoIHRoZWlyIG93biBpbnB1dCB3aWxsIG5vdCBiZSBpbmNsdWRlZC5cbiAqXG4gKiBJZiB5b3Ugc3BlY2lmeSBhbiBhbW91bnQgPiB0aGUgdG90YWwgYmFsYW5jZSBvZiB0aGUgcGF5ZXIgYWRkcmVzcywgdGhlbiB0aGlzIHdpbGxcbiAqICAgZ2VuZXJhdGUgYSBtYXhpbXVtIHNwZW5kIHRyYW5zYWN0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRlc3RpbmF0aW9uQWRkcmVzcyAtIHRoZSBhZGRyZXNzIHRvIHJlY2VpdmUgdGhlIGJpdGNvaW4gcGF5bWVudFxuICogQHBhcmFtIHtTdHJpbmcgfCBUcmFuc2FjdGlvblNpZ25lcn0gcGF5bWVudEtleUluIC0gdGhlIHByaXZhdGUga2V5XG4gKiAgICB1c2VkIHRvIGZ1bmQgdGhlIGJpdGNvaW4gc3BlbmRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhbW91bnQgLSB0aGUgYW1vdW50IGluIHNhdG9zaGlzIGZvciB0aGUgcGF5bWVudCBhZGRyZXNzIHRvXG4gKiAgICBzcGVuZCBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJ1aWxkSW5jb21wbGV0ZSAtIG9wdGlvbmFsIGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlLFxuICogaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBmdW5jdGlvbiBzaG91bGQgYXR0ZW1wdCB0byByZXR1cm4gYW4gdW5zaWduZWQgKG9yIG5vdCBmdWxseSBzaWduZWQpXG4gKiB0cmFuc2FjdGlvbi4gVXNlZnVsIGZvciBwYXNzaW5nIGFyb3VuZCBhIFRYIGZvciBtdWx0aS1zaWcgaW5wdXQgc2lnbmluZy5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSAtIGEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB0byB0aGUgaGV4LWVuY29kZWQgdHJhbnNhY3Rpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBtYWtlQml0Y29pblNwZW5kKGRlc3RpbmF0aW9uQWRkcmVzczogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXltZW50S2V5SW46IHN0cmluZyB8IFRyYW5zYWN0aW9uU2lnbmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnQ6IG51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnVpbGRJbmNvbXBsZXRlPzogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgaWYgKGFtb3VudCA8PSAwKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbnZhbGlkUGFyYW1ldGVyRXJyb3IoJ2Ftb3VudCcsICdhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gemVybycpKVxuICB9XG5cbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG5cbiAgY29uc3QgcGF5bWVudEtleSA9IGdldFRyYW5zYWN0aW9uU2lnbmVyKHBheW1lbnRLZXlJbilcblxuICByZXR1cm4gcGF5bWVudEtleS5nZXRBZGRyZXNzKCkudGhlbihcbiAgICBwYXltZW50QWRkcmVzcyA9PiBQcm9taXNlLmFsbChbbmV0d29yay5nZXRVVFhPcyhwYXltZW50QWRkcmVzcyksIG5ldHdvcmsuZ2V0RmVlUmF0ZSgpXSlcbiAgICAgIC50aGVuKChbdXR4b3MsIGZlZVJhdGVdKSA9PiB7XG4gICAgICAgIGNvbnN0IHR4QiA9IG5ldyBiaXRjb2luanMuVHJhbnNhY3Rpb25CdWlsZGVyKG5ldHdvcmsubGF5ZXIxKVxuICAgICAgICB0eEIuc2V0VmVyc2lvbigxKVxuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbkluZGV4ID0gdHhCLmFkZE91dHB1dChkZXN0aW5hdGlvbkFkZHJlc3MsIDApXG5cbiAgICAgICAgLy8gd2lsbCBhZGQgdXR4b3MgdXAgdG8gX2Ftb3VudF8gYW5kIHJldHVybiB0aGUgYW1vdW50IG9mIGxlZnRvdmVyIF9jaGFuZ2VfXG4gICAgICAgIGxldCBjaGFuZ2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjaGFuZ2UgPSBhZGRVVFhPc1RvRnVuZCh0eEIsIHV0eG9zLCBhbW91bnQsIGZlZVJhdGUsIGZhbHNlKVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyLm5hbWUgPT09ICdOb3RFbm91Z2hGdW5kc0Vycm9yJykge1xuICAgICAgICAgICAgLy8gYWN0dWFsIGFtb3VudCBmdW5kZWQgPSBhbW91bnQgcmVxdWVzdGVkIC0gcmVtYWluZGVyXG4gICAgICAgICAgICBhbW91bnQgLT0gZXJyLmxlZnRUb0Z1bmRcbiAgICAgICAgICAgIGNoYW5nZSA9IDBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGZlZXNUb1BheSA9IGZlZVJhdGUgKiBlc3RpbWF0ZVRYQnl0ZXModHhCLCAwLCAwKVxuICAgICAgICBjb25zdCBmZWVGb3JDaGFuZ2UgPSBmZWVSYXRlICogKGVzdGltYXRlVFhCeXRlcyh0eEIsIDAsIDEpKSAtIGZlZXNUb1BheVxuXG4gICAgICAgIC8vIGl0J3Mgd29ydGh3aGlsZSB0byBhZGQgYSBjaGFuZ2Ugb3V0cHV0XG4gICAgICAgIGlmIChjaGFuZ2UgPiBmZWVGb3JDaGFuZ2UpIHtcbiAgICAgICAgICBmZWVzVG9QYXkgKz0gZmVlRm9yQ2hhbmdlXG4gICAgICAgICAgdHhCLmFkZE91dHB1dChwYXltZW50QWRkcmVzcywgY2hhbmdlKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93IGxldCdzIGNvbXB1dGUgaG93IG11Y2ggb3V0cHV0IGlzIGxlZnRvdmVyIG9uY2Ugd2UgcGF5IHRoZSBmZWVzLlxuICAgICAgICBjb25zdCBvdXRwdXRBbW91bnQgPSBhbW91bnQgLSBmZWVzVG9QYXlcbiAgICAgICAgaWYgKG91dHB1dEFtb3VudCA8IERVU1RfTUlOSU1VTSkge1xuICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQW1vdW50RXJyb3IoZmVlc1RvUGF5LCBhbW91bnQpXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIG1hbnVhbGx5IHNldCB0aGUgb3V0cHV0IHZhbHVlcyBub3dcbiAgICAgICAgdHhCLl9fdHgub3V0c1tkZXN0aW5hdGlvbkluZGV4XS52YWx1ZSA9IG91dHB1dEFtb3VudFxuXG4gICAgICAgIC8vIHJlYWR5IHRvIHNpZ24uXG4gICAgICAgIHJldHVybiBzaWduSW5wdXRzKHR4QiwgcGF5bWVudEtleSlcbiAgICAgIH0pXG4gIClcbiAgICAudGhlbihzaWduaW5nVHhCID0+IHJldHVyblRyYW5zYWN0aW9uSGV4KHNpZ25pbmdUeEIsIGJ1aWxkSW5jb21wbGV0ZSkpXG59XG5cbmV4cG9ydCBjb25zdCB0cmFuc2FjdGlvbnMgPSB7XG4gIG1ha2VSZW5ld2FsLFxuICBtYWtlVXBkYXRlLFxuICBtYWtlUHJlb3JkZXIsXG4gIG1ha2VSZWdpc3RlcixcbiAgbWFrZVRyYW5zZmVyLFxuICBtYWtlUmV2b2tlLFxuICBtYWtlTmFtZXNwYWNlUHJlb3JkZXIsXG4gIG1ha2VOYW1lc3BhY2VSZXZlYWwsXG4gIG1ha2VOYW1lc3BhY2VSZWFkeSxcbiAgbWFrZUJpdGNvaW5TcGVuZCxcbiAgbWFrZU5hbWVJbXBvcnQsXG4gIG1ha2VBbm5vdW5jZSxcbiAgbWFrZVRva2VuVHJhbnNmZXIsXG4gIEJsb2Nrc3RhY2tOYW1lc3BhY2UsXG4gIGVzdGltYXRlUHJlb3JkZXIsXG4gIGVzdGltYXRlUmVnaXN0ZXIsXG4gIGVzdGltYXRlVHJhbnNmZXIsXG4gIGVzdGltYXRlVXBkYXRlLFxuICBlc3RpbWF0ZVJlbmV3YWwsXG4gIGVzdGltYXRlUmV2b2tlLFxuICBlc3RpbWF0ZU5hbWVzcGFjZVByZW9yZGVyLFxuICBlc3RpbWF0ZU5hbWVzcGFjZVJldmVhbCxcbiAgZXN0aW1hdGVOYW1lc3BhY2VSZWFkeSxcbiAgZXN0aW1hdGVOYW1lSW1wb3J0LFxuICBlc3RpbWF0ZUFubm91bmNlLFxuICBlc3RpbWF0ZVRva2VuVHJhbnNmZXJcbn1cbiJdfQ==