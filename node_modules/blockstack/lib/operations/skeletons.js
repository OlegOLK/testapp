"use strict";

exports.__esModule = true;
exports.makePreorderSkeleton = makePreorderSkeleton;
exports.makeRegisterSkeleton = makeRegisterSkeleton;
exports.makeRenewalSkeleton = makeRenewalSkeleton;
exports.makeTransferSkeleton = makeTransferSkeleton;
exports.makeUpdateSkeleton = makeUpdateSkeleton;
exports.makeRevokeSkeleton = makeRevokeSkeleton;
exports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;
exports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;
exports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton;
exports.makeNameImportSkeleton = makeNameImportSkeleton;
exports.makeAnnounceSkeleton = makeAnnounceSkeleton;
exports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;
exports.BlockstackNamespace = void 0;

var _bitcoinjsLib = _interopRequireDefault(require("bitcoinjs-lib"));

var _bigi = _interopRequireDefault(require("bigi"));

var _utils = require("./utils");

var _config = require("../config");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// todo : add name length / character verification
class BlockstackNamespace {
  constructor(namespaceID) {
    if (namespaceID.length > 19) {
      throw new Error('Namespace ID too long (19 chars max)');
    }

    if (!namespaceID.match('[0123456789abcdefghijklmnopqrstuvwxyz_-]+')) {
      throw new Error('Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_');
    }

    this.namespaceID = namespaceID;
    this.version = -1;
    this.lifetime = -1;
    this.coeff = -1;
    this.base = -1;
    this.buckets = [-1];
    this.nonalphaDiscount = -1;
    this.noVowelDiscount = -1;
  }

  check() {
    try {
      this.setVersion(this.version);
      this.setLifetime(this.lifetime);
      this.setCoeff(this.coeff);
      this.setBase(this.base);
      this.setBuckets(this.buckets);
      this.setNonalphaDiscount(this.nonalphaDiscount);
      this.setNoVowelDiscount(this.noVowelDiscount);
      return true;
    } catch (e) {
      return false;
    }
  }

  setVersion(version) {
    if (version < 0 || version > 2 ** 16 - 1) {
      throw new Error('Invalid version: must be a 16-bit number');
    }

    this.version = version;
  }

  setLifetime(lifetime) {
    if (lifetime < 0 || lifetime > 2 ** 32 - 1) {
      throw new Error('Invalid lifetime: must be a 32-bit number');
    }

    this.lifetime = lifetime;
  }

  setCoeff(coeff) {
    if (coeff < 0 || coeff > 255) {
      throw new Error('Invalid coeff: must be an 8-bit number');
    }

    this.coeff = coeff;
  }

  setBase(base) {
    if (base < 0 || base > 255) {
      throw new Error('Invalid base: must be an 8-bit number');
    }

    this.base = base;
  }

  setBuckets(buckets) {
    if (buckets.length !== 16) {
      throw new Error('Invalid buckets: must have 16 entries');
    }

    for (let i = 0; i < buckets.length; i++) {
      if (buckets[i] < 0 || buckets[i] > 15) {
        throw new Error('Invalid buckets: must be 4-bit numbers');
      }
    }

    this.buckets = buckets.slice(0);
  }

  setNonalphaDiscount(nonalphaDiscount) {
    if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {
      throw new Error('Invalid nonalphaDiscount: must be a positive 4-bit number');
    }

    this.nonalphaDiscount = nonalphaDiscount;
  }

  setNoVowelDiscount(noVowelDiscount) {
    if (noVowelDiscount <= 0 || noVowelDiscount > 15) {
      throw new Error('Invalid noVowelDiscount: must be a positive 4-bit number');
    }

    this.noVowelDiscount = noVowelDiscount;
  }

  toHexPayload() {
    const lifeHex = `00000000${this.lifetime.toString(16)}`.slice(-8);
    const coeffHex = `00${this.coeff.toString(16)}`.slice(-2);
    const baseHex = `00${this.base.toString(16)}`.slice(-2);
    const bucketHex = this.buckets.map(b => b.toString(16)).reduce((b1, b2) => b1 + b2, '');
    const discountHex = this.nonalphaDiscount.toString(16) + this.noVowelDiscount.toString(16);
    const versionHex = `0000${this.version.toString(16)}`.slice(-4);
    const namespaceIDHex = new Buffer(this.namespaceID).toString('hex');
    return lifeHex + coeffHex + baseHex + bucketHex + discountHex + versionHex + namespaceIDHex;
  }

}

exports.BlockstackNamespace = BlockstackNamespace;

function asAmountV2(amount) {
  // convert an AmountType v1 or v2 to an AmountTypeV2.
  // the "units" of a v1 amount type are always 'BTC'
  if (typeof amount === 'number') {
    return {
      units: 'BTC',
      amount: _bigi.default.fromByteArrayUnsigned(String(amount))
    };
  } else {
    return {
      units: amount.units,
      amount: amount.amount
    };
  }
}

function makeTXbuilder() {
  const txb = new _bitcoinjsLib.default.TransactionBuilder(_config.config.network.layer1);
  txb.setVersion(1);
  return txb;
}

function opEncode(opcode) {
  // NOTE: must *always* a 3-character string
  const res = `${_config.config.network.MAGIC_BYTES}${opcode}`;

  if (res.length !== 3) {
    throw new Error('Runtime error: invalid MAGIC_BYTES');
  }

  return res;
}

function makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burn, registerAddress = null) {
  // Returns a preorder tx skeleton.
  //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data
  //                    2. the Preorder's change address (5500 satoshi minimum)
  //                    3. the BURN
  //
  // 0     2  3                                     23             39          47            66
  // |-----|--|--------------------------------------|--------------|-----------|-------------|
  // magic op  hash160(fqn,scriptPubkey,registerAddr) consensus hash token burn  token type
  //                                                                 (optional)   (optional)
  //
  // output 0: name preorder code
  // output 1: preorder address
  // output 2: burn address
  //
  // Returns an unsigned serialized transaction.
  const burnAmount = asAmountV2(burn);
  const network = _config.config.network;
  const nameBuff = Buffer.from((0, _utils.decodeB40)(fullyQualifiedName), 'hex'); // base40

  const scriptPublicKey = _bitcoinjsLib.default.address.toOutputScript(preorderAddress, network.layer1);

  const dataBuffers = [nameBuff, scriptPublicKey];

  if (!!registerAddress) {
    const registerBuff = Buffer.from(registerAddress, 'ascii');
    dataBuffers.push(registerBuff);
  }

  const dataBuff = Buffer.concat(dataBuffers);
  const hashed = (0, _utils.hash160)(dataBuff);
  const opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;
  const opReturnBuffer = Buffer.alloc(opReturnBufferLen);
  opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');
  hashed.copy(opReturnBuffer, 3);
  opReturnBuffer.write(consensusHash, 23, 16, 'hex');

  if (burnAmount.units !== 'BTC') {
    const burnHex = burnAmount.amount.toHex();

    if (burnHex.length > 16) {
      // exceeds 2**64; can't fit
      throw new Error(`Cannot preorder '${fullyQualifiedName}': cannot fit price into 8 bytes`);
    }

    const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);
    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');
    opReturnBuffer.write(burnAmount.units, 47, burnAmount.units.length, 'ascii');
  }

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);

  if (burnAmount.units === 'BTC') {
    const btcBurnAmount = parseInt(burnAmount.amount.toHex(), 16);
    tx.addOutput(burnAddress, btcBurnAmount);
  } else {
    tx.addOutput(burnAddress, _utils.DUST_MINIMUM);
  }

  return tx.buildIncomplete();
}

function makeRegisterSkeleton(fullyQualifiedName, ownerAddress, valueHash = null, burnTokenAmountHex = null) {
  // Returns a register tx skeleton.
  //   with 2 outputs : 1. The register OP_RETURN
  //                    2. The owner address (can be different from REGISTER address on renewals)
  // You MUST make the first input a UTXO from the current OWNER *or* the
  //   funder of the PREORDER
  // in the case of a renewal, this would need to be modified to include a change address
  //  as output (3) before the burn output (4)

  /*
    Formats
     No zonefile hash, and pay with BTC:
     0    2  3                                  39
    |----|--|----------------------------------|
    magic op   name.ns_id (up to 37 bytes)
      With zonefile hash, and pay with BTC:
     0    2  3                                  39                  59
    |----|--|----------------------------------|-------------------|
    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash
     output 0: name registration code
    output 1: owner address
  */
  let payload;

  if (!!burnTokenAmountHex && !valueHash) {
    // empty value hash
    valueHash = '0000000000000000000000000000000000000000';
  }

  if (!!valueHash) {
    if (valueHash.length !== 40) {
      throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');
    }

    if (!!burnTokenAmountHex) {
      if (burnTokenAmountHex.length !== 16) {
        throw new Error('Burn field length incorrect.  Expecting 8-bytes, hex-encoded');
      }
    }

    const payloadLen = burnTokenAmountHex ? 65 : 57;
    payload = Buffer.alloc(payloadLen, 0);
    payload.write(fullyQualifiedName, 0, 37, 'ascii');
    payload.write(valueHash, 37, 20, 'hex');

    if (!!burnTokenAmountHex) {
      payload.write(burnTokenAmountHex, 57, 8, 'hex');
    }
  } else {
    payload = Buffer.from(fullyQualifiedName, 'ascii');
  }

  const opReturnBuffer = Buffer.concat([Buffer.from(opEncode(':'), 'ascii'), payload]);

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  tx.addOutput(ownerAddress, _utils.DUST_MINIMUM);
  return tx.buildIncomplete();
}

function makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burn, valueHash = null) {
  /*
    Formats
     No zonefile hash, and pay with BTC:
     0    2  3                                  39
    |----|--|----------------------------------|
    magic op   name.ns_id (up to 37 bytes)
      With zonefile hash, and pay with BTC:
     0    2  3                                  39                  59
    |----|--|----------------------------------|-------------------|
    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash
     With renewal payment in a token:
   (for register, tokens burned is not included)
   (for renew, tokens burned is the number of tokens to burn)
    0    2  3                                  39                  59                            67
   |----|--|----------------------------------|-------------------|------------------------------|
   magic op   name.ns_id (37 bytes, 0-padded)     zone file hash    tokens burned (big-endian)
    output 0: renewal code
   output 1: new owner address
   output 2: current owner address
   output 3: burn address
  */
  const burnAmount = asAmountV2(burn);
  const network = _config.config.network;
  const burnTokenAmount = burnAmount.units === 'BTC' ? null : burnAmount.amount;
  const burnBTCAmount = burnAmount.units === 'BTC' ? parseInt(burnAmount.amount.toHex(), 16) : _utils.DUST_MINIMUM;
  let burnTokenHex = null;

  if (!!burnTokenAmount) {
    const burnHex = burnTokenAmount.toHex();

    if (burnHex.length > 16) {
      // exceeds 2**64; can't fit 
      throw new Error(`Cannot renew '${fullyQualifiedName}': cannot fit price into 8 bytes`);
    }

    burnTokenHex = `0000000000000000${burnHex}`.slice(-16);
  }

  const registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash, burnTokenHex);

  const txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(registerTX, network.layer1);

  txB.addOutput(lastOwnerAddress, _utils.DUST_MINIMUM);
  txB.addOutput(burnAddress, burnBTCAmount);
  return txB.buildIncomplete();
}

function makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner, keepZonefile = false) {
  // Returns a transfer tx skeleton.
  //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data
  //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)
  //
  // You MUST make the first input a UTXO from the current OWNER
  //
  // Returns an unsigned serialized transaction.

  /*
    Format
     0     2  3    4                   20              36
    |-----|--|----|-------------------|---------------|
    magic op keep  hash128(name.ns_id) consensus hash
             data?
     output 0: transfer code
    output 1: new owner
  */
  const opRet = Buffer.alloc(36);
  let keepChar = '~';

  if (keepZonefile) {
    keepChar = '>';
  }

  opRet.write(opEncode('>'), 0, 3, 'ascii');
  opRet.write(keepChar, 3, 1, 'ascii');
  const hashed = (0, _utils.hash128)(Buffer.from(fullyQualifiedName, 'ascii'));
  hashed.copy(opRet, 4);
  opRet.write(consensusHash, 20, 16, 'hex');

  const opRetPayload = _bitcoinjsLib.default.payments.embed({
    data: [opRet]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(opRetPayload, 0);
  tx.addOutput(newOwner, _utils.DUST_MINIMUM);
  return tx.buildIncomplete();
}

function makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {
  // Returns an update tx skeleton.
  //   with 1 output : 1. the Blockstack update OP_RETURN
  //
  // You MUST make the first input a UTXO from the current OWNER
  //
  // Returns an unsigned serialized transaction.
  //
  // output 0: the revoke code

  /*
    Format:
     0     2  3                                   19                      39
    |-----|--|-----------------------------------|-----------------------|
    magic op  hash128(name.ns_id,consensus hash) hash160(data)
     output 0: update code
  */
  const opRet = Buffer.alloc(39);
  const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
  const consensusBuff = Buffer.from(consensusHash, 'ascii');
  const hashedName = (0, _utils.hash128)(Buffer.concat([nameBuff, consensusBuff]));
  opRet.write(opEncode('+'), 0, 3, 'ascii');
  hashedName.copy(opRet, 3);
  opRet.write(valueHash, 19, 20, 'hex');

  const opRetPayload = _bitcoinjsLib.default.payments.embed({
    data: [opRet]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(opRetPayload, 0);
  return tx.buildIncomplete();
}

function makeRevokeSkeleton(fullyQualifiedName) {
  // Returns a revoke tx skeleton
  //    with 1 output: 1. the Blockstack revoke OP_RETURN
  //
  // You MUST make the first input a UTXO from the current OWNER
  //
  // Returns an unsigned serialized transaction

  /*
   Format:
    0    2  3                             39
   |----|--|-----------------------------|
   magic op   name.ns_id (37 bytes)
    output 0: the revoke code
  */
  const opRet = Buffer.alloc(3);
  const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');
  opRet.write(opEncode('~'), 0, 3, 'ascii');
  const opReturnBuffer = Buffer.concat([opRet, nameBuff]);

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  return tx.buildIncomplete();
}

function makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, registerAddress, burn) {
  // Returns a namespace preorder tx skeleton.
  // Returns an unsigned serialized transaction.

  /*
   Formats:
    Without STACKS:
    0     2   3                                      23               39
   |-----|---|--------------------------------------|----------------|
   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash
     with STACKs:
    0     2   3                                      23               39                         47
   |-----|---|--------------------------------------|----------------|--------------------------|
   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash    token fee (big-endian)
    output 0: namespace preorder code
   output 1: change address
   otuput 2: burn address
  */
  const burnAmount = asAmountV2(burn);

  if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {
    throw new Error(`Invalid burnUnits ${burnAmount.units}`);
  }

  const network = _config.config.network;
  const burnAddress = network.getDefaultBurnAddress();
  const namespaceIDBuff = Buffer.from((0, _utils.decodeB40)(namespaceID), 'hex'); // base40

  const scriptPublicKey = _bitcoinjsLib.default.address.toOutputScript(preorderAddress, network.layer1);

  const registerBuff = Buffer.from(registerAddress, 'ascii');
  const dataBuffers = [namespaceIDBuff, scriptPublicKey, registerBuff];
  const dataBuff = Buffer.concat(dataBuffers);
  const hashed = (0, _utils.hash160)(dataBuff);
  let btcBurnAmount = _utils.DUST_MINIMUM;
  let opReturnBufferLen = 39;

  if (burnAmount.units === 'STACKS') {
    opReturnBufferLen = 47;
  } else {
    btcBurnAmount = parseInt(burnAmount.amount.toHex(), 16);
  }

  const opReturnBuffer = Buffer.alloc(opReturnBufferLen);
  opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');
  hashed.copy(opReturnBuffer, 3);
  opReturnBuffer.write(consensusHash, 23, 16, 'hex');

  if (burnAmount.units === 'STACKS') {
    const burnHex = burnAmount.amount.toHex();
    const paddedBurnHex = `0000000000000000${burnHex}`.slice(-16);
    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');
  }

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);
  tx.addOutput(burnAddress, btcBurnAmount);
  return tx.buildIncomplete();
}

function makeNamespaceRevealSkeleton(namespace, revealAddress) {
  /*
   Format:
    0     2   3    7     8     9    10   11   12   13   14    15    16    17       18      20     39
   |-----|---|----|-----|-----|----|----|----|----|----|-----|-----|-----|--------|-------|-------|
   magic  op  life coeff. base 1-2  3-4  5-6  7-8  9-10 11-12 13-14 15-16 nonalpha version  ns ID
                                                  bucket exponents        no-vowel
                                                                          discounts
   
   output 0: namespace reveal code
   output 1: reveal address
  */
  const hexPayload = namespace.toHexPayload();
  const opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);
  opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');
  opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  tx.addOutput(revealAddress, _utils.DUST_MINIMUM);
  return tx.buildIncomplete();
}

function makeNamespaceReadySkeleton(namespaceID) {
  /*
   Format:
    0     2  3  4           23
   |-----|--|--|------------|
   magic op  .  ns_id
    output 0: namespace ready code
   */
  const opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);
  opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');
  opReturnBuffer.write(`.${namespaceID}`, 3, namespaceID.length + 1, 'ascii');

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  return tx.buildIncomplete();
}

function makeNameImportSkeleton(name, recipientAddr, zonefileHash) {
  /*
   Format:
     0    2  3                             39
    |----|--|-----------------------------|
    magic op   name.ns_id (37 bytes)
    Output 0: the OP_RETURN
   Output 1: the recipient
   Output 2: the zonefile hash
  */
  if (zonefileHash.length !== 40) {
    throw new Error('Invalid zonefile hash: must be 20 bytes hex-encoded');
  }

  const network = _config.config.network;
  const opReturnBuffer = Buffer.alloc(3 + name.length);
  opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');
  opReturnBuffer.write(name, 3, name.length, 'ascii');

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();

  const zonefileHashB58 = _bitcoinjsLib.default.address.toBase58Check(new Buffer(zonefileHash, 'hex'), network.layer1.pubKeyHash);

  tx.addOutput(nullOutput, 0);
  tx.addOutput(recipientAddr, _utils.DUST_MINIMUM);
  tx.addOutput(zonefileHashB58, _utils.DUST_MINIMUM);
  return tx.buildIncomplete();
}

function makeAnnounceSkeleton(messageHash) {
  /*
    Format:
     0    2  3                             23
    |----|--|-----------------------------|
    magic op   message hash (160-bit)
     output 0: the OP_RETURN
  */
  if (messageHash.length !== 40) {
    throw new Error('Invalid message hash: must be 20 bytes hex-encoded');
  }

  const opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);
  opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');
  opReturnBuffer.write(messageHash, 3, messageHash.length / 2, 'hex');

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  return tx.buildIncomplete();
}

function makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea) {
  /*
   Format:
     0     2  3              19         38          46                        80
    |-----|--|--------------|----------|-----------|-------------------------|
    magic op  consensus_hash token_type amount (BE) scratch area
                             (ns_id)
     output 0: token transfer code
    output 1: recipient address
  */
  if (scratchArea.length > 34) {
    throw new Error('Invalid scratch area: must be no more than 34 bytes');
  }

  const opReturnBuffer = Buffer.alloc(46 + scratchArea.length);
  const tokenTypeHex = new Buffer(tokenType).toString('hex');
  const tokenTypeHexPadded = `00000000000000000000000000000000000000${tokenTypeHex}`.slice(-38);
  const tokenValueHex = tokenAmount.toHex();

  if (tokenValueHex.length > 16) {
    // exceeds 2**64; can't fit
    throw new Error(`Cannot send tokens: cannot fit ${tokenAmount.toString()} into 8 bytes`);
  }

  const tokenValueHexPadded = `0000000000000000${tokenValueHex}`.slice(-16);
  opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');
  opReturnBuffer.write(consensusHash, 3, consensusHash.length / 2, 'hex');
  opReturnBuffer.write(tokenTypeHexPadded, 19, tokenTypeHexPadded.length / 2, 'hex');
  opReturnBuffer.write(tokenValueHexPadded, 38, tokenValueHexPadded.length / 2, 'hex');
  opReturnBuffer.write(scratchArea, 46, scratchArea.length, 'ascii');

  const nullOutput = _bitcoinjsLib.default.payments.embed({
    data: [opReturnBuffer]
  }).output;

  const tx = makeTXbuilder();
  tx.addOutput(nullOutput, 0);
  tx.addOutput(recipientAddress, _utils.DUST_MINIMUM);
  return tx.buildIncomplete();
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9vcGVyYXRpb25zL3NrZWxldG9ucy5qcyJdLCJuYW1lcyI6WyJCbG9ja3N0YWNrTmFtZXNwYWNlIiwiY29uc3RydWN0b3IiLCJuYW1lc3BhY2VJRCIsImxlbmd0aCIsIkVycm9yIiwibWF0Y2giLCJ2ZXJzaW9uIiwibGlmZXRpbWUiLCJjb2VmZiIsImJhc2UiLCJidWNrZXRzIiwibm9uYWxwaGFEaXNjb3VudCIsIm5vVm93ZWxEaXNjb3VudCIsImNoZWNrIiwic2V0VmVyc2lvbiIsInNldExpZmV0aW1lIiwic2V0Q29lZmYiLCJzZXRCYXNlIiwic2V0QnVja2V0cyIsInNldE5vbmFscGhhRGlzY291bnQiLCJzZXROb1Zvd2VsRGlzY291bnQiLCJlIiwiaSIsInNsaWNlIiwidG9IZXhQYXlsb2FkIiwibGlmZUhleCIsInRvU3RyaW5nIiwiY29lZmZIZXgiLCJiYXNlSGV4IiwiYnVja2V0SGV4IiwibWFwIiwiYiIsInJlZHVjZSIsImIxIiwiYjIiLCJkaXNjb3VudEhleCIsInZlcnNpb25IZXgiLCJuYW1lc3BhY2VJREhleCIsIkJ1ZmZlciIsImFzQW1vdW50VjIiLCJhbW91bnQiLCJ1bml0cyIsIkJpZ0ludGVnZXIiLCJmcm9tQnl0ZUFycmF5VW5zaWduZWQiLCJTdHJpbmciLCJtYWtlVFhidWlsZGVyIiwidHhiIiwiYml0Y29pbiIsIlRyYW5zYWN0aW9uQnVpbGRlciIsImNvbmZpZyIsIm5ldHdvcmsiLCJsYXllcjEiLCJvcEVuY29kZSIsIm9wY29kZSIsInJlcyIsIk1BR0lDX0JZVEVTIiwibWFrZVByZW9yZGVyU2tlbGV0b24iLCJmdWxseVF1YWxpZmllZE5hbWUiLCJjb25zZW5zdXNIYXNoIiwicHJlb3JkZXJBZGRyZXNzIiwiYnVybkFkZHJlc3MiLCJidXJuIiwicmVnaXN0ZXJBZGRyZXNzIiwiYnVybkFtb3VudCIsIm5hbWVCdWZmIiwiZnJvbSIsInNjcmlwdFB1YmxpY0tleSIsImFkZHJlc3MiLCJ0b091dHB1dFNjcmlwdCIsImRhdGFCdWZmZXJzIiwicmVnaXN0ZXJCdWZmIiwicHVzaCIsImRhdGFCdWZmIiwiY29uY2F0IiwiaGFzaGVkIiwib3BSZXR1cm5CdWZmZXJMZW4iLCJvcFJldHVybkJ1ZmZlciIsImFsbG9jIiwid3JpdGUiLCJjb3B5IiwiYnVybkhleCIsInRvSGV4IiwicGFkZGVkQnVybkhleCIsIm51bGxPdXRwdXQiLCJwYXltZW50cyIsImVtYmVkIiwiZGF0YSIsIm91dHB1dCIsInR4IiwiYWRkT3V0cHV0IiwiRFVTVF9NSU5JTVVNIiwiYnRjQnVybkFtb3VudCIsInBhcnNlSW50IiwiYnVpbGRJbmNvbXBsZXRlIiwibWFrZVJlZ2lzdGVyU2tlbGV0b24iLCJvd25lckFkZHJlc3MiLCJ2YWx1ZUhhc2giLCJidXJuVG9rZW5BbW91bnRIZXgiLCJwYXlsb2FkIiwicGF5bG9hZExlbiIsIm1ha2VSZW5ld2FsU2tlbGV0b24iLCJuZXh0T3duZXJBZGRyZXNzIiwibGFzdE93bmVyQWRkcmVzcyIsImJ1cm5Ub2tlbkFtb3VudCIsImJ1cm5CVENBbW91bnQiLCJidXJuVG9rZW5IZXgiLCJyZWdpc3RlclRYIiwidHhCIiwiZnJvbVRyYW5zYWN0aW9uIiwibWFrZVRyYW5zZmVyU2tlbGV0b24iLCJuZXdPd25lciIsImtlZXBab25lZmlsZSIsIm9wUmV0Iiwia2VlcENoYXIiLCJvcFJldFBheWxvYWQiLCJtYWtlVXBkYXRlU2tlbGV0b24iLCJjb25zZW5zdXNCdWZmIiwiaGFzaGVkTmFtZSIsIm1ha2VSZXZva2VTa2VsZXRvbiIsIm1ha2VOYW1lc3BhY2VQcmVvcmRlclNrZWxldG9uIiwiZ2V0RGVmYXVsdEJ1cm5BZGRyZXNzIiwibmFtZXNwYWNlSURCdWZmIiwibWFrZU5hbWVzcGFjZVJldmVhbFNrZWxldG9uIiwibmFtZXNwYWNlIiwicmV2ZWFsQWRkcmVzcyIsImhleFBheWxvYWQiLCJtYWtlTmFtZXNwYWNlUmVhZHlTa2VsZXRvbiIsIm1ha2VOYW1lSW1wb3J0U2tlbGV0b24iLCJuYW1lIiwicmVjaXBpZW50QWRkciIsInpvbmVmaWxlSGFzaCIsInpvbmVmaWxlSGFzaEI1OCIsInRvQmFzZTU4Q2hlY2siLCJwdWJLZXlIYXNoIiwibWFrZUFubm91bmNlU2tlbGV0b24iLCJtZXNzYWdlSGFzaCIsIm1ha2VUb2tlblRyYW5zZmVyU2tlbGV0b24iLCJyZWNpcGllbnRBZGRyZXNzIiwidG9rZW5UeXBlIiwidG9rZW5BbW91bnQiLCJzY3JhdGNoQXJlYSIsInRva2VuVHlwZUhleCIsInRva2VuVHlwZUhleFBhZGRlZCIsInRva2VuVmFsdWVIZXgiLCJ0b2tlblZhbHVlSGV4UGFkZGVkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUVBOztBQUNBOztBQUNBOztBQUdBOzs7O0FBT0E7QUFFTyxNQUFNQSxtQkFBTixDQUEwQjtBQWlCL0JDLEVBQUFBLFdBQVcsQ0FBQ0MsV0FBRCxFQUFzQjtBQUMvQixRQUFJQSxXQUFXLENBQUNDLE1BQVosR0FBcUIsRUFBekIsRUFBNkI7QUFDM0IsWUFBTSxJQUFJQyxLQUFKLENBQVUsc0NBQVYsQ0FBTjtBQUNEOztBQUNELFFBQUksQ0FBQ0YsV0FBVyxDQUFDRyxLQUFaLENBQWtCLDJDQUFsQixDQUFMLEVBQXFFO0FBQ25FLFlBQU0sSUFBSUQsS0FBSixDQUFVLDZFQUFWLENBQU47QUFDRDs7QUFFRCxTQUFLRixXQUFMLEdBQW1CQSxXQUFuQjtBQUNBLFNBQUtJLE9BQUwsR0FBZSxDQUFDLENBQWhCO0FBQ0EsU0FBS0MsUUFBTCxHQUFnQixDQUFDLENBQWpCO0FBQ0EsU0FBS0MsS0FBTCxHQUFhLENBQUMsQ0FBZDtBQUNBLFNBQUtDLElBQUwsR0FBWSxDQUFDLENBQWI7QUFDQSxTQUFLQyxPQUFMLEdBQWUsQ0FBQyxDQUFDLENBQUYsQ0FBZjtBQUNBLFNBQUtDLGdCQUFMLEdBQXdCLENBQUMsQ0FBekI7QUFDQSxTQUFLQyxlQUFMLEdBQXVCLENBQUMsQ0FBeEI7QUFDRDs7QUFFREMsRUFBQUEsS0FBSyxHQUFHO0FBQ04sUUFBSTtBQUNGLFdBQUtDLFVBQUwsQ0FBZ0IsS0FBS1IsT0FB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RUFBdUNBLGFBQWEsQ0FBQ3ZELE1BQWQsR0FBdUIsQ0FBOUQsRUFBaUUsS0FBakU7QUFDQXlFLEVBQUFBLGNBQWMsQ0FBQ0UsS0FBZixDQUFxQmdFLGtCQUFyQixFQUF5QyxFQUF6QyxFQUE2Q0Esa0JBQWtCLENBQUMzSSxNQUFuQixHQUE0QixDQUF6RSxFQUE0RSxLQUE1RTtBQUNBeUUsRUFBQUEsY0FBYyxDQUFDRSxLQUFmLENBQXFCa0UsbUJBQXJCLEVBQTBDLEVBQTFDLEVBQThDQSxtQkFBbUIsQ0FBQzdJLE1BQXBCLEdBQTZCLENBQTNFLEVBQThFLEtBQTlFO0FBQ0F5RSxFQUFBQSxjQUFjLENBQUNFLEtBQWYsQ0FBcUI4RCxXQUFyQixFQUFrQyxFQUFsQyxFQUFzQ0EsV0FBVyxDQUFDekksTUFBbEQsRUFBMEQsT0FBMUQ7O0FBRUEsUUFBTWdGLFVBQVUsR0FBR3BDLHNCQUFRcUMsUUFBUixDQUFpQkMsS0FBakIsQ0FBdUI7QUFBRUMsSUFBQUEsSUFBSSxFQUFFLENBQUNWLGNBQUQ7QUFBUixHQUF2QixFQUFtRFcsTUFBdEU7O0FBQ0EsUUFBTUMsRUFBRSxHQUFHM0MsYUFBYSxFQUF4QjtBQUVBMkMsRUFBQUEsRUFBRSxDQUFDQyxTQUFILENBQWFOLFVBQWIsRUFBeUIsQ0FBekI7QUFDQUssRUFBQUEsRUFBRSxDQUFDQyxTQUFILENBQWFnRCxnQkFBYixFQUErQi9DLG1CQUEvQjtBQUVBLFNBQU9GLEVBQUUsQ0FBQ0ssZUFBSCxFQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5pbXBvcnQgYml0Y29pbiBmcm9tICdiaXRjb2luanMtbGliJ1xuaW1wb3J0IEJpZ0ludGVnZXIgZnJvbSAnYmlnaSdcbmltcG9ydCB7XG4gIGRlY29kZUI0MCwgaGFzaDE2MCwgaGFzaDEyOCwgRFVTVF9NSU5JTVVNXG59IGZyb20gJy4vdXRpbHMnXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tICcuLi9jb25maWcnXG5cbi8vIHN1cHBvcnQgdjEgYW5kIHYyIHByaWNlIEFQSSBlbmRwb2ludCByZXR1cm4gdmFsdWVzXG50eXBlIEFtb3VudFR5cGVWMSA9IG51bWJlclxudHlwZSBBbW91bnRUeXBlVjIgPSB7IHVuaXRzOiBzdHJpbmcsIGFtb3VudDogQmlnSW50ZWdlciB9XG50eXBlIEFtb3VudFR5cGUgPSBBbW91bnRUeXBlVjEgfCBBbW91bnRUeXBlVjJcblxuLy8gdG9kbyA6IGFkZCBuYW1lIGxlbmd0aCAvIGNoYXJhY3RlciB2ZXJpZmljYXRpb25cblxuZXhwb3J0IGNsYXNzIEJsb2Nrc3RhY2tOYW1lc3BhY2Uge1xuICBuYW1lc3BhY2VJRDogc3RyaW5nXG5cbiAgdmVyc2lvbjogbnVtYmVyXG5cbiAgbGlmZXRpbWU6IG51bWJlclxuXG4gIGNvZWZmOiBudW1iZXJcblxuICBiYXNlOiBudW1iZXJcblxuICBidWNrZXRzOiBBcnJheTxudW1iZXI+XG5cbiAgbm9uYWxwaGFEaXNjb3VudDogbnVtYmVyXG5cbiAgbm9Wb3dlbERpc2NvdW50OiBudW1iZXJcblxuICBjb25zdHJ1Y3RvcihuYW1lc3BhY2VJRDogc3RyaW5nKSB7XG4gICAgaWYgKG5hbWVzcGFjZUlELmxlbmd0aCA+IDE5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hbWVzcGFjZSBJRCB0b28gbG9uZyAoMTkgY2hhcnMgbWF4KScpXG4gICAgfVxuICAgIGlmICghbmFtZXNwYWNlSUQubWF0Y2goJ1swMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpfLV0rJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTmFtZXNwYWNlIElEIGNhbiBvbmx5IHVzZSBjaGFyYWN0ZXJzIDAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fJylcbiAgICB9XG5cbiAgICB0aGlzLm5hbWVzcGFjZUlEID0gbmFtZXNwYWNlSURcbiAgICB0aGlzLnZlcnNpb24gPSAtMVxuICAgIHRoaXMubGlmZXRpbWUgPSAtMVxuICAgIHRoaXMuY29lZmYgPSAtMVxuICAgIHRoaXMuYmFzZSA9IC0xXG4gICAgdGhpcy5idWNrZXRzID0gWy0xXVxuICAgIHRoaXMubm9uYWxwaGFEaXNjb3VudCA9IC0xXG4gICAgdGhpcy5ub1Zvd2VsRGlzY291bnQgPSAtMVxuICB9XG5cbiAgY2hlY2soKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuc2V0VmVyc2lvbih0aGlzLnZlcnNpb24pXG4gICAgICB0aGlzLnNldExpZmV0aW1lKHRoaXMubGlmZXRpbWUpXG4gICAgICB0aGlzLnNldENvZWZmKHRoaXMuY29lZmYpXG4gICAgICB0aGlzLnNldEJhc2UodGhpcy5iYXNlKVxuICAgICAgdGhpcy5zZXRCdWNrZXRzKHRoaXMuYnVja2V0cylcbiAgICAgIHRoaXMuc2V0Tm9uYWxwaGFEaXNjb3VudCh0aGlzLm5vbmFscGhhRGlzY291bnQpXG4gICAgICB0aGlzLnNldE5vVm93ZWxEaXNjb3VudCh0aGlzLm5vVm93ZWxEaXNjb3VudClcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgc2V0VmVyc2lvbih2ZXJzaW9uOiBudW1iZXIpIHtcbiAgICBpZiAodmVyc2lvbiA8IDAgfHwgdmVyc2lvbiA+IDIgKiogMTYgLSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVyc2lvbjogbXVzdCBiZSBhIDE2LWJpdCBudW1iZXInKVxuICAgIH1cbiAgICB0aGlzLnZlcnNpb24gPSB2ZXJzaW9uXG4gIH1cblxuICBzZXRMaWZldGltZShsaWZldGltZTogbnVtYmVyKSB7XG4gICAgaWYgKGxpZmV0aW1lIDwgMCB8fCBsaWZldGltZSA+IDIgKiogMzIgLSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlmZXRpbWU6IG11c3QgYmUgYSAzMi1iaXQgbnVtYmVyJylcbiAgICB9XG4gICAgdGhpcy5saWZldGltZSA9IGxpZmV0aW1lXG4gIH1cblxuICBzZXRDb2VmZihjb2VmZjogbnVtYmVyKSB7XG4gICAgaWYgKGNvZWZmIDwgMCB8fCBjb2VmZiA+IDI1NSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZWZmOiBtdXN0IGJlIGFuIDgtYml0IG51bWJlcicpXG4gICAgfVxuICAgIHRoaXMuY29lZmYgPSBjb2VmZlxuICB9XG5cbiAgc2V0QmFzZShiYXNlOiBudW1iZXIpIHtcbiAgICBpZiAoYmFzZSA8IDAgfHwgYmFzZSA+IDI1NSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJhc2U6IG11c3QgYmUgYW4gOC1iaXQgbnVtYmVyJylcbiAgICB9XG4gICAgdGhpcy5iYXNlID0gYmFzZVxuICB9XG5cbiAgc2V0QnVja2V0cyhidWNrZXRzOiBBcnJheTxudW1iZXI+KSB7XG4gICAgaWYgKGJ1Y2tldHMubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1Y2tldHM6IG11c3QgaGF2ZSAxNiBlbnRyaWVzJylcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Y2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChidWNrZXRzW2ldIDwgMCB8fCBidWNrZXRzW2ldID4gMTUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ1Y2tldHM6IG11c3QgYmUgNC1iaXQgbnVtYmVycycpXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5idWNrZXRzID0gYnVja2V0cy5zbGljZSgwKVxuICB9XG5cbiAgc2V0Tm9uYWxwaGFEaXNjb3VudChub25hbHBoYURpc2NvdW50OiBudW1iZXIpIHtcbiAgICBpZiAobm9uYWxwaGFEaXNjb3VudCA8PSAwIHx8IG5vbmFscGhhRGlzY291bnQgPiAxNSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG5vbmFscGhhRGlzY291bnQ6IG11c3QgYmUgYSBwb3NpdGl2ZSA0LWJpdCBudW1iZXInKVxuICAgIH1cbiAgICB0aGlzLm5vbmFscGhhRGlzY291bnQgPSBub25hbHBoYURpc2NvdW50XG4gIH1cblxuICBzZXROb1Zvd2VsRGlzY291bnQobm9Wb3dlbERpc2NvdW50OiBudW1iZXIpIHtcbiAgICBpZiAobm9Wb3dlbERpc2NvdW50IDw9IDAgfHwgbm9Wb3dlbERpc2NvdW50ID4gMTUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBub1Zvd2VsRGlzY291bnQ6IG11c3QgYmUgYSBwb3NpdGl2ZSA0LWJpdCBudW1iZXInKVxuICAgIH1cbiAgICB0aGlzLm5vVm93ZWxEaXNjb3VudCA9IG5vVm93ZWxEaXNjb3VudFxuICB9XG5cbiAgdG9IZXhQYXlsb2FkKCkge1xuICAgIGNvbnN0IGxpZmVIZXggPSBgMDAwMDAwMDAke3RoaXMubGlmZXRpbWUudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTgpXG4gICAgY29uc3QgY29lZmZIZXggPSBgMDAke3RoaXMuY29lZmYudG9TdHJpbmcoMTYpfWAuc2xpY2UoLTIpXG4gICAgY29uc3QgYmFzZUhleCA9IGAwMCR7dGhpcy5iYXNlLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKVxuICAgIGNvbnN0IGJ1Y2tldEhleCA9IHRoaXMuYnVja2V0cy5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KSkucmVkdWNlKChiMSwgYjIpID0+IGIxICsgYjIsICcnKVxuICAgIGNvbnN0IGRpc2NvdW50SGV4ID0gdGhpcy5ub25hbHBoYURpc2NvdW50LnRvU3RyaW5nKDE2KSArIHRoaXMubm9Wb3dlbERpc2NvdW50LnRvU3RyaW5nKDE2KVxuICAgIGNvbnN0IHZlcnNpb25IZXggPSBgMDAwMCR7dGhpcy52ZXJzaW9uLnRvU3RyaW5nKDE2KX1gLnNsaWNlKC00KVxuICAgIGNvbnN0IG5hbWVzcGFjZUlESGV4ID0gbmV3IEJ1ZmZlcih0aGlzLm5hbWVzcGFjZUlEKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiBsaWZlSGV4ICsgY29lZmZIZXggKyBiYXNlSGV4ICsgYnVja2V0SGV4ICsgZGlzY291bnRIZXggKyB2ZXJzaW9uSGV4ICsgbmFtZXNwYWNlSURIZXhcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGFzQW1vdW50VjIoYW1vdW50OiBBbW91bnRUeXBlKTogQW1vdW50VHlwZVYyIHtcbiAgLy8gY29udmVydCBhbiBBbW91bnRUeXBlIHYxIG9yIHYyIHRvIGFuIEFtb3VudFR5cGVWMi5cbiAgLy8gdGhlIFwidW5pdHNcIiBvZiBhIHYxIGFtb3VudCB0eXBlIGFyZSBhbHdheXMgJ0JUQydcbiAgaWYgKHR5cGVvZiBhbW91bnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHsgdW5pdHM6ICdCVEMnLCBhbW91bnQ6IEJpZ0ludGVnZXIuZnJvbUJ5dGVBcnJheVVuc2lnbmVkKFN0cmluZyhhbW91bnQpKSB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgdW5pdHM6IGFtb3VudC51bml0cywgYW1vdW50OiBhbW91bnQuYW1vdW50IH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlVFhidWlsZGVyKCkge1xuICBjb25zdCB0eGIgPSBuZXcgYml0Y29pbi5UcmFuc2FjdGlvbkJ1aWxkZXIoY29uZmlnLm5ldHdvcmsubGF5ZXIxKVxuICB0eGIuc2V0VmVyc2lvbigxKVxuICByZXR1cm4gdHhiXG59XG5cbmZ1bmN0aW9uIG9wRW5jb2RlKG9wY29kZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gTk9URTogbXVzdCAqYWx3YXlzKiBhIDMtY2hhcmFjdGVyIHN0cmluZ1xuICBjb25zdCByZXMgPSBgJHtjb25maWcubmV0d29yay5NQUdJQ19CWVRFU30ke29wY29kZX1gXG4gIGlmIChyZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSdW50aW1lIGVycm9yOiBpbnZhbGlkIE1BR0lDX0JZVEVTJylcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUHJlb3JkZXJTa2VsZXRvbihcbiAgZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcsIGNvbnNlbnN1c0hhc2ggOiBzdHJpbmcsIHByZW9yZGVyQWRkcmVzczogc3RyaW5nLFxuICBidXJuQWRkcmVzcyA6IHN0cmluZywgYnVybjogQW1vdW50VHlwZSxcbiAgcmVnaXN0ZXJBZGRyZXNzOiA/c3RyaW5nID0gbnVsbFxuKSB7XG4gIC8vIFJldHVybnMgYSBwcmVvcmRlciB0eCBza2VsZXRvbi5cbiAgLy8gICB3aXRoIDMgb3V0cHV0cyA6IDEuIHRoZSBCbG9ja3N0YWNrIFByZW9yZGVyIE9QX1JFVFVSTiBkYXRhXG4gIC8vICAgICAgICAgICAgICAgICAgICAyLiB0aGUgUHJlb3JkZXIncyBjaGFuZ2UgYWRkcmVzcyAoNTUwMCBzYXRvc2hpIG1pbmltdW0pXG4gIC8vICAgICAgICAgICAgICAgICAgICAzLiB0aGUgQlVSTlxuICAvL1xuICAvLyAwICAgICAyICAzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIzICAgICAgICAgICAgIDM5ICAgICAgICAgIDQ3ICAgICAgICAgICAgNjZcbiAgLy8gfC0tLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS18XG4gIC8vIG1hZ2ljIG9wICBoYXNoMTYwKGZxbixzY3JpcHRQdWJrZXkscmVnaXN0ZXJBZGRyKSBjb25zZW5zdXMgaGFzaCB0b2tlbiBidXJuICB0b2tlbiB0eXBlXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAob3B0aW9uYWwpICAgKG9wdGlvbmFsKVxuICAvL1xuICAvLyBvdXRwdXQgMDogbmFtZSBwcmVvcmRlciBjb2RlXG4gIC8vIG91dHB1dCAxOiBwcmVvcmRlciBhZGRyZXNzXG4gIC8vIG91dHB1dCAyOiBidXJuIGFkZHJlc3NcbiAgLy9cbiAgLy8gUmV0dXJucyBhbiB1bnNpZ25lZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICBjb25zdCBidXJuQW1vdW50ID0gYXNBbW91bnRWMihidXJuKVxuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcbiAgY29uc3QgbmFtZUJ1ZmYgPSBCdWZmZXIuZnJvbShkZWNvZGVCNDAoZnVsbHlRdWFsaWZpZWROYW1lKSwgJ2hleCcpIC8vIGJhc2U0MFxuICBjb25zdCBzY3JpcHRQdWJsaWNLZXkgPSBiaXRjb2luLmFkZHJlc3MudG9PdXRwdXRTY3JpcHQocHJlb3JkZXJBZGRyZXNzLCBuZXR3b3JrLmxheWVyMSlcblxuICBjb25zdCBkYXRhQnVmZmVycyA9IFtuYW1lQnVmZiwgc2NyaXB0UHVibGljS2V5XVxuXG4gIGlmICghIXJlZ2lzdGVyQWRkcmVzcykge1xuICAgIGNvbnN0IHJlZ2lzdGVyQnVmZiA9IEJ1ZmZlci5mcm9tKHJlZ2lzdGVyQWRkcmVzcywgJ2FzY2lpJylcbiAgICBkYXRhQnVmZmVycy5wdXNoKHJlZ2lzdGVyQnVmZilcbiAgfVxuXG4gIGNvbnN0IGRhdGFCdWZmID0gQnVmZmVyLmNvbmNhdChkYXRhQnVmZmVycylcblxuICBjb25zdCBoYXNoZWQgPSBoYXNoMTYwKGRhdGFCdWZmKVxuXG4gIGNvbnN0IG9wUmV0dXJuQnVmZmVyTGVuID0gYnVybkFtb3VudC51bml0cyA9PT0gJ0JUQycgPyAzOSA6IDY2XG4gIGNvbnN0IG9wUmV0dXJuQnVmZmVyID0gQnVmZmVyLmFsbG9jKG9wUmV0dXJuQnVmZmVyTGVuKVxuICBvcFJldHVybkJ1ZmZlci53cml0ZShvcEVuY29kZSgnPycpLCAwLCAzLCAnYXNjaWknKVxuICBoYXNoZWQuY29weShvcFJldHVybkJ1ZmZlciwgMylcbiAgb3BSZXR1cm5CdWZmZXIud3JpdGUoY29uc2Vuc3VzSGFzaCwgMjMsIDE2LCAnaGV4JylcblxuICBpZiAoYnVybkFtb3VudC51bml0cyAhPT0gJ0JUQycpIHtcbiAgICBjb25zdCBidXJuSGV4ID0gYnVybkFtb3VudC5hbW91bnQudG9IZXgoKVxuICAgIGlmIChidXJuSGV4Lmxlbmd0aCA+IDE2KSB7XG4gICAgICAvLyBleGNlZWRzIDIqKjY0OyBjYW4ndCBmaXRcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHByZW9yZGVyICcke2Z1bGx5UXVhbGlmaWVkTmFtZX0nOiBjYW5ub3QgZml0IHByaWNlIGludG8gOCBieXRlc2ApXG4gICAgfVxuICAgIGNvbnN0IHBhZGRlZEJ1cm5IZXggPSBgMDAwMDAwMDAwMDAwMDAwMCR7YnVybkhleH1gLnNsaWNlKC0xNilcblxuICAgIG9wUmV0dXJuQnVmZmVyLndyaXRlKHBhZGRlZEJ1cm5IZXgsIDM5LCA4LCAnaGV4JylcbiAgICBvcFJldHVybkJ1ZmZlci53cml0ZShidXJuQW1vdW50LnVuaXRzLCA0NywgYnVybkFtb3VudC51bml0cy5sZW5ndGgsICdhc2NpaScpXG4gIH1cblxuICBjb25zdCBudWxsT3V0cHV0ID0gYml0Y29pbi5wYXltZW50cy5lbWJlZCh7IGRhdGE6IFtvcFJldHVybkJ1ZmZlcl0gfSkub3V0cHV0XG4gIGNvbnN0IHR4ID0gbWFrZVRYYnVpbGRlcigpXG5cbiAgdHguYWRkT3V0cHV0KG51bGxPdXRwdXQsIDApXG4gIHR4LmFkZE91dHB1dChwcmVvcmRlckFkZHJlc3MsIERVU1RfTUlOSU1VTSlcblxuICBpZiAoYnVybkFtb3VudC51bml0cyA9PT0gJ0JUQycpIHtcbiAgICBjb25zdCBidGNCdXJuQW1vdW50ID0gcGFyc2VJbnQoYnVybkFtb3VudC5hbW91bnQudG9IZXgoKSwgMTYpXG4gICAgdHguYWRkT3V0cHV0KGJ1cm5BZGRyZXNzLCBidGNCdXJuQW1vdW50KVxuICB9IGVsc2Uge1xuICAgIHR4LmFkZE91dHB1dChidXJuQWRkcmVzcywgRFVTVF9NSU5JTVVNKVxuICB9XG5cbiAgcmV0dXJuIHR4LmJ1aWxkSW5jb21wbGV0ZSgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVnaXN0ZXJTa2VsZXRvbihcbiAgZnVsbHlRdWFsaWZpZWROYW1lOiBzdHJpbmcsIG93bmVyQWRkcmVzczogc3RyaW5nLFxuICB2YWx1ZUhhc2g6ID9zdHJpbmcgPSBudWxsLCBidXJuVG9rZW5BbW91bnRIZXg6ID9zdHJpbmcgPSBudWxsXG4pIHtcbiAgLy8gUmV0dXJucyBhIHJlZ2lzdGVyIHR4IHNrZWxldG9uLlxuICAvLyAgIHdpdGggMiBvdXRwdXRzIDogMS4gVGhlIHJlZ2lzdGVyIE9QX1JFVFVSTlxuICAvLyAgICAgICAgICAgICAgICAgICAgMi4gVGhlIG93bmVyIGFkZHJlc3MgKGNhbiBiZSBkaWZmZXJlbnQgZnJvbSBSRUdJU1RFUiBhZGRyZXNzIG9uIHJlbmV3YWxzKVxuXG4gIC8vIFlvdSBNVVNUIG1ha2UgdGhlIGZpcnN0IGlucHV0IGEgVVRYTyBmcm9tIHRoZSBjdXJyZW50IE9XTkVSICpvciogdGhlXG4gIC8vICAgZnVuZGVyIG9mIHRoZSBQUkVPUkRFUlxuXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgcmVuZXdhbCwgdGhpcyB3b3VsZCBuZWVkIHRvIGJlIG1vZGlmaWVkIHRvIGluY2x1ZGUgYSBjaGFuZ2UgYWRkcmVzc1xuICAvLyAgYXMgb3V0cHV0ICgzKSBiZWZvcmUgdGhlIGJ1cm4gb3V0cHV0ICg0KVxuXG4gIC8qXG4gICAgRm9ybWF0c1xuXG4gICAgTm8gem9uZWZpbGUgaGFzaCwgYW5kIHBheSB3aXRoIEJUQzpcblxuICAgIDAgICAgMiAgMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzOVxuICAgIHwtLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgbWFnaWMgb3AgICBuYW1lLm5zX2lkICh1cCB0byAzNyBieXRlcylcblxuXG4gICAgV2l0aCB6b25lZmlsZSBoYXNoLCBhbmQgcGF5IHdpdGggQlRDOlxuXG4gICAgMCAgICAyICAzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDM5ICAgICAgICAgICAgICAgICAgNTlcbiAgICB8LS0tLXwtLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgbWFnaWMgb3AgICBuYW1lLm5zX2lkICgzNyBieXRlcywgMC1wYWRkZWQpICAgICB6b25lIGZpbGUgaGFzaFxuXG4gICAgb3V0cHV0IDA6IG5hbWUgcmVnaXN0cmF0aW9uIGNvZGVcbiAgICBvdXRwdXQgMTogb3duZXIgYWRkcmVzc1xuICAqL1xuXG4gIGxldCBwYXlsb2FkXG5cbiAgaWYgKCEhYnVyblRva2VuQW1vdW50SGV4ICYmICF2YWx1ZUhhc2gpIHtcbiAgICAvLyBlbXB0eSB2YWx1ZSBoYXNoXG4gICAgdmFsdWVIYXNoID0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIH1cblxuICBpZiAoISF2YWx1ZUhhc2gpIHtcbiAgICBpZiAodmFsdWVIYXNoLmxlbmd0aCAhPT0gNDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmFsdWUgaGFzaCBsZW5ndGggaW5jb3JyZWN0LiBFeHBlY3RpbmcgMjAtYnl0ZXMsIGhleC1lbmNvZGVkJylcbiAgICB9XG4gICAgaWYgKCEhYnVyblRva2VuQW1vdW50SGV4KSB7XG4gICAgICBpZiAoYnVyblRva2VuQW1vdW50SGV4Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCdXJuIGZpZWxkIGxlbmd0aCBpbmNvcnJlY3QuICBFeHBlY3RpbmcgOC1ieXRlcywgaGV4LWVuY29kZWQnKVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHBheWxvYWRMZW4gPSBidXJuVG9rZW5BbW91bnRIZXggPyA2NSA6IDU3XG4gICAgcGF5bG9hZCA9IEJ1ZmZlci5hbGxvYyhwYXlsb2FkTGVuLCAwKVxuICAgIHBheWxvYWQud3JpdGUoZnVsbHlRdWFsaWZpZWROYW1lLCAwLCAzNywgJ2FzY2lpJylcbiAgICBwYXlsb2FkLndyaXRlKHZhbHVlSGFzaCwgMzcsIDIwLCAnaGV4JylcbiAgICBpZiAoISFidXJuVG9rZW5BbW91bnRIZXgpIHtcbiAgICAgIHBheWxvYWQud3JpdGUoYnVyblRva2VuQW1vdW50SGV4LCA1NywgOCwgJ2hleCcpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBheWxvYWQgPSBCdWZmZXIuZnJvbShmdWxseVF1YWxpZmllZE5hbWUsICdhc2NpaScpXG4gIH1cblxuICBjb25zdCBvcFJldHVybkJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKG9wRW5jb2RlKCc6JyksICdhc2NpaScpLCBwYXlsb2FkXSlcbiAgY29uc3QgbnVsbE91dHB1dCA9IGJpdGNvaW4ucGF5bWVudHMuZW1iZWQoeyBkYXRhOiBbb3BSZXR1cm5CdWZmZXJdIH0pLm91dHB1dFxuICBjb25zdCB0eCA9IG1ha2VUWGJ1aWxkZXIoKVxuXG4gIHR4LmFkZE91dHB1dChudWxsT3V0cHV0LCAwKVxuICB0eC5hZGRPdXRwdXQob3duZXJBZGRyZXNzLCBEVVNUX01JTklNVU0pXG5cbiAgcmV0dXJuIHR4LmJ1aWxkSW5jb21wbGV0ZSgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUmVuZXdhbFNrZWxldG9uKFxuICBmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZywgbmV4dE93bmVyQWRkcmVzczogc3RyaW5nLCBsYXN0T3duZXJBZGRyZXNzOiBzdHJpbmcsXG4gIGJ1cm5BZGRyZXNzOiBzdHJpbmcsIGJ1cm46IEFtb3VudFR5cGUsIHZhbHVlSGFzaDogP3N0cmluZyA9IG51bGxcbikge1xuICAvKlxuICAgIEZvcm1hdHNcblxuICAgIE5vIHpvbmVmaWxlIGhhc2gsIGFuZCBwYXkgd2l0aCBCVEM6XG5cbiAgICAwICAgIDIgIDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzlcbiAgICB8LS0tLXwtLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIG1hZ2ljIG9wICAgbmFtZS5uc19pZCAodXAgdG8gMzcgYnl0ZXMpXG5cblxuICAgIFdpdGggem9uZWZpbGUgaGFzaCwgYW5kIHBheSB3aXRoIEJUQzpcblxuICAgIDAgICAgMiAgMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzOSAgICAgICAgICAgICAgICAgIDU5XG4gICAgfC0tLS18LS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIG1hZ2ljIG9wICAgbmFtZS5uc19pZCAoMzcgYnl0ZXMsIDAtcGFkZGVkKSAgICAgem9uZSBmaWxlIGhhc2hcblxuXG4gICBXaXRoIHJlbmV3YWwgcGF5bWVudCBpbiBhIHRva2VuOlxuICAgKGZvciByZWdpc3RlciwgdG9rZW5zIGJ1cm5lZCBpcyBub3QgaW5jbHVkZWQpXG4gICAoZm9yIHJlbmV3LCB0b2tlbnMgYnVybmVkIGlzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGJ1cm4pXG5cbiAgIDAgICAgMiAgMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAzOSAgICAgICAgICAgICAgICAgIDU5ICAgICAgICAgICAgICAgICAgICAgICAgICAgIDY3XG4gICB8LS0tLXwtLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgbWFnaWMgb3AgICBuYW1lLm5zX2lkICgzNyBieXRlcywgMC1wYWRkZWQpICAgICB6b25lIGZpbGUgaGFzaCAgICB0b2tlbnMgYnVybmVkIChiaWctZW5kaWFuKVxuXG4gICBvdXRwdXQgMDogcmVuZXdhbCBjb2RlXG4gICBvdXRwdXQgMTogbmV3IG93bmVyIGFkZHJlc3NcbiAgIG91dHB1dCAyOiBjdXJyZW50IG93bmVyIGFkZHJlc3NcbiAgIG91dHB1dCAzOiBidXJuIGFkZHJlc3NcbiAgKi9cbiAgY29uc3QgYnVybkFtb3VudCA9IGFzQW1vdW50VjIoYnVybilcbiAgY29uc3QgbmV0d29yayA9IGNvbmZpZy5uZXR3b3JrXG4gIGNvbnN0IGJ1cm5Ub2tlbkFtb3VudCA9IGJ1cm5BbW91bnQudW5pdHMgPT09ICdCVEMnID8gbnVsbCA6IGJ1cm5BbW91bnQuYW1vdW50XG4gIGNvbnN0IGJ1cm5CVENBbW91bnQgPSBidXJuQW1vdW50LnVuaXRzID09PSAnQlRDJyBcbiAgICA/IHBhcnNlSW50KGJ1cm5BbW91bnQuYW1vdW50LnRvSGV4KCksIDE2KSA6IERVU1RfTUlOSU1VTVxuICBcbiAgbGV0IGJ1cm5Ub2tlbkhleCA9IG51bGxcbiAgaWYgKCEhYnVyblRva2VuQW1vdW50KSB7XG4gICAgY29uc3QgYnVybkhleCA9IGJ1cm5Ub2tlbkFtb3VudC50b0hleCgpXG4gICAgaWYgKGJ1cm5IZXgubGVuZ3RoID4gMTYpIHtcbiAgICAgIC8vIGV4Y2VlZHMgMioqNjQ7IGNhbid0IGZpdCBcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlbmV3ICcke2Z1bGx5UXVhbGlmaWVkTmFtZX0nOiBjYW5ub3QgZml0IHByaWNlIGludG8gOCBieXRlc2ApXG4gICAgfVxuICAgIGJ1cm5Ub2tlbkhleCA9IGAwMDAwMDAwMDAwMDAwMDAwJHtidXJuSGV4fWAuc2xpY2UoLTE2KVxuICB9XG5cbiAgY29uc3QgcmVnaXN0ZXJUWCA9IG1ha2VSZWdpc3RlclNrZWxldG9uKFxuICAgIGZ1bGx5UXVhbGlmaWVkTmFtZSwgbmV4dE93bmVyQWRkcmVzcywgdmFsdWVIYXNoLCBidXJuVG9rZW5IZXhcbiAgKVxuICBjb25zdCB0eEIgPSBiaXRjb2luLlRyYW5zYWN0aW9uQnVpbGRlci5mcm9tVHJhbnNhY3Rpb24oXG4gICAgcmVnaXN0ZXJUWCwgbmV0d29yay5sYXllcjFcbiAgKVxuICB0eEIuYWRkT3V0cHV0KGxhc3RPd25lckFkZHJlc3MsIERVU1RfTUlOSU1VTSlcbiAgdHhCLmFkZE91dHB1dChidXJuQWRkcmVzcywgYnVybkJUQ0Ftb3VudClcbiAgcmV0dXJuIHR4Qi5idWlsZEluY29tcGxldGUoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVRyYW5zZmVyU2tlbGV0b24oXG4gIGZ1bGx5UXVhbGlmaWVkTmFtZTogc3RyaW5nLCBjb25zZW5zdXNIYXNoOiBzdHJpbmcsIG5ld093bmVyOiBzdHJpbmcsXG4gIGtlZXBab25lZmlsZTogYm9vbGVhbiA9IGZhbHNlXG4pIHtcbiAgLy8gUmV0dXJucyBhIHRyYW5zZmVyIHR4IHNrZWxldG9uLlxuICAvLyAgIHdpdGggMiBvdXRwdXRzIDogMS4gdGhlIEJsb2Nrc3RhY2sgVHJhbnNmZXIgT1BfUkVUVVJOIGRhdGFcbiAgLy8gICAgICAgICAgICAgICAgICAgIDIuIHRoZSBuZXcgb3duZXIgd2l0aCBhIERVU1RfTUlOSU1VTSB2YWx1ZSAoNTUwMCBzYXRvc2hpKVxuICAvL1xuICAvLyBZb3UgTVVTVCBtYWtlIHRoZSBmaXJzdCBpbnB1dCBhIFVUWE8gZnJvbSB0aGUgY3VycmVudCBPV05FUlxuICAvL1xuICAvLyBSZXR1cm5zIGFuIHVuc2lnbmVkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gIC8qXG4gICAgRm9ybWF0XG5cbiAgICAwICAgICAyICAzICAgIDQgICAgICAgICAgICAgICAgICAgMjAgICAgICAgICAgICAgIDM2XG4gICAgfC0tLS0tfC0tfC0tLS18LS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS18XG4gICAgbWFnaWMgb3Aga2VlcCAgaGFzaDEyOChuYW1lLm5zX2lkKSBjb25zZW5zdXMgaGFzaFxuICAgICAgICAgICAgIGRhdGE/XG5cbiAgICBvdXRwdXQgMDogdHJhbnNmZXIgY29kZVxuICAgIG91dHB1dCAxOiBuZXcgb3duZXJcbiAgKi9cbiAgY29uc3Qgb3BSZXQgPSBCdWZmZXIuYWxsb2MoMzYpXG4gIGxldCBrZWVwQ2hhciA9ICd+J1xuICBpZiAoa2VlcFpvbmVmaWxlKSB7XG4gICAga2VlcENoYXIgPSAnPidcbiAgfVxuXG4gIG9wUmV0LndyaXRlKG9wRW5jb2RlKCc+JyksIDAsIDMsICdhc2NpaScpXG4gIG9wUmV0LndyaXRlKGtlZXBDaGFyLCAzLCAxLCAnYXNjaWknKVxuXG4gIGNvbnN0IGhhc2hlZCA9IGhhc2gxMjgoQnVmZmVyLmZyb20oZnVsbHlRdWFsaWZpZWROYW1lLCAnYXNjaWknKSlcbiAgaGFzaGVkLmNvcHkob3BSZXQsIDQpXG4gIG9wUmV0LndyaXRlKGNvbnNlbnN1c0hhc2gsIDIwLCAxNiwgJ2hleCcpXG5cbiAgY29uc3Qgb3BSZXRQYXlsb2FkID0gYml0Y29pbi5wYXltZW50cy5lbWJlZCh7IGRhdGE6IFtvcFJldF0gfSkub3V0cHV0XG5cbiAgY29uc3QgdHggPSBtYWtlVFhidWlsZGVyKClcblxuICB0eC5hZGRPdXRwdXQob3BSZXRQYXlsb2FkLCAwKVxuICB0eC5hZGRPdXRwdXQobmV3T3duZXIsIERVU1RfTUlOSU1VTSlcblxuICByZXR1cm4gdHguYnVpbGRJbmNvbXBsZXRlKClcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZVVwZGF0ZVNrZWxldG9uKFxuICBmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZywgY29uc2Vuc3VzSGFzaDogc3RyaW5nLCB2YWx1ZUhhc2g6IHN0cmluZ1xuKSB7XG4gIC8vIFJldHVybnMgYW4gdXBkYXRlIHR4IHNrZWxldG9uLlxuICAvLyAgIHdpdGggMSBvdXRwdXQgOiAxLiB0aGUgQmxvY2tzdGFjayB1cGRhdGUgT1BfUkVUVVJOXG4gIC8vXG4gIC8vIFlvdSBNVVNUIG1ha2UgdGhlIGZpcnN0IGlucHV0IGEgVVRYTyBmcm9tIHRoZSBjdXJyZW50IE9XTkVSXG4gIC8vXG4gIC8vIFJldHVybnMgYW4gdW5zaWduZWQgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAgLy9cbiAgLy8gb3V0cHV0IDA6IHRoZSByZXZva2UgY29kZVxuICAvKlxuICAgIEZvcm1hdDpcblxuICAgIDAgICAgIDIgIDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDE5ICAgICAgICAgICAgICAgICAgICAgIDM5XG4gICAgfC0tLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIG1hZ2ljIG9wICBoYXNoMTI4KG5hbWUubnNfaWQsY29uc2Vuc3VzIGhhc2gpIGhhc2gxNjAoZGF0YSlcblxuICAgIG91dHB1dCAwOiB1cGRhdGUgY29kZVxuICAqL1xuXG4gIGNvbnN0IG9wUmV0ID0gQnVmZmVyLmFsbG9jKDM5KVxuXG4gIGNvbnN0IG5hbWVCdWZmID0gQnVmZmVyLmZyb20oZnVsbHlRdWFsaWZpZWROYW1lLCAnYXNjaWknKVxuICBjb25zdCBjb25zZW5zdXNCdWZmID0gQnVmZmVyLmZyb20oY29uc2Vuc3VzSGFzaCwgJ2FzY2lpJylcblxuICBjb25zdCBoYXNoZWROYW1lID0gaGFzaDEyOChCdWZmZXIuY29uY2F0KFxuICAgIFtuYW1lQnVmZiwgY29uc2Vuc3VzQnVmZl1cbiAgKSlcblxuICBvcFJldC53cml0ZShvcEVuY29kZSgnKycpLCAwLCAzLCAnYXNjaWknKVxuICBoYXNoZWROYW1lLmNvcHkob3BSZXQsIDMpXG4gIG9wUmV0LndyaXRlKHZhbHVlSGFzaCwgMTksIDIwLCAnaGV4JylcblxuICBjb25zdCBvcFJldFBheWxvYWQgPSBiaXRjb2luLnBheW1lbnRzLmVtYmVkKHsgZGF0YTogW29wUmV0XSB9KS5vdXRwdXRcblxuICBjb25zdCB0eCA9IG1ha2VUWGJ1aWxkZXIoKVxuXG4gIHR4LmFkZE91dHB1dChvcFJldFBheWxvYWQsIDApXG5cbiAgcmV0dXJuIHR4LmJ1aWxkSW5jb21wbGV0ZSgpXG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VSZXZva2VTa2VsZXRvbihmdWxseVF1YWxpZmllZE5hbWU6IHN0cmluZykge1xuICAvLyBSZXR1cm5zIGEgcmV2b2tlIHR4IHNrZWxldG9uXG4gIC8vICAgIHdpdGggMSBvdXRwdXQ6IDEuIHRoZSBCbG9ja3N0YWNrIHJldm9rZSBPUF9SRVRVUk5cbiAgLy9cbiAgLy8gWW91IE1VU1QgbWFrZSB0aGUgZmlyc3QgaW5wdXQgYSBVVFhPIGZyb20gdGhlIGN1cnJlbnQgT1dORVJcbiAgLy9cbiAgLy8gUmV0dXJucyBhbiB1bnNpZ25lZCBzZXJpYWxpemVkIHRyYW5zYWN0aW9uXG4gIC8qXG4gICBGb3JtYXQ6XG5cbiAgIDAgICAgMiAgMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzlcbiAgIHwtLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgbWFnaWMgb3AgICBuYW1lLm5zX2lkICgzNyBieXRlcylcblxuICAgb3V0cHV0IDA6IHRoZSByZXZva2UgY29kZVxuICAqL1xuXG4gIGNvbnN0IG9wUmV0ID0gQnVmZmVyLmFsbG9jKDMpXG5cbiAgY29uc3QgbmFtZUJ1ZmYgPSBCdWZmZXIuZnJvbShmdWxseVF1YWxpZmllZE5hbWUsICdhc2NpaScpXG5cbiAgb3BSZXQud3JpdGUob3BFbmNvZGUoJ34nKSwgMCwgMywgJ2FzY2lpJylcblxuICBjb25zdCBvcFJldHVybkJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW29wUmV0LCBuYW1lQnVmZl0pXG4gIGNvbnN0IG51bGxPdXRwdXQgPSBiaXRjb2luLnBheW1lbnRzLmVtYmVkKHsgZGF0YTogW29wUmV0dXJuQnVmZmVyXSB9KS5vdXRwdXRcbiAgY29uc3QgdHggPSBtYWtlVFhidWlsZGVyKClcblxuICB0eC5hZGRPdXRwdXQobnVsbE91dHB1dCwgMClcblxuICByZXR1cm4gdHguYnVpbGRJbmNvbXBsZXRlKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VOYW1lc3BhY2VQcmVvcmRlclNrZWxldG9uKFxuICBuYW1lc3BhY2VJRDogc3RyaW5nLCBjb25zZW5zdXNIYXNoIDogc3RyaW5nLCBwcmVvcmRlckFkZHJlc3M6IHN0cmluZyxcbiAgcmVnaXN0ZXJBZGRyZXNzOiBzdHJpbmcsIGJ1cm46IEFtb3VudFR5cGVcbikge1xuICAvLyBSZXR1cm5zIGEgbmFtZXNwYWNlIHByZW9yZGVyIHR4IHNrZWxldG9uLlxuICAvLyBSZXR1cm5zIGFuIHVuc2lnbmVkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gIC8qXG4gICBGb3JtYXRzOlxuXG4gICBXaXRob3V0IFNUQUNLUzpcblxuICAgMCAgICAgMiAgIDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIzICAgICAgICAgICAgICAgMzlcbiAgIHwtLS0tLXwtLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLXxcbiAgIG1hZ2ljIG9wICBoYXNoKG5zX2lkLHNjcmlwdF9wdWJrZXkscmV2ZWFsX2FkZHIpICAgY29uc2Vuc3VzIGhhc2hcblxuXG4gICB3aXRoIFNUQUNLczpcblxuICAgMCAgICAgMiAgIDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDIzICAgICAgICAgICAgICAgMzkgICAgICAgICAgICAgICAgICAgICAgICAgNDdcbiAgIHwtLS0tLXwtLS18LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgIG1hZ2ljIG9wICBoYXNoKG5zX2lkLHNjcmlwdF9wdWJrZXkscmV2ZWFsX2FkZHIpICAgY29uc2Vuc3VzIGhhc2ggICAgdG9rZW4gZmVlIChiaWctZW5kaWFuKVxuXG4gICBvdXRwdXQgMDogbmFtZXNwYWNlIHByZW9yZGVyIGNvZGVcbiAgIG91dHB1dCAxOiBjaGFuZ2UgYWRkcmVzc1xuICAgb3R1cHV0IDI6IGJ1cm4gYWRkcmVzc1xuICAqL1xuXG4gIGNvbnN0IGJ1cm5BbW91bnQgPSBhc0Ftb3VudFYyKGJ1cm4pXG4gIGlmIChidXJuQW1vdW50LnVuaXRzICE9PSAnQlRDJyAmJiBidXJuQW1vdW50LnVuaXRzICE9PSAnU1RBQ0tTJykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBidXJuVW5pdHMgJHtidXJuQW1vdW50LnVuaXRzfWApXG4gIH1cblxuICBjb25zdCBuZXR3b3JrID0gY29uZmlnLm5ldHdvcmtcbiAgY29uc3QgYnVybkFkZHJlc3MgPSBuZXR3b3JrLmdldERlZmF1bHRCdXJuQWRkcmVzcygpXG4gIGNvbnN0IG5hbWVzcGFjZUlEQnVmZiA9IEJ1ZmZlci5mcm9tKGRlY29kZUI0MChuYW1lc3BhY2VJRCksICdoZXgnKSAvLyBiYXNlNDBcbiAgY29uc3Qgc2NyaXB0UHVibGljS2V5ID0gYml0Y29pbi5hZGRyZXNzLnRvT3V0cHV0U2NyaXB0KHByZW9yZGVyQWRkcmVzcywgbmV0d29yay5sYXllcjEpXG4gIGNvbnN0IHJlZ2lzdGVyQnVmZiA9IEJ1ZmZlci5mcm9tKHJlZ2lzdGVyQWRkcmVzcywgJ2FzY2lpJylcblxuICBjb25zdCBkYXRhQnVmZmVycyA9IFtuYW1lc3BhY2VJREJ1ZmYsIHNjcmlwdFB1YmxpY0tleSwgcmVnaXN0ZXJCdWZmXVxuICBjb25zdCBkYXRhQnVmZiA9IEJ1ZmZlci5jb25jYXQoZGF0YUJ1ZmZlcnMpXG5cbiAgY29uc3QgaGFzaGVkID0gaGFzaDE2MChkYXRhQnVmZilcbiAgXG4gIGxldCBidGNCdXJuQW1vdW50ID0gRFVTVF9NSU5JTVVNXG4gIGxldCBvcFJldHVybkJ1ZmZlckxlbiA9IDM5XG4gIGlmIChidXJuQW1vdW50LnVuaXRzID09PSAnU1RBQ0tTJykge1xuICAgIG9wUmV0dXJuQnVmZmVyTGVuID0gNDdcbiAgfSBlbHNlIHtcbiAgICBidGNCdXJuQW1vdW50ID0gcGFyc2VJbnQoYnVybkFtb3VudC5hbW91bnQudG9IZXgoKSwgMTYpXG4gIH1cblxuICBjb25zdCBvcFJldHVybkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhvcFJldHVybkJ1ZmZlckxlbilcbiAgb3BSZXR1cm5CdWZmZXIud3JpdGUob3BFbmNvZGUoJyonKSwgMCwgMywgJ2FzY2lpJylcbiAgaGFzaGVkLmNvcHkob3BSZXR1cm5CdWZmZXIsIDMpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKGNvbnNlbnN1c0hhc2gsIDIzLCAxNiwgJ2hleCcpXG5cbiAgaWYgKGJ1cm5BbW91bnQudW5pdHMgPT09ICdTVEFDS1MnKSB7XG4gICAgY29uc3QgYnVybkhleCA9IGJ1cm5BbW91bnQuYW1vdW50LnRvSGV4KClcbiAgICBjb25zdCBwYWRkZWRCdXJuSGV4ID0gYDAwMDAwMDAwMDAwMDAwMDAke2J1cm5IZXh9YC5zbGljZSgtMTYpXG4gICAgb3BSZXR1cm5CdWZmZXIud3JpdGUocGFkZGVkQnVybkhleCwgMzksIDgsICdoZXgnKVxuICB9XG5cbiAgY29uc3QgbnVsbE91dHB1dCA9IGJpdGNvaW4ucGF5bWVudHMuZW1iZWQoeyBkYXRhOiBbb3BSZXR1cm5CdWZmZXJdIH0pLm91dHB1dFxuICBjb25zdCB0eCA9IG1ha2VUWGJ1aWxkZXIoKVxuXG4gIHR4LmFkZE91dHB1dChudWxsT3V0cHV0LCAwKVxuICB0eC5hZGRPdXRwdXQocHJlb3JkZXJBZGRyZXNzLCBEVVNUX01JTklNVU0pXG4gIHR4LmFkZE91dHB1dChidXJuQWRkcmVzcywgYnRjQnVybkFtb3VudClcblxuICByZXR1cm4gdHguYnVpbGRJbmNvbXBsZXRlKClcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5hbWVzcGFjZVJldmVhbFNrZWxldG9uKFxuICBuYW1lc3BhY2U6IEJsb2Nrc3RhY2tOYW1lc3BhY2UsIHJldmVhbEFkZHJlc3M6IHN0cmluZ1xuKSB7XG4gIC8qXG4gICBGb3JtYXQ6XG5cbiAgIDAgICAgIDIgICAzICAgIDcgICAgIDggICAgIDkgICAgMTAgICAxMSAgIDEyICAgMTMgICAxNCAgICAxNSAgICAxNiAgICAxNyAgICAgICAxOCAgICAgIDIwICAgICAzOVxuICAgfC0tLS0tfC0tLXwtLS0tfC0tLS0tfC0tLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tLXwtLS0tLXwtLS0tLXwtLS0tLS0tLXwtLS0tLS0tfC0tLS0tLS18XG4gICBtYWdpYyAgb3AgIGxpZmUgY29lZmYuIGJhc2UgMS0yICAzLTQgIDUtNiAgNy04ICA5LTEwIDExLTEyIDEzLTE0IDE1LTE2IG5vbmFscGhhIHZlcnNpb24gIG5zIElEXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCBleHBvbmVudHMgICAgICAgIG5vLXZvd2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2NvdW50c1xuICAgXG4gICBvdXRwdXQgMDogbmFtZXNwYWNlIHJldmVhbCBjb2RlXG4gICBvdXRwdXQgMTogcmV2ZWFsIGFkZHJlc3NcbiAgKi9cbiAgY29uc3QgaGV4UGF5bG9hZCA9IG5hbWVzcGFjZS50b0hleFBheWxvYWQoKVxuXG4gIGNvbnN0IG9wUmV0dXJuQnVmZmVyID0gQnVmZmVyLmFsbG9jKDMgKyBoZXhQYXlsb2FkLmxlbmd0aCAvIDIpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKG9wRW5jb2RlKCcmJyksIDAsIDMsICdhc2NpaScpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKGhleFBheWxvYWQsIDMsIGhleFBheWxvYWQubGVuZ3RoIC8gMiwgJ2hleCcpXG5cbiAgY29uc3QgbnVsbE91dHB1dCA9IGJpdGNvaW4ucGF5bWVudHMuZW1iZWQoeyBkYXRhOiBbb3BSZXR1cm5CdWZmZXJdIH0pLm91dHB1dFxuICBjb25zdCB0eCA9IG1ha2VUWGJ1aWxkZXIoKVxuXG4gIHR4LmFkZE91dHB1dChudWxsT3V0cHV0LCAwKVxuICB0eC5hZGRPdXRwdXQocmV2ZWFsQWRkcmVzcywgRFVTVF9NSU5JTVVNKVxuXG4gIHJldHVybiB0eC5idWlsZEluY29tcGxldGUoKVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlTmFtZXNwYWNlUmVhZHlTa2VsZXRvbihuYW1lc3BhY2VJRDogc3RyaW5nKSB7XG4gIC8qXG4gICBGb3JtYXQ6XG5cbiAgIDAgICAgIDIgIDMgIDQgICAgICAgICAgIDIzXG4gICB8LS0tLS18LS18LS18LS0tLS0tLS0tLS0tfFxuICAgbWFnaWMgb3AgIC4gIG5zX2lkXG5cbiAgIG91dHB1dCAwOiBuYW1lc3BhY2UgcmVhZHkgY29kZVxuICAgKi9cbiAgY29uc3Qgb3BSZXR1cm5CdWZmZXIgPSBCdWZmZXIuYWxsb2MoMyArIG5hbWVzcGFjZUlELmxlbmd0aCArIDEpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKG9wRW5jb2RlKCchJyksIDAsIDMsICdhc2NpaScpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKGAuJHtuYW1lc3BhY2VJRH1gLCAzLCBuYW1lc3BhY2VJRC5sZW5ndGggKyAxLCAnYXNjaWknKVxuXG4gIGNvbnN0IG51bGxPdXRwdXQgPSBiaXRjb2luLnBheW1lbnRzLmVtYmVkKHsgZGF0YTogW29wUmV0dXJuQnVmZmVyXSB9KS5vdXRwdXRcbiAgY29uc3QgdHggPSBtYWtlVFhidWlsZGVyKClcblxuICB0eC5hZGRPdXRwdXQobnVsbE91dHB1dCwgMClcblxuICByZXR1cm4gdHguYnVpbGRJbmNvbXBsZXRlKClcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gbWFrZU5hbWVJbXBvcnRTa2VsZXRvbihuYW1lOiBzdHJpbmcsIHJlY2lwaWVudEFkZHI6IHN0cmluZywgem9uZWZpbGVIYXNoOiBzdHJpbmcpIHtcbiAgLypcbiAgIEZvcm1hdDpcblxuICAgIDAgICAgMiAgMyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMzlcbiAgICB8LS0tLXwtLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAgICBtYWdpYyBvcCAgIG5hbWUubnNfaWQgKDM3IGJ5dGVzKVxuXG4gICBPdXRwdXQgMDogdGhlIE9QX1JFVFVSTlxuICAgT3V0cHV0IDE6IHRoZSByZWNpcGllbnRcbiAgIE91dHB1dCAyOiB0aGUgem9uZWZpbGUgaGFzaFxuICovXG4gIGlmICh6b25lZmlsZUhhc2gubGVuZ3RoICE9PSA0MCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB6b25lZmlsZSBoYXNoOiBtdXN0IGJlIDIwIGJ5dGVzIGhleC1lbmNvZGVkJylcbiAgfVxuXG4gIGNvbnN0IG5ldHdvcmsgPSBjb25maWcubmV0d29ya1xuICBjb25zdCBvcFJldHVybkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzICsgbmFtZS5sZW5ndGgpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKG9wRW5jb2RlKCc7JyksIDAsIDMsICdhc2NpaScpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKG5hbWUsIDMsIG5hbWUubGVuZ3RoLCAnYXNjaWknKVxuXG4gIGNvbnN0IG51bGxPdXRwdXQgPSBiaXRjb2luLnBheW1lbnRzLmVtYmVkKHsgZGF0YTogW29wUmV0dXJuQnVmZmVyXSB9KS5vdXRwdXRcblxuICBjb25zdCB0eCA9IG1ha2VUWGJ1aWxkZXIoKVxuICBjb25zdCB6b25lZmlsZUhhc2hCNTggPSBiaXRjb2luLmFkZHJlc3MudG9CYXNlNThDaGVjayhcbiAgICBuZXcgQnVmZmVyKHpvbmVmaWxlSGFzaCwgJ2hleCcpLCBuZXR3b3JrLmxheWVyMS5wdWJLZXlIYXNoXG4gIClcblxuICB0eC5hZGRPdXRwdXQobnVsbE91dHB1dCwgMClcbiAgdHguYWRkT3V0cHV0KHJlY2lwaWVudEFkZHIsIERVU1RfTUlOSU1VTSlcbiAgdHguYWRkT3V0cHV0KHpvbmVmaWxlSGFzaEI1OCwgRFVTVF9NSU5JTVVNKVxuXG4gIHJldHVybiB0eC5idWlsZEluY29tcGxldGUoKVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQW5ub3VuY2VTa2VsZXRvbihtZXNzYWdlSGFzaDogc3RyaW5nKSB7XG4gIC8qXG4gICAgRm9ybWF0OlxuXG4gICAgMCAgICAyICAzICAgICAgICAgICAgICAgICAgICAgICAgICAgICAyM1xuICAgIHwtLS0tfC0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICAgIG1hZ2ljIG9wICAgbWVzc2FnZSBoYXNoICgxNjAtYml0KVxuXG4gICAgb3V0cHV0IDA6IHRoZSBPUF9SRVRVUk5cbiAgKi9cbiAgaWYgKG1lc3NhZ2VIYXNoLmxlbmd0aCAhPT0gNDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWVzc2FnZSBoYXNoOiBtdXN0IGJlIDIwIGJ5dGVzIGhleC1lbmNvZGVkJylcbiAgfVxuXG4gIGNvbnN0IG9wUmV0dXJuQnVmZmVyID0gQnVmZmVyLmFsbG9jKDMgKyBtZXNzYWdlSGFzaC5sZW5ndGggLyAyKVxuICBvcFJldHVybkJ1ZmZlci53cml0ZShvcEVuY29kZSgnIycpLCAwLCAzLCAnYXNjaWknKVxuICBvcFJldHVybkJ1ZmZlci53cml0ZShtZXNzYWdlSGFzaCwgMywgbWVzc2FnZUhhc2gubGVuZ3RoIC8gMiwgJ2hleCcpXG5cbiAgY29uc3QgbnVsbE91dHB1dCA9IGJpdGNvaW4ucGF5bWVudHMuZW1iZWQoeyBkYXRhOiBbb3BSZXR1cm5CdWZmZXJdIH0pLm91dHB1dFxuICBjb25zdCB0eCA9IG1ha2VUWGJ1aWxkZXIoKVxuXG4gIHR4LmFkZE91dHB1dChudWxsT3V0cHV0LCAwKVxuICByZXR1cm4gdHguYnVpbGRJbmNvbXBsZXRlKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VUb2tlblRyYW5zZmVyU2tlbGV0b24ocmVjaXBpZW50QWRkcmVzczogc3RyaW5nLCBjb25zZW5zdXNIYXNoOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHN0cmluZywgdG9rZW5BbW91bnQ6IEJpZ0ludGVnZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JhdGNoQXJlYTogc3RyaW5nXG4pIHtcbiAgLypcbiAgIEZvcm1hdDpcblxuICAgIDAgICAgIDIgIDMgICAgICAgICAgICAgIDE5ICAgICAgICAgMzggICAgICAgICAgNDYgICAgICAgICAgICAgICAgICAgICAgICA4MFxuICAgIHwtLS0tLXwtLXwtLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tfC0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gICAgbWFnaWMgb3AgIGNvbnNlbnN1c19oYXNoIHRva2VuX3R5cGUgYW1vdW50IChCRSkgc2NyYXRjaCBhcmVhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuc19pZClcblxuICAgIG91dHB1dCAwOiB0b2tlbiB0cmFuc2ZlciBjb2RlXG4gICAgb3V0cHV0IDE6IHJlY2lwaWVudCBhZGRyZXNzXG4gICovXG4gIGlmIChzY3JhdGNoQXJlYS5sZW5ndGggPiAzNCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzY3JhdGNoIGFyZWE6IG11c3QgYmUgbm8gbW9yZSB0aGFuIDM0IGJ5dGVzJylcbiAgfVxuXG4gIGNvbnN0IG9wUmV0dXJuQnVmZmVyID0gQnVmZmVyLmFsbG9jKDQ2ICsgc2NyYXRjaEFyZWEubGVuZ3RoKVxuXG4gIGNvbnN0IHRva2VuVHlwZUhleCA9IG5ldyBCdWZmZXIodG9rZW5UeXBlKS50b1N0cmluZygnaGV4JylcbiAgY29uc3QgdG9rZW5UeXBlSGV4UGFkZGVkID0gYDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJHt0b2tlblR5cGVIZXh9YC5zbGljZSgtMzgpXG5cbiAgY29uc3QgdG9rZW5WYWx1ZUhleCA9IHRva2VuQW1vdW50LnRvSGV4KClcblxuICBpZiAodG9rZW5WYWx1ZUhleC5sZW5ndGggPiAxNikge1xuICAgIC8vIGV4Y2VlZHMgMioqNjQ7IGNhbid0IGZpdFxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNlbmQgdG9rZW5zOiBjYW5ub3QgZml0ICR7dG9rZW5BbW91bnQudG9TdHJpbmcoKX0gaW50byA4IGJ5dGVzYClcbiAgfVxuXG4gIGNvbnN0IHRva2VuVmFsdWVIZXhQYWRkZWQgPSBgMDAwMDAwMDAwMDAwMDAwMCR7dG9rZW5WYWx1ZUhleH1gLnNsaWNlKC0xNilcblxuICBvcFJldHVybkJ1ZmZlci53cml0ZShvcEVuY29kZSgnJCcpLCAwLCAzLCAnYXNjaWknKVxuICBvcFJldHVybkJ1ZmZlci53cml0ZShjb25zZW5zdXNIYXNoLCAzLCBjb25zZW5zdXNIYXNoLmxlbmd0aCAvIDIsICdoZXgnKVxuICBvcFJldHVybkJ1ZmZlci53cml0ZSh0b2tlblR5cGVIZXhQYWRkZWQsIDE5LCB0b2tlblR5cGVIZXhQYWRkZWQubGVuZ3RoIC8gMiwgJ2hleCcpXG4gIG9wUmV0dXJuQnVmZmVyLndyaXRlKHRva2VuVmFsdWVIZXhQYWRkZWQsIDM4LCB0b2tlblZhbHVlSGV4UGFkZGVkLmxlbmd0aCAvIDIsICdoZXgnKVxuICBvcFJldHVybkJ1ZmZlci53cml0ZShzY3JhdGNoQXJlYSwgNDYsIHNjcmF0Y2hBcmVhLmxlbmd0aCwgJ2FzY2lpJylcblxuICBjb25zdCBudWxsT3V0cHV0ID0gYml0Y29pbi5wYXltZW50cy5lbWJlZCh7IGRhdGE6IFtvcFJldHVybkJ1ZmZlcl0gfSkub3V0cHV0XG4gIGNvbnN0IHR4ID0gbWFrZVRYYnVpbGRlcigpXG5cbiAgdHguYWRkT3V0cHV0KG51bGxPdXRwdXQsIDApXG4gIHR4LmFkZE91dHB1dChyZWNpcGllbnRBZGRyZXNzLCBEVVNUX01JTklNVU0pXG5cbiAgcmV0dXJuIHR4LmJ1aWxkSW5jb21wbGV0ZSgpXG59XG4iXX0=