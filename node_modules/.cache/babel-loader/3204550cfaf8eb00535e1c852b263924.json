{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.isUserSignedIn = isUserSignedIn;\nexports.isSignInPending = isSignInPending;\nexports.handlePendingSignIn = handlePendingSignIn;\nexports.loadUserData = loadUserData;\nexports.signUserOut = signUserOut;\nexports.makeAuthRequest = makeAuthRequest;\nexports.redirectToSignInWithAuthRequestImpl = redirectToSignInWithAuthRequestImpl;\nexports.redirectToSignIn = redirectToSignIn;\nexports.redirectToSignInImpl = redirectToSignInImpl;\nexports.handlePendingSignInImpl = handlePendingSignInImpl;\nexports.loadUserDataImpl = loadUserDataImpl;\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n\nvar _queryString = _interopRequireDefault(require(\"query-string\"));\n\nvar _jsontokens = require(\"jsontokens\");\n\nvar _index = require(\"./index\");\n\nvar _utils = require(\"../utils\");\n\nvar _index2 = require(\"../index\");\n\nvar _errors = require(\"../errors\");\n\nvar _authMessages = require(\"./authMessages\");\n\nvar _authConstants = require(\"./authConstants\");\n\nvar _profiles = require(\"../profiles\");\n\nvar _userSession = require(\"./userSession\");\n\nvar _config = require(\"../config\");\n\nvar _logger = require(\"../logger\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org'\n  /**\n   * Check if a user is currently signed in.\n   * @method isUserSignedIn\n   * @return {Boolean} `true` if the user is signed in, `false` if not.\n   */\n\n};\n\nfunction isUserSignedIn() {\n  console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isUserSignedIn().');\n  var userSession = new _userSession.UserSession();\n  return userSession.isUserSignedIn();\n}\n/**\n * Check if there is a authentication request that hasn't been handled.\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\n\n\nfunction isSignInPending() {\n  console.warn('DEPRECATION WARNING: The static isSignInPending() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isSignInPending().');\n  var userSession = new _userSession.UserSession();\n  return userSession.isSignInPending();\n}\n/**\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\n\n/* eslint-disable no-unused-vars, no-use-before-define */\n\n\nfunction handlePendingSignIn() {\n  var nameLookupURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var authResponseToken = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getAuthResponseToken();\n  var transitKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n  console.warn('DEPRECATION WARNING: The static handlePendingSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method handlePendingSignIn().');\n  console.warn('DEPRECATION WARNING: handlePendingSignIn() no long supports setting of nameLookupURL and ' + 'transitKey. The nameLookupURL and transitKey now defaults to values in the default user session.');\n  var userSession = new _userSession.UserSession();\n  return userSession.handlePendingSignIn(authResponseToken);\n}\n/* eslint-enable no-unused-vars */\n\n/**\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\n\n\nfunction getAuthResponseToken() {\n  var queryDict = _queryString.default.parse(location.search);\n\n  return queryDict.authResponse ? queryDict.authResponse : '';\n}\n/**\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n */\n\n\nfunction loadUserData() {\n  console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method loadUserData().');\n  var userSession = new _userSession.UserSession();\n  return userSession.loadUserData();\n}\n/**\n * Sign the user out and optionally redirect to given location.\n * @param  {String} [redirectURL=null] Location to redirect user to after sign out.\n * @return {void}\n */\n\n\nfunction signUserOut() {\n  var redirectURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  // eslint-disable-line no-unused-vars\n  console.warn('DEPRECATION WARNING: The static signUserOut() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method signUserOut().');\n  var userSession = new _userSession.UserSession();\n  userSession.signUserOut();\n  window.location = redirectURL;\n}\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\n\n\nfunction makeAuthRequest(transitPrivateKey) {\n  var redirectURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\".concat(window.location.origin, \"/\");\n  var manifestURI = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\".concat(window.location.origin, \"/manifest.json\");\n  var scopes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _authConstants.DEFAULT_SCOPE;\n  var appDomain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : window.location.origin;\n  var expiresAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : (0, _utils.nextMonth)().getTime();\n  var extraParams = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {};\n  console.warn('DEPRECATION WARNING: The makeAuthRequest() function will be deprecated in the ' + 'next major release of blockstack.js. Use UserSession to configure your auth request.');\n  var userSession = new _userSession.UserSession();\n  var transitKey = transitPrivateKey == null ? userSession.generateAndStoreTransitKey() : transitPrivateKey;\n  return (0, _authMessages.makeAuthRequestImpl)(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);\n}\n/**\n * Detects if the native auth-browser is installed and is successfully \n * launched via a custom protocol URI. \n * @param {String} authRequest\n * The encoded authRequest to be used as a query param in the custom URI. \n * @param {String} successCallback\n * The callback that is invoked when the protocol handler was detected. \n * @param {String} failCallback\n * The callback that is invoked when the protocol handler was not detected. \n * @return {void}\n */\n\n\nfunction detectProtocolLaunch(authRequest, successCallback, failCallback) {\n  // Create a unique ID used for this protocol detection attempt.\n  var echoReplyID = Math.random().toString(36).substr(2, 9);\n  var echoReplyKeyPrefix = 'echo-reply-';\n  var echoReplyKey = \"\".concat(echoReplyKeyPrefix).concat(echoReplyID); // Use localStorage as a reliable cross-window communication method.\n  // Create the storage entry to signal a protocol detection attempt for the\n  // next browser window to check.\n\n  window.localStorage.setItem(echoReplyKey, Date.now().toString());\n\n  var cleanUpLocalStorage = function cleanUpLocalStorage() {\n    try {\n      window.localStorage.removeItem(echoReplyKey); // Also clear out any stale echo-reply keys older than 1 hour.\n\n      for (var i = 0; i < window.localStorage.length; i++) {\n        var storageKey = window.localStorage.key(i);\n\n        if (storageKey.startsWith(echoReplyKeyPrefix)) {\n          var storageValue = window.localStorage.getItem(storageKey);\n\n          if (storageValue === 'success' || Date.now() - parseInt(storageValue, 10) > 3600000) {\n            window.localStorage.removeItem(storageKey);\n          }\n        }\n      }\n    } catch (err) {\n      _logger.Logger.error('Exception cleaning up echo-reply entries in localStorage');\n\n      _logger.Logger.error(err);\n    }\n  };\n\n  var detectionTimeout = 1000;\n  var redirectToWebAuthTimer = 0;\n\n  var cancelWebAuthRedirectTimer = function cancelWebAuthRedirectTimer() {\n    if (redirectToWebAuthTimer) {\n      window.clearTimeout(redirectToWebAuthTimer);\n      redirectToWebAuthTimer = 0;\n    }\n  };\n\n  var startWebAuthRedirectTimer = function startWebAuthRedirectTimer() {\n    var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : detectionTimeout;\n    cancelWebAuthRedirectTimer();\n    redirectToWebAuthTimer = window.setTimeout(function () {\n      if (redirectToWebAuthTimer) {\n        cancelWebAuthRedirectTimer();\n        var nextFunc;\n\n        if (window.localStorage.getItem(echoReplyKey) === 'success') {\n          _logger.Logger.info('Protocol echo reply detected.');\n\n          nextFunc = successCallback;\n        } else {\n          _logger.Logger.info('Protocol handler not detected.');\n\n          nextFunc = failCallback;\n        }\n\n        failCallback = function failCallback() {};\n\n        successCallback = function successCallback() {};\n\n        cleanUpLocalStorage(); // Briefly wait since localStorage changes can \n        // sometimes be ignored when immediately redirected.\n\n        setTimeout(function () {\n          return nextFunc();\n        }, 100);\n      }\n    }, timeout);\n  };\n\n  startWebAuthRedirectTimer();\n  var inputPromptTracker = document.createElement('input');\n  inputPromptTracker.type = 'text'; // Prevent this element from inherited any css.\n\n  inputPromptTracker.style.all = 'initial'; // Setting display=none on an element prevents them from being focused/blurred.\n  // So hide the element using other properties..\n\n  inputPromptTracker.style.opacity = '0';\n  inputPromptTracker.style.filter = 'alpha(opacity=0)';\n  inputPromptTracker.style.height = '0';\n  inputPromptTracker.style.width = '0'; // If the the focus of a page element is immediately changed then this likely indicates \n  // the protocol handler is installed, and the browser is prompting the user if they want \n  // to open the application. \n\n  var inputBlurredFunc = function inputBlurredFunc() {\n    // Use a timeout of 100ms to ignore instant toggles between blur and focus.\n    // Browsers often perform an instant blur & focus when the protocol handler is working\n    // but not showing any browser prompts, so we want to ignore those instances.\n    var isRefocused = false;\n    inputPromptTracker.addEventListener('focus', function () {\n      isRefocused = true;\n    }, {\n      once: true,\n      capture: true\n    });\n    setTimeout(function () {\n      if (redirectToWebAuthTimer && !isRefocused) {\n        _logger.Logger.info('Detected possible browser prompt for opening the protocol handler app.');\n\n        window.clearTimeout(redirectToWebAuthTimer);\n        inputPromptTracker.addEventListener('focus', function () {\n          if (redirectToWebAuthTimer) {\n            _logger.Logger.info('Possible browser prompt closed, restarting auth redirect timeout.');\n\n            startWebAuthRedirectTimer();\n          }\n        }, {\n          once: true,\n          capture: true\n        });\n      }\n    }, 100);\n  };\n\n  inputPromptTracker.addEventListener('blur', inputBlurredFunc, {\n    once: true,\n    capture: true\n  });\n  setTimeout(function () {\n    return inputPromptTracker.removeEventListener('blur', inputBlurredFunc);\n  }, 200); // Flow complains without this check.\n\n  if (document.body) document.body.appendChild(inputPromptTracker);\n  inputPromptTracker.focus(); // Detect if document.visibility is immediately changed which is a strong \n  // indication that the protocol handler is working. We don't know for sure and \n  // can't predict future browser changes, so only increase the redirect timeout.\n  // This reduces the probability of a false-negative (where local auth works, but \n  // the original page was redirect to web auth because something took too long),\n\n  var pageVisibilityChanged = function pageVisibilityChanged() {\n    if (document.hidden && redirectToWebAuthTimer) {\n      _logger.Logger.info('Detected immediate page visibility change (protocol handler probably working).');\n\n      startWebAuthRedirectTimer(3000);\n    }\n  };\n\n  document.addEventListener('visibilitychange', pageVisibilityChanged, {\n    once: true,\n    capture: true\n  });\n  setTimeout(function () {\n    return document.removeEventListener('visibilitychange', pageVisibilityChanged);\n  }, 500); // Listen for the custom protocol echo reply via localStorage update event.\n\n  window.addEventListener('storage', function replyEventListener(event) {\n    if (event.key === echoReplyKey && window.localStorage.getItem(echoReplyKey) === 'success') {\n      // Custom protocol worked, cancel the web auth redirect timer.\n      cancelWebAuthRedirectTimer();\n      inputPromptTracker.removeEventListener('blur', inputBlurredFunc);\n\n      _logger.Logger.info('Protocol echo reply detected from localStorage event.'); // Clean up event listener and localStorage.\n\n\n      window.removeEventListener('storage', replyEventListener);\n      var nextFunc = successCallback;\n\n      successCallback = function successCallback() {};\n\n      failCallback = function failCallback() {};\n\n      cleanUpLocalStorage(); // Briefly wait since localStorage changes can sometimes \n      // be ignored when immediately redirected.\n\n      setTimeout(function () {\n        return nextFunc();\n      }, 100);\n    }\n  }, false); // Use iframe technique for launching the protocol URI rather than setting `window.location`.\n  // This method prevents browsers like Safari, Opera, Firefox from showing error prompts\n  // about unknown protocol handler when app is not installed, and avoids an empty\n  // browser tab when the app is installed. \n\n  _logger.Logger.info('Attempting protocol launch via iframe injection.');\n\n  var locationSrc = \"\".concat(_utils.BLOCKSTACK_HANDLER, \":\").concat(authRequest, \"&echo=\").concat(echoReplyID);\n  var iframe = document.createElement('iframe');\n  iframe.style.all = 'initial';\n  iframe.style.display = 'none';\n  iframe.src = locationSrc; // Flow complains without this check.\n\n  if (document.body) {\n    document.body.appendChild(iframe);\n  } else {\n    _logger.Logger.error('document.body is null when attempting iframe injection for protoocol URI launch');\n  }\n}\n/**\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {UserSession} caller - the instance calling this method\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n * @private\n */\n\n\nfunction redirectToSignInWithAuthRequestImpl(caller, authRequest) {\n  var httpsURI = \"\".concat(_authConstants.DEFAULT_BLOCKSTACK_HOST, \"?authRequest=\").concat(authRequest);\n\n  if (caller.appConfig && caller.appConfig.authenticatorURL) {\n    httpsURI = \"\".concat(caller.appConfig.authenticatorURL, \"?authRequest=\").concat(authRequest);\n  } // If they're on a mobile OS, always redirect them to HTTPS site\n\n\n  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {\n    _logger.Logger.info('detected mobile OS, sending to https');\n\n    window.location = httpsURI;\n    return;\n  }\n\n  function successCallback() {\n    _logger.Logger.info('protocol handler detected'); // The detection function should open the link for us\n\n  }\n\n  function failCallback() {\n    _logger.Logger.warn('protocol handler not detected');\n\n    window.location = httpsURI;\n  }\n\n  detectProtocolLaunch(authRequest, successCallback, failCallback);\n}\n/**\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\n\n\nfunction redirectToSignIn() {\n  var redirectURI = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\".concat(window.location.origin, \"/\");\n  var manifestURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\".concat(window.location.origin, \"/manifest.json\");\n  var scopes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _authConstants.DEFAULT_SCOPE;\n  console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method redirectToSignIn().');\n  var authRequest = makeAuthRequest(null, redirectURI, manifestURI, scopes);\n  redirectToSignInWithAuthRequest(authRequest);\n}\n/**\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most web applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest`,\n * and `redirectToSignInWithAuthRequest` to build your own sign in process.\n * @param {UserSession} caller - the instance calling this function\n * @return {void}\n * @private\n */\n\n\nfunction redirectToSignInImpl(caller) {\n  var transitKey = caller.generateAndStoreTransitKey();\n  var authRequest = caller.makeAuthRequest(transitKey);\n  redirectToSignInWithAuthRequestImpl(caller, authRequest);\n}\n/**\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {UserSession} caller - the instance calling this function\n * @param {String} authResponseToken - the signed authentication response token\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n * @private\n */\n\n\nfunction handlePendingSignInImpl(caller, authResponseToken) {\n  var transitKey = caller.store.getSessionData().transitKey;\n  var coreNodeSessionValue = caller.store.getSessionData().coreNode;\n  var nameLookupURL = null;\n\n  if (!coreNodeSessionValue) {\n    var tokenPayload = (0, _jsontokens.decodeToken)(authResponseToken).payload;\n\n    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.3.0') && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n      // override globally\n      _logger.Logger.info(\"Overriding \".concat(_config.config.network.blockstackAPIUrl, \" \") + \"with \".concat(tokenPayload.blockstackAPIUrl));\n\n      _config.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;\n    }\n\n    nameLookupURL = \"\".concat(_config.config.network.blockstackAPIUrl).concat(_authConstants.NAME_LOOKUP_PATH);\n  } else {\n    nameLookupURL = \"\".concat(coreNodeSessionValue).concat(_authConstants.NAME_LOOKUP_PATH);\n  }\n\n  return (0, _index.verifyAuthResponse)(authResponseToken, nameLookupURL).then(function (isValid) {\n    if (!isValid) {\n      throw new _errors.LoginFailedError('Invalid authentication response.');\n    }\n\n    var tokenPayload = (0, _jsontokens.decodeToken)(authResponseToken).payload; // TODO: real version handling\n\n    var appPrivateKey = tokenPayload.private_key;\n    var coreSessionToken = tokenPayload.core_token;\n\n    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = (0, _authMessages.decryptPrivateKey)(transitKey, tokenPayload.private_key);\n          } catch (e) {\n            _logger.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n\n            try {\n              (0, _utils.hexStringToECPair)(tokenPayload.private_key);\n            } catch (ecPairError) {\n              throw new _errors.LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            }\n          }\n        }\n\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = (0, _authMessages.decryptPrivateKey)(transitKey, coreSessionToken);\n          } catch (e) {\n            _logger.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new _errors.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n      }\n    }\n\n    var hubUrl = _authConstants.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    var gaiaAssociationToken;\n\n    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n      hubUrl = tokenPayload.hubUrl;\n    }\n\n    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n      gaiaAssociationToken = tokenPayload.associationToken;\n    }\n\n    var userData = {\n      username: tokenPayload.username,\n      profile: tokenPayload.profile,\n      email: tokenPayload.email,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: (0, _index2.getAddressFromDID)(tokenPayload.iss),\n      appPrivateKey: appPrivateKey,\n      coreSessionToken: coreSessionToken,\n      authResponseToken: authResponseToken,\n      hubUrl: hubUrl,\n      gaiaAssociationToken: gaiaAssociationToken\n    };\n    var profileURL = tokenPayload.profile_url;\n\n    if ((userData.profile === null || userData.profile === undefined) && profileURL !== undefined && profileURL !== null) {\n      return fetch(profileURL).then(function (response) {\n        if (!response.ok) {\n          // return blank profile if we fail to fetch\n          userData.profile = Object.assign({}, DEFAULT_PROFILE);\n          var sessionData = caller.store.getSessionData();\n          sessionData.userData = userData;\n          caller.store.setSessionData(sessionData);\n          return userData;\n        } else {\n          return response.text().then(function (responseText) {\n            return JSON.parse(responseText);\n          }).then(function (wrappedProfile) {\n            return (0, _profiles.extractProfile)(wrappedProfile[0].token);\n          }).then(function (profile) {\n            var sessionData = caller.store.getSessionData();\n            userData.profile = profile;\n            sessionData.userData = userData;\n            caller.store.setSessionData(sessionData);\n            return userData;\n          });\n        }\n      });\n    } else {\n      var sessionData = caller.store.getSessionData();\n      userData.profile = tokenPayload.profile;\n      sessionData.userData = userData;\n      caller.store.setSessionData(sessionData);\n      return userData;\n    }\n  });\n}\n/**\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n *\n *  @param {UserSession} caller - the instance calling this function\n *  @return {Object} User data object.\n *  @private\n */\n\n\nfunction loadUserDataImpl(caller) {\n  var userData = caller.store.getSessionData().userData;\n\n  if (!userData) {\n    throw new _errors.InvalidStateError('No user data found. Did the user sign in?');\n  }\n\n  return userData;\n}\n/**\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\n\n\nfunction redirectToSignInWithAuthRequest(authRequest) {\n  var blockstackIDHost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _authConstants.DEFAULT_BLOCKSTACK_HOST;\n  console.warn('DEPRECATION WARNING: The static redirectToSignInWithAuthRequest() function will ' + 'be deprecated in the next major release of blockstack.js. Create an instance of UserSession ' + 'and call the instance method redirectToSignInWithAuthRequest().');\n  var userSession = new _userSession.UserSession();\n  var sessionAuthRequest = authRequest == null ? userSession.makeAuthRequest(userSession.generateAndStoreTransitKey()) : authRequest;\n  userSession.appConfig.authenticatorURL = blockstackIDHost;\n  redirectToSignInWithAuthRequestImpl(userSession, sessionAuthRequest);\n}","map":null,"metadata":{},"sourceType":"script"}