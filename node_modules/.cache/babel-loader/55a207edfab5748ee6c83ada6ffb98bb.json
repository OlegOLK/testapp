{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nexports.__esModule = true;\nexports.makePreorderSkeleton = makePreorderSkeleton;\nexports.makeRegisterSkeleton = makeRegisterSkeleton;\nexports.makeRenewalSkeleton = makeRenewalSkeleton;\nexports.makeTransferSkeleton = makeTransferSkeleton;\nexports.makeUpdateSkeleton = makeUpdateSkeleton;\nexports.makeRevokeSkeleton = makeRevokeSkeleton;\nexports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;\nexports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;\nexports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton;\nexports.makeNameImportSkeleton = makeNameImportSkeleton;\nexports.makeAnnounceSkeleton = makeAnnounceSkeleton;\nexports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;\nexports.BlockstackNamespace = void 0;\n\nvar _bitcoinjsLib = _interopRequireDefault(require(\"bitcoinjs-lib\"));\n\nvar _bigi = _interopRequireDefault(require(\"bigi\"));\n\nvar _utils = require(\"./utils\");\n\nvar _config = require(\"../config\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // todo : add name length / character verification\n\n\nvar BlockstackNamespace =\n/*#__PURE__*/\nfunction () {\n  function BlockstackNamespace(namespaceID) {\n    _classCallCheck(this, BlockstackNamespace);\n\n    if (namespaceID.length > 19) {\n      throw new Error('Namespace ID too long (19 chars max)');\n    }\n\n    if (!namespaceID.match('[0123456789abcdefghijklmnopqrstuvwxyz_-]+')) {\n      throw new Error('Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_');\n    }\n\n    this.namespaceID = namespaceID;\n    this.version = -1;\n    this.lifetime = -1;\n    this.coeff = -1;\n    this.base = -1;\n    this.buckets = [-1];\n    this.nonalphaDiscount = -1;\n    this.noVowelDiscount = -1;\n  }\n\n  _createClass(BlockstackNamespace, [{\n    key: \"check\",\n    value: function check() {\n      try {\n        this.setVersion(this.version);\n        this.setLifetime(this.lifetime);\n        this.setCoeff(this.coeff);\n        this.setBase(this.base);\n        this.setBuckets(this.buckets);\n        this.setNonalphaDiscount(this.nonalphaDiscount);\n        this.setNoVowelDiscount(this.noVowelDiscount);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n  }, {\n    key: \"setVersion\",\n    value: function setVersion(version) {\n      if (version < 0 || version > Math.pow(2, 16) - 1) {\n        throw new Error('Invalid version: must be a 16-bit number');\n      }\n\n      this.version = version;\n    }\n  }, {\n    key: \"setLifetime\",\n    value: function setLifetime(lifetime) {\n      if (lifetime < 0 || lifetime > Math.pow(2, 32) - 1) {\n        throw new Error('Invalid lifetime: must be a 32-bit number');\n      }\n\n      this.lifetime = lifetime;\n    }\n  }, {\n    key: \"setCoeff\",\n    value: function setCoeff(coeff) {\n      if (coeff < 0 || coeff > 255) {\n        throw new Error('Invalid coeff: must be an 8-bit number');\n      }\n\n      this.coeff = coeff;\n    }\n  }, {\n    key: \"setBase\",\n    value: function setBase(base) {\n      if (base < 0 || base > 255) {\n        throw new Error('Invalid base: must be an 8-bit number');\n      }\n\n      this.base = base;\n    }\n  }, {\n    key: \"setBuckets\",\n    value: function setBuckets(buckets) {\n      if (buckets.length !== 16) {\n        throw new Error('Invalid buckets: must have 16 entries');\n      }\n\n      for (var i = 0; i < buckets.length; i++) {\n        if (buckets[i] < 0 || buckets[i] > 15) {\n          throw new Error('Invalid buckets: must be 4-bit numbers');\n        }\n      }\n\n      this.buckets = buckets.slice(0);\n    }\n  }, {\n    key: \"setNonalphaDiscount\",\n    value: function setNonalphaDiscount(nonalphaDiscount) {\n      if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {\n        throw new Error('Invalid nonalphaDiscount: must be a positive 4-bit number');\n      }\n\n      this.nonalphaDiscount = nonalphaDiscount;\n    }\n  }, {\n    key: \"setNoVowelDiscount\",\n    value: function setNoVowelDiscount(noVowelDiscount) {\n      if (noVowelDiscount <= 0 || noVowelDiscount > 15) {\n        throw new Error('Invalid noVowelDiscount: must be a positive 4-bit number');\n      }\n\n      this.noVowelDiscount = noVowelDiscount;\n    }\n  }, {\n    key: \"toHexPayload\",\n    value: function toHexPayload() {\n      var lifeHex = \"00000000\".concat(this.lifetime.toString(16)).slice(-8);\n      var coeffHex = \"00\".concat(this.coeff.toString(16)).slice(-2);\n      var baseHex = \"00\".concat(this.base.toString(16)).slice(-2);\n      var bucketHex = this.buckets.map(function (b) {\n        return b.toString(16);\n      }).reduce(function (b1, b2) {\n        return b1 + b2;\n      }, '');\n      var discountHex = this.nonalphaDiscount.toString(16) + this.noVowelDiscount.toString(16);\n      var versionHex = \"0000\".concat(this.version.toString(16)).slice(-4);\n      var namespaceIDHex = new Buffer(this.namespaceID).toString('hex');\n      return lifeHex + coeffHex + baseHex + bucketHex + discountHex + versionHex + namespaceIDHex;\n    }\n  }]);\n\n  return BlockstackNamespace;\n}();\n\nexports.BlockstackNamespace = BlockstackNamespace;\n\nfunction asAmountV2(amount) {\n  // convert an AmountType v1 or v2 to an AmountTypeV2.\n  // the \"units\" of a v1 amount type are always 'BTC'\n  if (typeof amount === 'number') {\n    return {\n      units: 'BTC',\n      amount: _bigi.default.fromByteArrayUnsigned(String(amount))\n    };\n  } else {\n    return {\n      units: amount.units,\n      amount: amount.amount\n    };\n  }\n}\n\nfunction makeTXbuilder() {\n  var txb = new _bitcoinjsLib.default.TransactionBuilder(_config.config.network.layer1);\n  txb.setVersion(1);\n  return txb;\n}\n\nfunction opEncode(opcode) {\n  // NOTE: must *always* a 3-character string\n  var res = \"\".concat(_config.config.network.MAGIC_BYTES).concat(opcode);\n\n  if (res.length !== 3) {\n    throw new Error('Runtime error: invalid MAGIC_BYTES');\n  }\n\n  return res;\n}\n\nfunction makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burn) {\n  var registerAddress = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n  // Returns a preorder tx skeleton.\n  //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data\n  //                    2. the Preorder's change address (5500 satoshi minimum)\n  //                    3. the BURN\n  //\n  // 0     2  3                                     23             39          47            66\n  // |-----|--|--------------------------------------|--------------|-----------|-------------|\n  // magic op  hash160(fqn,scriptPubkey,registerAddr) consensus hash token burn  token type\n  //                                                                 (optional)   (optional)\n  //\n  // output 0: name preorder code\n  // output 1: preorder address\n  // output 2: burn address\n  //\n  // Returns an unsigned serialized transaction.\n  var burnAmount = asAmountV2(burn);\n  var network = _config.config.network;\n  var nameBuff = Buffer.from((0, _utils.decodeB40)(fullyQualifiedName), 'hex'); // base40\n\n  var scriptPublicKey = _bitcoinjsLib.default.address.toOutputScript(preorderAddress, network.layer1);\n\n  var dataBuffers = [nameBuff, scriptPublicKey];\n\n  if (!!registerAddress) {\n    var registerBuff = Buffer.from(registerAddress, 'ascii');\n    dataBuffers.push(registerBuff);\n  }\n\n  var dataBuff = Buffer.concat(dataBuffers);\n  var hashed = (0, _utils.hash160)(dataBuff);\n  var opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;\n  var opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n  opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');\n  hashed.copy(opReturnBuffer, 3);\n  opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n\n  if (burnAmount.units !== 'BTC') {\n    var burnHex = burnAmount.amount.toHex();\n\n    if (burnHex.length > 16) {\n      // exceeds 2**64; can't fit\n      throw new Error(\"Cannot preorder '\".concat(fullyQualifiedName, \"': cannot fit price into 8 bytes\"));\n    }\n\n    var paddedBurnHex = \"0000000000000000\".concat(burnHex).slice(-16);\n    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n    opReturnBuffer.write(burnAmount.units, 47, burnAmount.units.length, 'ascii');\n  }\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);\n\n  if (burnAmount.units === 'BTC') {\n    var btcBurnAmount = parseInt(burnAmount.amount.toHex(), 16);\n    tx.addOutput(burnAddress, btcBurnAmount);\n  } else {\n    tx.addOutput(burnAddress, _utils.DUST_MINIMUM);\n  }\n\n  return tx.buildIncomplete();\n}\n\nfunction makeRegisterSkeleton(fullyQualifiedName, ownerAddress) {\n  var valueHash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var burnTokenAmountHex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  // Returns a register tx skeleton.\n  //   with 2 outputs : 1. The register OP_RETURN\n  //                    2. The owner address (can be different from REGISTER address on renewals)\n  // You MUST make the first input a UTXO from the current OWNER *or* the\n  //   funder of the PREORDER\n  // in the case of a renewal, this would need to be modified to include a change address\n  //  as output (3) before the burn output (4)\n\n  /*\n    Formats\n     No zonefile hash, and pay with BTC:\n     0    2  3                                  39\n    |----|--|----------------------------------|\n    magic op   name.ns_id (up to 37 bytes)\n      With zonefile hash, and pay with BTC:\n     0    2  3                                  39                  59\n    |----|--|----------------------------------|-------------------|\n    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n     output 0: name registration code\n    output 1: owner address\n  */\n  var payload;\n\n  if (!!burnTokenAmountHex && !valueHash) {\n    // empty value hash\n    valueHash = '0000000000000000000000000000000000000000';\n  }\n\n  if (!!valueHash) {\n    if (valueHash.length !== 40) {\n      throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');\n    }\n\n    if (!!burnTokenAmountHex) {\n      if (burnTokenAmountHex.length !== 16) {\n        throw new Error('Burn field length incorrect.  Expecting 8-bytes, hex-encoded');\n      }\n    }\n\n    var payloadLen = burnTokenAmountHex ? 65 : 57;\n    payload = Buffer.alloc(payloadLen, 0);\n    payload.write(fullyQualifiedName, 0, 37, 'ascii');\n    payload.write(valueHash, 37, 20, 'hex');\n\n    if (!!burnTokenAmountHex) {\n      payload.write(burnTokenAmountHex, 57, 8, 'hex');\n    }\n  } else {\n    payload = Buffer.from(fullyQualifiedName, 'ascii');\n  }\n\n  var opReturnBuffer = Buffer.concat([Buffer.from(opEncode(':'), 'ascii'), payload]);\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(ownerAddress, _utils.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nfunction makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burn) {\n  var valueHash = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n\n  /*\n    Formats\n     No zonefile hash, and pay with BTC:\n     0    2  3                                  39\n    |----|--|----------------------------------|\n    magic op   name.ns_id (up to 37 bytes)\n      With zonefile hash, and pay with BTC:\n     0    2  3                                  39                  59\n    |----|--|----------------------------------|-------------------|\n    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n     With renewal payment in a token:\n   (for register, tokens burned is not included)\n   (for renew, tokens burned is the number of tokens to burn)\n    0    2  3                                  39                  59                            67\n   |----|--|----------------------------------|-------------------|------------------------------|\n   magic op   name.ns_id (37 bytes, 0-padded)     zone file hash    tokens burned (big-endian)\n    output 0: renewal code\n   output 1: new owner address\n   output 2: current owner address\n   output 3: burn address\n  */\n  var burnAmount = asAmountV2(burn);\n  var network = _config.config.network;\n  var burnTokenAmount = burnAmount.units === 'BTC' ? null : burnAmount.amount;\n  var burnBTCAmount = burnAmount.units === 'BTC' ? parseInt(burnAmount.amount.toHex(), 16) : _utils.DUST_MINIMUM;\n  var burnTokenHex = null;\n\n  if (!!burnTokenAmount) {\n    var burnHex = burnTokenAmount.toHex();\n\n    if (burnHex.length > 16) {\n      // exceeds 2**64; can't fit \n      throw new Error(\"Cannot renew '\".concat(fullyQualifiedName, \"': cannot fit price into 8 bytes\"));\n    }\n\n    burnTokenHex = \"0000000000000000\".concat(burnHex).slice(-16);\n  }\n\n  var registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash, burnTokenHex);\n\n  var txB = _bitcoinjsLib.default.TransactionBuilder.fromTransaction(registerTX, network.layer1);\n\n  txB.addOutput(lastOwnerAddress, _utils.DUST_MINIMUM);\n  txB.addOutput(burnAddress, burnBTCAmount);\n  return txB.buildIncomplete();\n}\n\nfunction makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner) {\n  var keepZonefile = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  // Returns a transfer tx skeleton.\n  //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data\n  //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction.\n\n  /*\n    Format\n     0     2  3    4                   20              36\n    |-----|--|----|-------------------|---------------|\n    magic op keep  hash128(name.ns_id) consensus hash\n             data?\n     output 0: transfer code\n    output 1: new owner\n  */\n  var opRet = Buffer.alloc(36);\n  var keepChar = '~';\n\n  if (keepZonefile) {\n    keepChar = '>';\n  }\n\n  opRet.write(opEncode('>'), 0, 3, 'ascii');\n  opRet.write(keepChar, 3, 1, 'ascii');\n  var hashed = (0, _utils.hash128)(Buffer.from(fullyQualifiedName, 'ascii'));\n  hashed.copy(opRet, 4);\n  opRet.write(consensusHash, 20, 16, 'hex');\n\n  var opRetPayload = _bitcoinjsLib.default.payments.embed({\n    data: [opRet]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(opRetPayload, 0);\n  tx.addOutput(newOwner, _utils.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nfunction makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {\n  // Returns an update tx skeleton.\n  //   with 1 output : 1. the Blockstack update OP_RETURN\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction.\n  //\n  // output 0: the revoke code\n\n  /*\n    Format:\n     0     2  3                                   19                      39\n    |-----|--|-----------------------------------|-----------------------|\n    magic op  hash128(name.ns_id,consensus hash) hash160(data)\n     output 0: update code\n  */\n  var opRet = Buffer.alloc(39);\n  var nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n  var consensusBuff = Buffer.from(consensusHash, 'ascii');\n  var hashedName = (0, _utils.hash128)(Buffer.concat([nameBuff, consensusBuff]));\n  opRet.write(opEncode('+'), 0, 3, 'ascii');\n  hashedName.copy(opRet, 3);\n  opRet.write(valueHash, 19, 20, 'hex');\n\n  var opRetPayload = _bitcoinjsLib.default.payments.embed({\n    data: [opRet]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(opRetPayload, 0);\n  return tx.buildIncomplete();\n}\n\nfunction makeRevokeSkeleton(fullyQualifiedName) {\n  // Returns a revoke tx skeleton\n  //    with 1 output: 1. the Blockstack revoke OP_RETURN\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction\n\n  /*\n   Format:\n    0    2  3                             39\n   |----|--|-----------------------------|\n   magic op   name.ns_id (37 bytes)\n    output 0: the revoke code\n  */\n  var opRet = Buffer.alloc(3);\n  var nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n  opRet.write(opEncode('~'), 0, 3, 'ascii');\n  var opReturnBuffer = Buffer.concat([opRet, nameBuff]);\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nfunction makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, registerAddress, burn) {\n  // Returns a namespace preorder tx skeleton.\n  // Returns an unsigned serialized transaction.\n\n  /*\n   Formats:\n    Without STACKS:\n    0     2   3                                      23               39\n   |-----|---|--------------------------------------|----------------|\n   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash\n     with STACKs:\n    0     2   3                                      23               39                         47\n   |-----|---|--------------------------------------|----------------|--------------------------|\n   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash    token fee (big-endian)\n    output 0: namespace preorder code\n   output 1: change address\n   otuput 2: burn address\n  */\n  var burnAmount = asAmountV2(burn);\n\n  if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {\n    throw new Error(\"Invalid burnUnits \".concat(burnAmount.units));\n  }\n\n  var network = _config.config.network;\n  var burnAddress = network.getDefaultBurnAddress();\n  var namespaceIDBuff = Buffer.from((0, _utils.decodeB40)(namespaceID), 'hex'); // base40\n\n  var scriptPublicKey = _bitcoinjsLib.default.address.toOutputScript(preorderAddress, network.layer1);\n\n  var registerBuff = Buffer.from(registerAddress, 'ascii');\n  var dataBuffers = [namespaceIDBuff, scriptPublicKey, registerBuff];\n  var dataBuff = Buffer.concat(dataBuffers);\n  var hashed = (0, _utils.hash160)(dataBuff);\n  var btcBurnAmount = _utils.DUST_MINIMUM;\n  var opReturnBufferLen = 39;\n\n  if (burnAmount.units === 'STACKS') {\n    opReturnBufferLen = 47;\n  } else {\n    btcBurnAmount = parseInt(burnAmount.amount.toHex(), 16);\n  }\n\n  var opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n  opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');\n  hashed.copy(opReturnBuffer, 3);\n  opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n\n  if (burnAmount.units === 'STACKS') {\n    var burnHex = burnAmount.amount.toHex();\n    var paddedBurnHex = \"0000000000000000\".concat(burnHex).slice(-16);\n    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n  }\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(preorderAddress, _utils.DUST_MINIMUM);\n  tx.addOutput(burnAddress, btcBurnAmount);\n  return tx.buildIncomplete();\n}\n\nfunction makeNamespaceRevealSkeleton(namespace, revealAddress) {\n  /*\n   Format:\n    0     2   3    7     8     9    10   11   12   13   14    15    16    17       18      20     39\n   |-----|---|----|-----|-----|----|----|----|----|----|-----|-----|-----|--------|-------|-------|\n   magic  op  life coeff. base 1-2  3-4  5-6  7-8  9-10 11-12 13-14 15-16 nonalpha version  ns ID\n                                                  bucket exponents        no-vowel\n                                                                          discounts\n   \n   output 0: namespace reveal code\n   output 1: reveal address\n  */\n  var hexPayload = namespace.toHexPayload();\n  var opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);\n  opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');\n  opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(revealAddress, _utils.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nfunction makeNamespaceReadySkeleton(namespaceID) {\n  /*\n   Format:\n    0     2  3  4           23\n   |-----|--|--|------------|\n   magic op  .  ns_id\n    output 0: namespace ready code\n   */\n  var opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);\n  opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');\n  opReturnBuffer.write(\".\".concat(namespaceID), 3, namespaceID.length + 1, 'ascii');\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nfunction makeNameImportSkeleton(name, recipientAddr, zonefileHash) {\n  /*\n   Format:\n     0    2  3                             39\n    |----|--|-----------------------------|\n    magic op   name.ns_id (37 bytes)\n    Output 0: the OP_RETURN\n   Output 1: the recipient\n   Output 2: the zonefile hash\n  */\n  if (zonefileHash.length !== 40) {\n    throw new Error('Invalid zonefile hash: must be 20 bytes hex-encoded');\n  }\n\n  var network = _config.config.network;\n  var opReturnBuffer = Buffer.alloc(3 + name.length);\n  opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');\n  opReturnBuffer.write(name, 3, name.length, 'ascii');\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n\n  var zonefileHashB58 = _bitcoinjsLib.default.address.toBase58Check(new Buffer(zonefileHash, 'hex'), network.layer1.pubKeyHash);\n\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(recipientAddr, _utils.DUST_MINIMUM);\n  tx.addOutput(zonefileHashB58, _utils.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nfunction makeAnnounceSkeleton(messageHash) {\n  /*\n    Format:\n     0    2  3                             23\n    |----|--|-----------------------------|\n    magic op   message hash (160-bit)\n     output 0: the OP_RETURN\n  */\n  if (messageHash.length !== 40) {\n    throw new Error('Invalid message hash: must be 20 bytes hex-encoded');\n  }\n\n  var opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);\n  opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');\n  opReturnBuffer.write(messageHash, 3, messageHash.length / 2, 'hex');\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nfunction makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea) {\n  /*\n   Format:\n     0     2  3              19         38          46                        80\n    |-----|--|--------------|----------|-----------|-------------------------|\n    magic op  consensus_hash token_type amount (BE) scratch area\n                             (ns_id)\n     output 0: token transfer code\n    output 1: recipient address\n  */\n  if (scratchArea.length > 34) {\n    throw new Error('Invalid scratch area: must be no more than 34 bytes');\n  }\n\n  var opReturnBuffer = Buffer.alloc(46 + scratchArea.length);\n  var tokenTypeHex = new Buffer(tokenType).toString('hex');\n  var tokenTypeHexPadded = \"00000000000000000000000000000000000000\".concat(tokenTypeHex).slice(-38);\n  var tokenValueHex = tokenAmount.toHex();\n\n  if (tokenValueHex.length > 16) {\n    // exceeds 2**64; can't fit\n    throw new Error(\"Cannot send tokens: cannot fit \".concat(tokenAmount.toString(), \" into 8 bytes\"));\n  }\n\n  var tokenValueHexPadded = \"0000000000000000\".concat(tokenValueHex).slice(-16);\n  opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');\n  opReturnBuffer.write(consensusHash, 3, consensusHash.length / 2, 'hex');\n  opReturnBuffer.write(tokenTypeHexPadded, 19, tokenTypeHexPadded.length / 2, 'hex');\n  opReturnBuffer.write(tokenValueHexPadded, 38, tokenValueHexPadded.length / 2, 'hex');\n  opReturnBuffer.write(scratchArea, 46, scratchArea.length, 'ascii');\n\n  var nullOutput = _bitcoinjsLib.default.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n\n  var tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(recipientAddress, _utils.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}","map":null,"metadata":{},"sourceType":"script"}