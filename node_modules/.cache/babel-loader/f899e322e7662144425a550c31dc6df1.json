{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.signProfileToken = signProfileToken;\nexports.wrapProfileToken = wrapProfileToken;\nexports.verifyProfileToken = verifyProfileToken;\nexports.extractProfile = extractProfile;\n\nvar _bitcoinjsLib = require(\"bitcoinjs-lib\");\n\nvar _jsontokens = require(\"jsontokens\");\n\nvar _utils = require(\"../utils\");\n/**\n  * Signs a profile token\n  * @param {Object} profile - the JSON of the profile to be signed\n  * @param {String} privateKey - the signing private key\n  * @param {Object} subject - the entity that the information is about\n  * @param {Object} issuer - the entity that is issuing the token\n  * @param {String} signingAlgorithm - the signing algorithm to use\n  * @param {Date} issuedAt - the time of issuance of the token\n  * @param {Date} expiresAt - the time of expiration of the token\n  * @returns {Object} - the signed profile token\n  */\n\n\nfunction signProfileToken(profile, privateKey) {\n  var subject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var issuer = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  var signingAlgorithm = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 'ES256K';\n  var issuedAt = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Date();\n  var expiresAt = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : (0, _utils.nextYear)();\n\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  var publicKey = _jsontokens.SECP256K1Client.derivePublicKey(privateKey);\n\n  if (subject === null) {\n    subject = {\n      publicKey: publicKey\n    };\n  }\n\n  if (issuer === null) {\n    issuer = {\n      publicKey: publicKey\n    };\n  }\n\n  var tokenSigner = new _jsontokens.TokenSigner(signingAlgorithm, privateKey);\n  var payload = {\n    jti: (0, _utils.makeUUID4)(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject: subject,\n    issuer: issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\n/**\n  * Wraps a token for a profile token file\n  * @param {String} token - the token to be wrapped\n  * @returns {Object} - including `token` and `decodedToken`\n  */\n\n\nfunction wrapProfileToken(token) {\n  return {\n    token: token,\n    decodedToken: (0, _jsontokens.decodeToken)(token)\n  };\n}\n/**\n  * Verifies a profile token\n  * @param {String} token - the token to be verified\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the verified, decoded profile token\n  * @throws {Error} - throws an error if token verification fails\n  */\n\n\nfunction verifyProfileToken(token, publicKeyOrAddress) {\n  var decodedToken = (0, _jsontokens.decodeToken)(token);\n  var payload = decodedToken.payload; // Inspect and verify the subject\n\n  if (payload.hasOwnProperty('subject')) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have a subject public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have a subject');\n  } // Inspect and verify the issuer\n\n\n  if (payload.hasOwnProperty('issuer')) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have an issuer public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have an issuer');\n  } // Inspect and verify the claim\n\n\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error('Token doesn\\'t have a claim');\n  }\n\n  var issuerPublicKey = payload.issuer.publicKey;\n  var publicKeyBuffer = new Buffer(issuerPublicKey, 'hex');\n\n  var compressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: true\n  });\n\n  var compressedAddress = (0, _utils.ecPairToAddress)(compressedKeyPair);\n\n  var uncompressedKeyPair = _bitcoinjsLib.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: false\n  });\n\n  var uncompressedAddress = (0, _utils.ecPairToAddress)(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {// pass\n  } else if (publicKeyOrAddress === compressedAddress) {// pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {// pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  var tokenVerifier = new _jsontokens.TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  var tokenVerified = tokenVerifier.verify(token);\n\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n/**\n  * Extracts a profile from an encoded token and optionally verifies it,\n  * if `publicKeyOrAddress` is provided.\n  * @param {String} token - the token to be extracted\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the profile extracted from the encoded token\n  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n  */\n\n\nfunction extractProfile(token) {\n  var publicKeyOrAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var decodedToken;\n\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = (0, _jsontokens.decodeToken)(token);\n  }\n\n  var profile = {};\n\n  if (decodedToken.hasOwnProperty('payload')) {\n    var payload = decodedToken.payload;\n\n    if (payload.hasOwnProperty('claim')) {\n      profile = decodedToken.payload.claim;\n    }\n  }\n\n  return profile;\n}","map":null,"metadata":{},"sourceType":"script"}