"use strict";

exports.__esModule = true;
exports.validateProofs = validateProofs;

var _services = require("./services");

/**
 * Validates the social proofs in a user's profile. Currently supports validation of 
 * Facebook, Twitter, GitHub, Instagram, LinkedIn and HackerNews accounts.
 *
 * @param {Object} profile The JSON of the profile to be validated
 * @param {string} ownerAddress The owner bitcoin address to be validated
 * @param {string} [name=null] The Blockstack name to be validated 
 * @returns {Promise} that resolves to an array of validated proof objects
 */
function validateProofs(profile, ownerAddress, name = null) {
  if (!profile) {
    throw new Error('Profile must not be null');
  }

  let accounts = [];
  const proofsToValidate = [];

  if (profile.hasOwnProperty('account')) {
    accounts = profile.account;
  } else {
    return Promise.resolve([]);
  }

  accounts.forEach(account => {
    // skip if proof service is not supported
    if (account.hasOwnProperty('service') && !_services.profileServices.hasOwnProperty(account.service)) {
      return;
    }

    if (!(account.hasOwnProperty('proofType') && account.proofType === 'http' && account.hasOwnProperty('proofUrl'))) {
      return;
    }

    const proof = {
      service: account.service,
      proof_url: account.proofUrl,
      identifier: account.identifier,
      valid: false
    };
    proofsToValidate.push(_services.profileServices[account.service].validateProof(proof, ownerAddress, name));
  });
  return Promise.all(proofsToValidate);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9wcm9maWxlcy9wcm9maWxlUHJvb2ZzLmpzIl0sIm5hbWVzIjpbInZhbGlkYXRlUHJvb2ZzIiwicHJvZmlsZSIsIm93bmVyQWRkcmVzcyIsIm5hbWUiLCJFcnJvciIsImFjY291bnRzIiwicHJvb2ZzVG9WYWxpZGF0ZSIsImhhc093blByb3BlcnR5IiwiYWNjb3VudCIsIlByb21pc2UiLCJyZXNvbHZlIiwiZm9yRWFjaCIsInByb2ZpbGVTZXJ2aWNlcyIsInNlcnZpY2UiLCJwcm9vZlR5cGUiLCJwcm9vZiIsInByb29mX3VybCIsInByb29mVXJsIiwiaWRlbnRpZmllciIsInZhbGlkIiwicHVzaCIsInZhbGlkYXRlUHJvb2YiLCJhbGwiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7O0FBRUE7Ozs7Ozs7OztBQVNPLFNBQVNBLGNBQVQsQ0FBd0JDLE9BQXhCLEVBQ3dCQyxZQUR4QixFQUV3QkMsSUFBYSxHQUFHLElBRnhDLEVBRThDO0FBQ25ELE1BQUksQ0FBQ0YsT0FBTCxFQUFjO0FBQ1osVUFBTSxJQUFJRyxLQUFKLENBQVUsMEJBQVYsQ0FBTjtBQUNEOztBQUVELE1BQUlDLFFBQW9CLEdBQUcsRUFBM0I7QUFDQSxRQUFNQyxnQkFBZ0IsR0FBRyxFQUF6Qjs7QUFFQSxNQUFJTCxPQUFPLENBQUNNLGNBQVIsQ0FBdUIsU0FBdkIsQ0FBSixFQUF1QztBQUNyQ0YsSUFBQUEsUUFBUSxHQUFHSixPQUFPLENBQUNPLE9BQW5CO0FBQ0QsR0FGRCxNQUVPO0FBQ0wsV0FBT0MsT0FBTyxDQUFDQyxPQUFSLENBQWdCLEVBQWhCLENBQVA7QUFDRDs7QUFFREwsRUFBQUEsUUFBUSxDQUFDTSxPQUFULENBQWtCSCxPQUFELElBQWE7QUFDNUI7QUFDQSxRQUFJQSxPQUFPLENBQUNELGNBQVIsQ0FBdUIsU0FBdkIsS0FDRyxDQUFDSywwQkFBZ0JMLGNBQWhCLENBQStCQyxPQUFPLENBQUNLLE9BQXZDLENBRFIsRUFDeUQ7QUFDdkQ7QUFDRDs7QUFFRCxRQUFJLEVBQUVMLE9BQU8sQ0FBQ0QsY0FBUixDQUF1QixXQUF2QixLQUNDQyxPQUFPLENBQUNNLFNBQVIsS0FBc0IsTUFEdkIsSUFFQ04sT0FBTyxDQUFDRCxjQUFSLENBQXVCLFVBQXZCLENBRkgsQ0FBSixFQUU0QztBQUMxQztBQUNEOztBQUVELFVBQU1RLEtBQUssR0FBRztBQUNaRixNQUFBQSxPQUFPLEVBQUVMLE9BQU8sQ0FBQ0ssT0FETDtBQUVaRyxNQUFBQSxTQUFTLEVBQUVSLE9BQU8sQ0FBQ1MsUUFGUDtBQUdaQyxNQUFBQSxVQUFVLEVBQUVWLE9BQU8sQ0FBQ1UsVUFIUjtBQUlaQyxNQUFBQSxLQUFLLEVBQUU7QUFKSyxLQUFkO0FBT0FiLElBQUFBLGdCQUFnQixDQUFDYyxJQUFqQixDQUFzQlIsMEJBQWdCSixPQUFPLENBQUNLLE9BQXhCLEVBQ25CUSxhQURtQixDQUNMTixLQURLLEVBQ0ViLFlBREYsRUFDZ0JDLElBRGhCLENBQXRCO0FBRUQsR0F0QkQ7QUF3QkEsU0FBT00sT0FBTyxDQUFDYSxHQUFSLENBQVloQixnQkFBWixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuaW1wb3J0IHsgcHJvZmlsZVNlcnZpY2VzIH0gZnJvbSAnLi9zZXJ2aWNlcydcblxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIHNvY2lhbCBwcm9vZnMgaW4gYSB1c2VyJ3MgcHJvZmlsZS4gQ3VycmVudGx5IHN1cHBvcnRzIHZhbGlkYXRpb24gb2YgXG4gKiBGYWNlYm9vaywgVHdpdHRlciwgR2l0SHViLCBJbnN0YWdyYW0sIExpbmtlZEluIGFuZCBIYWNrZXJOZXdzIGFjY291bnRzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9maWxlIFRoZSBKU09OIG9mIHRoZSBwcm9maWxlIHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IG93bmVyQWRkcmVzcyBUaGUgb3duZXIgYml0Y29pbiBhZGRyZXNzIHRvIGJlIHZhbGlkYXRlZFxuICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lPW51bGxdIFRoZSBCbG9ja3N0YWNrIG5hbWUgdG8gYmUgdmFsaWRhdGVkIFxuICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgdmFsaWRhdGVkIHByb29mIG9iamVjdHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvb2ZzKHByb2ZpbGU6IE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvd25lckFkZHJlc3M6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiA/c3RyaW5nID0gbnVsbCkge1xuICBpZiAoIXByb2ZpbGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2ZpbGUgbXVzdCBub3QgYmUgbnVsbCcpXG4gIH1cblxuICBsZXQgYWNjb3VudHM6IEFycmF5PGFueT4gPSBbXVxuICBjb25zdCBwcm9vZnNUb1ZhbGlkYXRlID0gW11cblxuICBpZiAocHJvZmlsZS5oYXNPd25Qcm9wZXJ0eSgnYWNjb3VudCcpKSB7XG4gICAgYWNjb3VudHMgPSBwcm9maWxlLmFjY291bnRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKVxuICB9XG5cbiAgYWNjb3VudHMuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgIC8vIHNraXAgaWYgcHJvb2Ygc2VydmljZSBpcyBub3Qgc3VwcG9ydGVkXG4gICAgaWYgKGFjY291bnQuaGFzT3duUHJvcGVydHkoJ3NlcnZpY2UnKVxuICAgICAgICAmJiAhcHJvZmlsZVNlcnZpY2VzLmhhc093blByb3BlcnR5KGFjY291bnQuc2VydmljZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghKGFjY291bnQuaGFzT3duUHJvcGVydHkoJ3Byb29mVHlwZScpXG4gICAgICAgICYmIGFjY291bnQucHJvb2ZUeXBlID09PSAnaHR0cCdcbiAgICAgICAgJiYgYWNjb3VudC5oYXNPd25Qcm9wZXJ0eSgncHJvb2ZVcmwnKSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHByb29mID0ge1xuICAgICAgc2VydmljZTogYWNjb3VudC5zZXJ2aWNlLFxuICAgICAgcHJvb2ZfdXJsOiBhY2NvdW50LnByb29mVXJsLFxuICAgICAgaWRlbnRpZmllcjogYWNjb3VudC5pZGVudGlmaWVyLFxuICAgICAgdmFsaWQ6IGZhbHNlXG4gICAgfVxuXG4gICAgcHJvb2ZzVG9WYWxpZGF0ZS5wdXNoKHByb2ZpbGVTZXJ2aWNlc1thY2NvdW50LnNlcnZpY2VdXG4gICAgICAudmFsaWRhdGVQcm9vZihwcm9vZiwgb3duZXJBZGRyZXNzLCBuYW1lKSlcbiAgfSlcblxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvb2ZzVG9WYWxpZGF0ZSlcbn1cbiJdfQ==