"use strict";

exports.__esModule = true;
exports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;
exports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;
exports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;
exports.isIssuanceDateValid = isIssuanceDateValid;
exports.isExpirationDateValid = isExpirationDateValid;
exports.isManifestUriValid = isManifestUriValid;
exports.isRedirectUriValid = isRedirectUriValid;
exports.verifyAuthRequest = verifyAuthRequest;
exports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;
exports.verifyAuthResponse = verifyAuthResponse;

var _jsontokens = require("jsontokens");

var _index = require("../index");

var _ = require(".");

/**
 * Checks if the ES256k signature on passed `token` match the claimed public key
 * in the payload key `public_keys`.
 *
 * @param  {String} token encoded and signed authentication token
 * @return {Boolean} Returns `true` if the signature matches the claimed public key
 * @throws {Error} if `token` contains multiple public keys
 * @private
 */
function doSignaturesMatchPublicKeys(token) {
  const payload = (0, _jsontokens.decodeToken)(token).payload;
  const publicKeys = payload.public_keys;

  if (publicKeys.length === 1) {
    const publicKey = publicKeys[0];

    try {
      const tokenVerifier = new _jsontokens.TokenVerifier('ES256k', publicKey);
      const signatureVerified = tokenVerifier.verify(token);

      if (signatureVerified) {
        return true;
      } else {
        return false;
      }
    } catch (e) {
      return false;
    }
  } else {
    throw new Error('Multiple public keys are not supported');
  }
}
/**
 * Makes sure that the identity address portion of
 * the decentralized identifier passed in the issuer `iss`
 * key of the token matches the public key
 *
 * @param  {String} token encoded and signed authentication token
 * @return {Boolean} if the identity address and public keys match
 * @throws {Error} if ` token` has multiple public keys
 * @private
 */


function doPublicKeysMatchIssuer(token) {
  const payload = (0, _jsontokens.decodeToken)(token).payload;
  const publicKeys = payload.public_keys;
  const addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);

  if (publicKeys.length === 1) {
    const addressFromPublicKeys = (0, _index.publicKeyToAddress)(publicKeys[0]);

    if (addressFromPublicKeys === addressFromIssuer) {
      return true;
    }
  } else {
    throw new Error('Multiple public keys are not supported');
  }

  return false;
}
/**
 * Looks up the identity address that owns the claimed username
 * in `token` using the lookup endpoint provided in `nameLookupURL`
 * to determine if the username is owned by the identity address
 * that matches the claimed public key
 *
 * @param  {String} token  encoded and signed authentication token
 * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API
 * @return {Promise<Boolean>} returns a `Promise` that resolves to
 * `true` if the username is owned by the public key, otherwise the
 * `Promise` resolves to `false`
 * @private
 */


function doPublicKeysMatchUsername(token, nameLookupURL) {
  return Promise.resolve().then(() => {
    const payload = (0, _jsontokens.decodeToken)(token).payload;

    if (!payload.username) {
      return true;
    }

    if (payload.username === null) {
      return true;
    }

    if (nameLookupURL === null) {
      return false;
    }

    const username = payload.username;
    const url = `${nameLookupURL.replace(/\/$/, '')}/${username}`;
    return fetch(url).then(response => response.text()).then(responseText => {
      const responseJSON = JSON.parse(responseText);

      if (responseJSON.hasOwnProperty('address')) {
        const nameOwningAddress = responseJSON.address;
        const addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);

        if (nameOwningAddress === addressFromIssuer) {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    });
  }).catch(() => false);
}
/**
 * Checks if the if the token issuance time and date is after the
 * current time and date.
 *
 * @param  {String}  token encoded and signed authentication token
 * @return {Boolean} `true` if the token was issued after the current time,
 * otherwise returns `false`
 * @private
 */


function isIssuanceDateValid(token) {
  const payload = (0, _jsontokens.decodeToken)(token).payload;

  if (payload.iat) {
    if (typeof payload.iat !== 'number') {
      return false;
    }

    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds

    if (new Date().getTime() < issuedAt.getTime()) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}
/**
 * Checks if the expiration date of the `token` is before the current time
 * @param  {String}  token encoded and signed authentication token
 * @return {Boolean} `true` if the `token` has not yet expired, `false`
 * if the `token` has expired
 *
 * @private
 */


function isExpirationDateValid(token) {
  const payload = (0, _jsontokens.decodeToken)(token).payload;

  if (payload.exp) {
    if (typeof payload.exp !== 'number') {
      return false;
    }

    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds

    if (new Date().getTime() > expiresAt.getTime()) {
      return false;
    } else {
      return true;
    }
  } else {
    return true;
  }
}
/**
 * Makes sure the `manifest_uri` is a same origin absolute URL.
 * @param  {String}  token encoded and signed authentication token
 * @return {Boolean} `true` if valid, otherwise `false`
 * @private
 */


function isManifestUriValid(token) {
  const payload = (0, _jsontokens.decodeToken)(token).payload;
  return (0, _index.isSameOriginAbsoluteUrl)(payload.domain_name, payload.manifest_uri);
}
/**
 * Makes sure the `redirect_uri` is a same origin absolute URL.
 * @param  {String}  token encoded and signed authentication token
 * @return {Boolean} `true` if valid, otherwise `false`
 * @private
 */


function isRedirectUriValid(token) {
  const payload = (0, _jsontokens.decodeToken)(token).payload;
  return (0, _index.isSameOriginAbsoluteUrl)(payload.domain_name, payload.redirect_uri);
}
/**
 * Verify authentication request is valid. This function performs a number
 * of checks on the authentication request token:
 * * Checks that `token` has a valid issuance date & is not expired
 * * Checks that `token` has a valid signature that matches the public key it claims
 * * Checks that both the manifest and redirect URLs are absolute and conform to
 * the same origin policy
 *
 * @param  {String} token encoded and signed authentication request token
 * @return {Promise} that resolves to true if the auth request
 *  is valid and false if it does not. It rejects with a String if the
 *  token is not signed
 *  @private
 */


function verifyAuthRequest(token) {
  return Promise.resolve().then(() => {
    if ((0, _jsontokens.decodeToken)(token).header.alg === 'none') {
      throw new Error('Token must be signed in order to be verified');
    }
  }).then(() => Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)])).then(values => {
    if (values.every(Boolean)) {
      return true;
    } else {
      return false;
    }
  });
}
/**
 * Verify the authentication request is valid and
 * fetch the app manifest file if valid. Otherwise, reject the promise.
 * @param  {String} token encoded and signed authentication request token
 * @return {Promise} that resolves to the app manifest file in JSON format
 * or rejects if the auth request or app manifest file is invalid
 * @private
 */


function verifyAuthRequestAndLoadManifest(token) {
  return Promise.resolve().then(() => verifyAuthRequest(token).then(valid => {
    if (valid) {
      return (0, _.fetchAppManifest)(token);
    } else {
      return Promise.reject();
    }
  }));
}
/**
 * Verify the authentication response is valid
 * @param {String} token the authentication response token
 * @param {String} nameLookupURL the url use to verify owner of a username
 * @return {Promise} that resolves to true if auth response
 * is valid and false if it does not
 * @private
 */


function verifyAuthResponse(token, nameLookupURL) {
  return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]).then(values => {
    if (values.every(Boolean)) {
      return true;
    } else {
      return false;
    }
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdXRoL2F1dGhWZXJpZmljYXRpb24uanMiXSwibmFtZXMiOlsiZG9TaWduYXR1cmVzTWF0Y2hQdWJsaWNLZXlzIiwidG9rZW4iLCJwYXlsb2FkIiwicHVibGljS2V5cyIsInB1YmxpY19rZXlzIiwibGVuZ3RoIiwicHVibGljS2V5IiwidG9rZW5WZXJpZmllciIsIlRva2VuVmVyaWZpZXIiLCJzaWduYXR1cmVWZXJpZmllZCIsInZlcmlmeSIsImUiLCJFcnJvciIsImRvUHVibGljS2V5c01hdGNoSXNzdWVyIiwiYWRkcmVzc0Zyb21Jc3N1ZXIiLCJpc3MiLCJhZGRyZXNzRnJvbVB1YmxpY0tleXMiLCJkb1B1YmxpY0tleXNNYXRjaFVzZXJuYW1lIiwibmFtZUxvb2t1cFVSTCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsInVzZXJuYW1lIiwidXJsIiwicmVwbGFjZSIsImZldGNoIiwicmVzcG9uc2UiLCJ0ZXh0IiwicmVzcG9uc2VUZXh0IiwicmVzcG9uc2VKU09OIiwiSlNPTiIsInBhcnNlIiwiaGFzT3duUHJvcGVydHkiLCJuYW1lT3duaW5nQWRkcmVzcyIsImFkZHJlc3MiLCJjYXRjaCIsImlzSXNzdWFuY2VEYXRlVmFsaWQiLCJpYXQiLCJpc3N1ZWRBdCIsIkRhdGUiLCJnZXRUaW1lIiwiaXNFeHBpcmF0aW9uRGF0ZVZhbGlkIiwiZXhwIiwiZXhwaXJlc0F0IiwiaXNNYW5pZmVzdFVyaVZhbGlkIiwiZG9tYWluX25hbWUiLCJtYW5pZmVzdF91cmkiLCJpc1JlZGlyZWN0VXJpVmFsaWQiLCJyZWRpcmVjdF91cmkiLCJ2ZXJpZnlBdXRoUmVxdWVzdCIsImhlYWRlciIsImFsZyIsImFsbCIsInZhbHVlcyIsImV2ZXJ5IiwiQm9vbGVhbiIsInZlcmlmeUF1dGhSZXF1ZXN0QW5kTG9hZE1hbmlmZXN0IiwidmFsaWQiLCJyZWplY3QiLCJ2ZXJpZnlBdXRoUmVzcG9uc2UiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQ0E7O0FB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ekIsYUFBTyxJQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBTyxLQUFQO0FBQ0Q7QUFDRixHQVpNLENBQVA7QUFhRCIsInNvdXJjZXNDb250ZW50IjpbIi8vIEBmbG93XG5pbXBvcnQgeyBkZWNvZGVUb2tlbiwgVG9rZW5WZXJpZmllciB9IGZyb20gJ2pzb250b2tlbnMnXG5pbXBvcnQge1xuICBnZXRBZGRyZXNzRnJvbURJRCwgcHVibGljS2V5VG9BZGRyZXNzLFxuICBpc1NhbWVPcmlnaW5BYnNvbHV0ZVVybFxufSBmcm9tICcuLi9pbmRleCdcblxuaW1wb3J0IHtcbiAgZmV0Y2hBcHBNYW5pZmVzdFxufSBmcm9tICcuJ1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgRVMyNTZrIHNpZ25hdHVyZSBvbiBwYXNzZWQgYHRva2VuYCBtYXRjaCB0aGUgY2xhaW1lZCBwdWJsaWMga2V5XG4gKiBpbiB0aGUgcGF5bG9hZCBrZXkgYHB1YmxpY19rZXlzYC5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRva2VuIGVuY29kZWQgYW5kIHNpZ25lZCBhdXRoZW50aWNhdGlvbiB0b2tlblxuICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzIHRoZSBjbGFpbWVkIHB1YmxpYyBrZXlcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBgdG9rZW5gIGNvbnRhaW5zIG11bHRpcGxlIHB1YmxpYyBrZXlzXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZG9TaWduYXR1cmVzTWF0Y2hQdWJsaWNLZXlzKHRva2VuOiBzdHJpbmcpIHtcbiAgY29uc3QgcGF5bG9hZCA9IGRlY29kZVRva2VuKHRva2VuKS5wYXlsb2FkXG4gIGNvbnN0IHB1YmxpY0tleXMgPSBwYXlsb2FkLnB1YmxpY19rZXlzXG4gIGlmIChwdWJsaWNLZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleXNbMF1cbiAgICB0cnkge1xuICAgICAgY29uc3QgdG9rZW5WZXJpZmllciA9IG5ldyBUb2tlblZlcmlmaWVyKCdFUzI1NmsnLCBwdWJsaWNLZXkpXG4gICAgICBjb25zdCBzaWduYXR1cmVWZXJpZmllZCA9IHRva2VuVmVyaWZpZXIudmVyaWZ5KHRva2VuKVxuICAgICAgaWYgKHNpZ25hdHVyZVZlcmlmaWVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdWx0aXBsZSBwdWJsaWMga2V5cyBhcmUgbm90IHN1cHBvcnRlZCcpXG4gIH1cbn1cblxuLyoqXG4gKiBNYWtlcyBzdXJlIHRoYXQgdGhlIGlkZW50aXR5IGFkZHJlc3MgcG9ydGlvbiBvZlxuICogdGhlIGRlY2VudHJhbGl6ZWQgaWRlbnRpZmllciBwYXNzZWQgaW4gdGhlIGlzc3VlciBgaXNzYFxuICoga2V5IG9mIHRoZSB0b2tlbiBtYXRjaGVzIHRoZSBwdWJsaWMga2V5XG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0b2tlbiBlbmNvZGVkIGFuZCBzaWduZWQgYXV0aGVudGljYXRpb24gdG9rZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBpZGVudGl0eSBhZGRyZXNzIGFuZCBwdWJsaWMga2V5cyBtYXRjaFxuICogQHRocm93cyB7RXJyb3J9IGlmIGAgdG9rZW5gIGhhcyBtdWx0aXBsZSBwdWJsaWMga2V5c1xuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvUHVibGljS2V5c01hdGNoSXNzdWVyKHRva2VuOiBzdHJpbmcpIHtcbiAgY29uc3QgcGF5bG9hZCA9IGRlY29kZVRva2VuKHRva2VuKS5wYXlsb2FkXG4gIGNvbnN0IHB1YmxpY0tleXMgPSBwYXlsb2FkLnB1YmxpY19rZXlzXG4gIGNvbnN0IGFkZHJlc3NGcm9tSXNzdWVyID0gZ2V0QWRkcmVzc0Zyb21ESUQocGF5bG9hZC5pc3MpXG5cbiAgaWYgKHB1YmxpY0tleXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgYWRkcmVzc0Zyb21QdWJsaWNLZXlzID0gcHVibGljS2V5VG9BZGRyZXNzKHB1YmxpY0tleXNbMF0pXG4gICAgaWYgKGFkZHJlc3NGcm9tUHVibGljS2V5cyA9PT0gYWRkcmVzc0Zyb21Jc3N1ZXIpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVsdGlwbGUgcHVibGljIGtleXMgYXJlIG5vdCBzdXBwb3J0ZWQnKVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogTG9va3MgdXAgdGhlIGlkZW50aXR5IGFkZHJlc3MgdGhhdCBvd25zIHRoZSBjbGFpbWVkIHVzZXJuYW1lXG4gKiBpbiBgdG9rZW5gIHVzaW5nIHRoZSBsb29rdXAgZW5kcG9pbnQgcHJvdmlkZWQgaW4gYG5hbWVMb29rdXBVUkxgXG4gKiB0byBkZXRlcm1pbmUgaWYgdGhlIHVzZXJuYW1lIGlzIG93bmVkIGJ5IHRoZSBpZGVudGl0eSBhZGRyZXNzXG4gKiB0aGF0IG1hdGNoZXMgdGhlIGNsYWltZWQgcHVibGljIGtleVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdG9rZW4gIGVuY29kZWQgYW5kIHNpZ25lZCBhdXRoZW50aWNhdGlvbiB0b2tlblxuICogQHBhcmFtICB7U3RyaW5nfSBuYW1lTG9va3VwVVJMIGEgVVJMIHRvIHRoZSBuYW1lIGxvb2t1cCBlbmRwb2ludCBvZiB0aGUgQmxvY2tzdGFjayBDb3JlIEFQSVxuICogQHJldHVybiB7UHJvbWlzZTxCb29sZWFuPn0gcmV0dXJucyBhIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIHRvXG4gKiBgdHJ1ZWAgaWYgdGhlIHVzZXJuYW1lIGlzIG93bmVkIGJ5IHRoZSBwdWJsaWMga2V5LCBvdGhlcndpc2UgdGhlXG4gKiBgUHJvbWlzZWAgcmVzb2x2ZXMgdG8gYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRvUHVibGljS2V5c01hdGNoVXNlcm5hbWUodG9rZW46IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVMb29rdXBVUkw6IHN0cmluZykge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgY29uc3QgcGF5bG9hZCA9IGRlY29kZVRva2VuKHRva2VuKS5wYXlsb2FkXG5cbiAgICBpZiAoIXBheWxvYWQudXNlcm5hbWUpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHBheWxvYWQudXNlcm5hbWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKG5hbWVMb29rdXBVUkwgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGNvbnN0IHVzZXJuYW1lID0gcGF5bG9hZC51c2VybmFtZVxuICAgIGNvbnN0IHVybCA9IGAke25hbWVMb29rdXBVUkwucmVwbGFjZSgvXFwvJC8sICcnKX0vJHt1c2VybmFtZX1gXG4gICAgcmV0dXJuIGZldGNoKHVybClcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLnRleHQoKSlcbiAgICAgIC50aGVuKChyZXNwb25zZVRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VKU09OID0gSlNPTi5wYXJzZShyZXNwb25zZVRleHQpXG4gICAgICAgIGlmIChyZXNwb25zZUpTT04uaGFzT3duUHJvcGVydHkoJ2FkZHJlc3MnKSkge1xuICAgICAgICAgIGNvbnN0IG5hbWVPd25pbmdBZGRyZXNzID0gcmVzcG9uc2VKU09OLmFkZHJlc3NcbiAgICAgICAgICBjb25zdCBhZGRyZXNzRnJvbUlzc3VlciA9IGdldEFkZHJlc3NGcm9tRElEKHBheWxvYWQuaXNzKVxuICAgICAgICAgIGlmIChuYW1lT3duaW5nQWRkcmVzcyA9PT0gYWRkcmVzc0Zyb21Jc3N1ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSlcbiAgfSkuY2F0Y2goKCkgPT4gZmFsc2UpXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBpZiB0aGUgdG9rZW4gaXNzdWFuY2UgdGltZSBhbmQgZGF0ZSBpcyBhZnRlciB0aGVcbiAqIGN1cnJlbnQgdGltZSBhbmQgZGF0ZS5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICB0b2tlbiBlbmNvZGVkIGFuZCBzaWduZWQgYXV0aGVudGljYXRpb24gdG9rZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdG9rZW4gd2FzIGlzc3VlZCBhZnRlciB0aGUgY3VycmVudCB0aW1lLFxuICogb3RoZXJ3aXNlIHJldHVybnMgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSXNzdWFuY2VEYXRlVmFsaWQodG9rZW46IHN0cmluZykge1xuICBjb25zdCBwYXlsb2FkID0gZGVjb2RlVG9rZW4odG9rZW4pLnBheWxvYWRcbiAgaWYgKHBheWxvYWQuaWF0KSB7XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLmlhdCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBjb25zdCBpc3N1ZWRBdCA9IG5ldyBEYXRlKHBheWxvYWQuaWF0ICogMTAwMCkgLy8gSldUIHRpbWVzIGFyZSBpbiBzZWNvbmRzXG4gICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIDwgaXNzdWVkQXQuZ2V0VGltZSgpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZXhwaXJhdGlvbiBkYXRlIG9mIHRoZSBgdG9rZW5gIGlzIGJlZm9yZSB0aGUgY3VycmVudCB0aW1lXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICB0b2tlbiBlbmNvZGVkIGFuZCBzaWduZWQgYXV0aGVudGljYXRpb24gdG9rZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYHRva2VuYCBoYXMgbm90IHlldCBleHBpcmVkLCBgZmFsc2VgXG4gKiBpZiB0aGUgYHRva2VuYCBoYXMgZXhwaXJlZFxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0V4cGlyYXRpb25EYXRlVmFsaWQodG9rZW46IHN0cmluZykge1xuICBjb25zdCBwYXlsb2FkID0gZGVjb2RlVG9rZW4odG9rZW4pLnBheWxvYWRcbiAgaWYgKHBheWxvYWQuZXhwKSB7XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkLmV4cCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBjb25zdCBleHBpcmVzQXQgPSBuZXcgRGF0ZShwYXlsb2FkLmV4cCAqIDEwMDApIC8vIEpXVCB0aW1lcyBhcmUgaW4gc2Vjb25kc1xuICAgIGlmIChuZXcgRGF0ZSgpLmdldFRpbWUoKSA+IGV4cGlyZXNBdC5nZXRUaW1lKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbi8qKlxuICogTWFrZXMgc3VyZSB0aGUgYG1hbmlmZXN0X3VyaWAgaXMgYSBzYW1lIG9yaWdpbiBhYnNvbHV0ZSBVUkwuXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICB0b2tlbiBlbmNvZGVkIGFuZCBzaWduZWQgYXV0aGVudGljYXRpb24gdG9rZW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB2YWxpZCwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc01hbmlmZXN0VXJpVmFsaWQodG9rZW46IHN0cmluZykge1xuICBjb25zdCBwYXlsb2FkID0gZGVjb2RlVG9rZW4odG9rZW4pLnBheWxvYWRcbiAgcmV0dXJuIGlzU2FtZU9yaWdpbkFic29sdXRlVXJsKHBheWxvYWQuZG9tYWluX25hbWUsIHBheWxvYWQubWFuaWZlc3RfdXJpKVxufVxuXG4vKipcbiAqIE1ha2VzIHN1cmUgdGhlIGByZWRpcmVjdF91cmlgIGlzIGEgc2FtZSBvcmlnaW4gYWJzb2x1dGUgVVJMLlxuICogQHBhcmFtICB7U3RyaW5nfSAgdG9rZW4gZW5jb2RlZCBhbmQgc2lnbmVkIGF1dGhlbnRpY2F0aW9uIHRva2VuXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdmFsaWQsIG90aGVyd2lzZSBgZmFsc2VgXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNSZWRpcmVjdFVyaVZhbGlkKHRva2VuOiBzdHJpbmcpIHtcbiAgY29uc3QgcGF5bG9hZCA9IGRlY29kZVRva2VuKHRva2VuKS5wYXlsb2FkXG4gIHJldHVybiBpc1NhbWVPcmlnaW5BYnNvbHV0ZVVybChwYXlsb2FkLmRvbWFpbl9uYW1lLCBwYXlsb2FkLnJlZGlyZWN0X3VyaSlcbn1cblxuLyoqXG4gKiBWZXJpZnkgYXV0aGVudGljYXRpb24gcmVxdWVzdCBpcyB2YWxpZC4gVGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBhIG51bWJlclxuICogb2YgY2hlY2tzIG9uIHRoZSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IHRva2VuOlxuICogKiBDaGVja3MgdGhhdCBgdG9rZW5gIGhhcyBhIHZhbGlkIGlzc3VhbmNlIGRhdGUgJiBpcyBub3QgZXhwaXJlZFxuICogKiBDaGVja3MgdGhhdCBgdG9rZW5gIGhhcyBhIHZhbGlkIHNpZ25hdHVyZSB0aGF0IG1hdGNoZXMgdGhlIHB1YmxpYyBrZXkgaXQgY2xhaW1zXG4gKiAqIENoZWNrcyB0aGF0IGJvdGggdGhlIG1hbmlmZXN0IGFuZCByZWRpcmVjdCBVUkxzIGFyZSBhYnNvbHV0ZSBhbmQgY29uZm9ybSB0b1xuICogdGhlIHNhbWUgb3JpZ2luIHBvbGljeVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdG9rZW4gZW5jb2RlZCBhbmQgc2lnbmVkIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgdG9rZW5cbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgYXV0aCByZXF1ZXN0XG4gKiAgaXMgdmFsaWQgYW5kIGZhbHNlIGlmIGl0IGRvZXMgbm90LiBJdCByZWplY3RzIHdpdGggYSBTdHJpbmcgaWYgdGhlXG4gKiAgdG9rZW4gaXMgbm90IHNpZ25lZFxuICogIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlBdXRoUmVxdWVzdCh0b2tlbjogc3RyaW5nKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoZGVjb2RlVG9rZW4odG9rZW4pLmhlYWRlci5hbGcgPT09ICdub25lJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUb2tlbiBtdXN0IGJlIHNpZ25lZCBpbiBvcmRlciB0byBiZSB2ZXJpZmllZCcpXG4gICAgfVxuICB9KS50aGVuKCgpID0+IFByb21pc2UuYWxsKFtcbiAgICBpc0V4cGlyYXRpb25EYXRlVmFsaWQodG9rZW4pLFxuICAgIGlzSXNzdWFuY2VEYXRlVmFsaWQodG9rZW4pLFxuICAgIGRvU2lnbmF0dXJlc01hdGNoUHVibGljS2V5cyh0b2tlbiksXG4gICAgZG9QdWJsaWNLZXlzTWF0Y2hJc3N1ZXIodG9rZW4pLFxuICAgIGlzTWFuaWZlc3RVcmlWYWxpZCh0b2tlbiksXG4gICAgaXNSZWRpcmVjdFVyaVZhbGlkKHRva2VuKVxuICBdKSkudGhlbigodmFsdWVzKSA9PiB7XG4gICAgaWYgKHZhbHVlcy5ldmVyeShCb29sZWFuKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9KVxufVxuXG4vKipcbiAqIFZlcmlmeSB0aGUgYXV0aGVudGljYXRpb24gcmVxdWVzdCBpcyB2YWxpZCBhbmRcbiAqIGZldGNoIHRoZSBhcHAgbWFuaWZlc3QgZmlsZSBpZiB2YWxpZC4gT3RoZXJ3aXNlLCByZWplY3QgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRva2VuIGVuY29kZWQgYW5kIHNpZ25lZCBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IHRva2VuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSB0aGF0IHJlc29sdmVzIHRvIHRoZSBhcHAgbWFuaWZlc3QgZmlsZSBpbiBKU09OIGZvcm1hdFxuICogb3IgcmVqZWN0cyBpZiB0aGUgYXV0aCByZXF1ZXN0IG9yIGFwcCBtYW5pZmVzdCBmaWxlIGlzIGludmFsaWRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlBdXRoUmVxdWVzdEFuZExvYWRNYW5pZmVzdCh0b2tlbjogc3RyaW5nKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZlcmlmeUF1dGhSZXF1ZXN0KHRva2VuKVxuICAgIC50aGVuKCh2YWxpZCkgPT4ge1xuICAgICAgaWYgKHZhbGlkKSB7XG4gICAgICAgIHJldHVybiBmZXRjaEFwcE1hbmlmZXN0KHRva2VuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KClcbiAgICAgIH1cbiAgICB9KSlcbn1cblxuLyoqXG4gKiBWZXJpZnkgdGhlIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlIGlzIHZhbGlkXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlIHRva2VuXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZUxvb2t1cFVSTCB0aGUgdXJsIHVzZSB0byB2ZXJpZnkgb3duZXIgb2YgYSB1c2VybmFtZVxuICogQHJldHVybiB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIGF1dGggcmVzcG9uc2VcbiAqIGlzIHZhbGlkIGFuZCBmYWxzZSBpZiBpdCBkb2VzIG5vdFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeUF1dGhSZXNwb25zZSh0b2tlbjogc3RyaW5nLCBuYW1lTG9va3VwVVJMOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICBpc0V4cGlyYXRpb25EYXRlVmFsaWQodG9rZW4pLFxuICAgIGlzSXNzdWFuY2VEYXRlVmFsaWQodG9rZW4pLFxuICAgIGRvU2lnbmF0dXJlc01hdGNoUHVibGljS2V5cyh0b2tlbiksXG4gICAgZG9QdWJsaWNLZXlzTWF0Y2hJc3N1ZXIodG9rZW4pLFxuICAgIGRvUHVibGljS2V5c01hdGNoVXNlcm5hbWUodG9rZW4sIG5hbWVMb29rdXBVUkwpXG4gIF0pLnRoZW4oKHZhbHVlcykgPT4ge1xuICAgIGlmICh2YWx1ZXMuZXZlcnkoQm9vbGVhbikpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSlcbn1cbiJdfQ==