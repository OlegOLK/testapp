{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"C:\\\\Repository\\\\testapp\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nexports.__esModule = true;\nexports.encryptContent = encryptContent;\nexports.decryptContent = decryptContent;\nexports.getFile = getFile;\nexports.putFile = putFile;\nexports.listFiles = listFiles;\nexports.deleteFile = deleteFile;\nexports.getUserAppFileUrl = getUserAppFileUrl;\nexports.encryptContentImpl = encryptContentImpl;\nexports.decryptContentImpl = decryptContentImpl;\nexports.getFileUrlImpl = getFileUrlImpl;\nexports.getFileUrl = getFileUrl;\nexports.getFileImpl = getFileImpl;\nexports.putFileImpl = putFileImpl;\nexports.getAppBucketUrl = getAppBucketUrl;\nexports.listFilesImpl = listFilesImpl;\n\nvar _hub = require(\"./hub\");\n\nexports.connectToGaiaHub = _hub.connectToGaiaHub;\nexports.uploadToGaiaHub = _hub.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = _hub.BLOCKSTACK_GAIA_HUB_LABEL;\n\nvar _ec = require(\"../encryption/ec\");\n\nvar _keys = require(\"../keys\");\n\nvar _profiles = require(\"../profiles\");\n\nvar _errors = require(\"../errors\");\n\nvar _logger = require(\"../logger\");\n\nvar _userSession = require(\"../auth/userSession\"); // export { type GaiaHubConfig } from './hub'\n\n\nvar SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\n\nfunction encryptContent(content, options) {\n  console.warn('DEPRECATION WARNING: The static encryptContent() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method encryptContent().');\n  var userSession = new _userSession.UserSession();\n  return userSession.encryptContent(content, options);\n}\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\n\n\nfunction decryptContent(content, options) {\n  console.warn('DEPRECATION WARNING: The static decryptContent() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method decryptContent().');\n  var userSession = new _userSession.UserSession();\n  return userSession.decryptContent(content, options);\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @param {Object} [options=null] - options object\n * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {Boolean} options.verify - Whether the content should be verified, only to be used\n * when `putFile` was set to `sign = true`\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n * @param {String} [options.zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's getNameInfo function instead.\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\n\n\nfunction getFile(path, options) {\n  console.warn('DEPRECATION WARNING: The static getFile() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method getFile().');\n  var userSession = new _userSession.UserSession();\n  return userSession.getFile(path, options);\n}\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @param {Object} [options=null] - options object\n * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app public key\n *                                                  or the provided public key\n * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with\n *                                         the app private key\n * @param {String} [options.contentType=''] - set a Content-Type header for unencrypted data\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\n\n\nfunction putFile(path, content, options) {\n  console.warn('DEPRECATION WARNING: The static putFile() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method putFile().');\n  var userSession = new _userSession.UserSession();\n  return userSession.putFile(path, content, options);\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\n\n\nfunction listFiles(callback) {\n  console.warn('DEPRECATION WARNING: The static listFiles() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method listFiles().');\n  var userSession = new _userSession.UserSession();\n  return userSession.listFiles(callback);\n}\n/**\n * Deletes the specified file from the app's data store. Currently not implemented.\n * @param {String} path - the path to the file to delete\n * @returns {Promise} that resolves when the file has been removed\n * or rejects with an error\n * @private\n */\n\n\nfunction deleteFile(path) {\n  Promise.reject(new Error(\"Delete of \".concat(path, \" not supported by gaia hubs\")));\n}\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's getNameInfo function instead.\n * @return {Promise} that resolves to the public read URL of the file\n * or rejects with an error\n */\n\n\nfunction getUserAppFileUrl(path, username, appOrigin) {\n  var zoneFileLookupURL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n  return (0, _profiles.lookupProfile)(username, zoneFileLookupURL).then(function (profile) {\n    if (profile.hasOwnProperty('apps')) {\n      if (profile.apps.hasOwnProperty(appOrigin)) {\n        return profile.apps[appOrigin];\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }).then(function (bucketUrl) {\n    if (bucketUrl) {\n      var bucket = bucketUrl.replace(/\\/?(\\?|#|$)/, '/$1');\n      return \"\".concat(bucket).concat(path);\n    } else {\n      return null;\n    }\n  });\n}\n/**\n * Encrypts the data provided with the app public key.\n * @param {UserSession} caller - the instance calling this method\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n * @private\n */\n\n\nfunction encryptContentImpl(caller, content, options) {\n  var defaults = {\n    publicKey: null\n  };\n  var opt = Object.assign({}, defaults, options);\n\n  if (!opt.publicKey) {\n    var userData = caller.loadUserData();\n    var privateKey = userData.appPrivateKey;\n    opt.publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);\n  }\n\n  var cipherObject = (0, _ec.encryptECIES)(opt.publicKey, content);\n  return JSON.stringify(cipherObject);\n}\n/**\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {UserSession} caller - the instance calling this method\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n * @private\n */\n\n\nfunction decryptContentImpl(caller, content, options) {\n  var defaults = {\n    privateKey: null\n  };\n  var opt = Object.assign({}, defaults, options);\n  var privateKey = opt.privateKey;\n\n  if (!privateKey) {\n    privateKey = caller.loadUserData().appPrivateKey;\n  }\n\n  try {\n    var cipherObject = JSON.parse(content);\n    return (0, _ec.decryptECIES)(privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n */\n\n\nfunction getGaiaAddress(caller, app, username, zoneFileLookupURL) {\n  return Promise.resolve().then(function () {\n    if (username) {\n      return getUserAppFileUrl('/', username, app, zoneFileLookupURL);\n    } else {\n      return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(function (gaiaHubConfig) {\n        return (0, _hub.getFullReadUrl)('/', gaiaHubConfig);\n      });\n    }\n  }).then(function (fileUrl) {\n    var matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n\n    if (!matches) {\n      throw new Error('Failed to parse gaia address');\n    }\n\n    return matches[matches.length - 1];\n  });\n}\n\nfunction getFileUrlImpl(caller, path, options) {\n  return Promise.resolve().then(function () {\n    var appConfig = caller.appConfig;\n\n    if (!appConfig) {\n      throw new _errors.InvalidStateError('Missing AppConfig');\n    }\n\n    var defaults = {\n      username: null,\n      app: appConfig.appDomain,\n      zoneFileLookupURL: null\n    };\n    return Object.assign({}, defaults, options);\n  }).then(function (opts) {\n    if (opts.username) {\n      return getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n    } else {\n      return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(function (gaiaHubConfig) {\n        return (0, _hub.getFullReadUrl)(path, gaiaHubConfig);\n      });\n    }\n  }).then(function (readUrl) {\n    return new Promise(function (resolve, reject) {\n      if (!readUrl) {\n        reject(null);\n      } else {\n        resolve(readUrl);\n      }\n    });\n  });\n}\n/**\n * Get the URL for reading a file from an app's data store.\n * @param {String} path - the path to the file to read\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n * @param {String} [options.zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's getNameInfo function instead.\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\n\n\nfunction getFileUrl(path, options) {\n  console.warn('DEPRECATION WARNING: The static getFileUrl() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method getFileUrl().');\n  var userSession = new _userSession.UserSession();\n  return getFileUrlImpl(userSession, path, options);\n}\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n */\n\n\nfunction getFileContents(caller, path, app, username, zoneFileLookupURL, forceText) {\n  return Promise.resolve().then(function () {\n    var opts = {\n      app: app,\n      username: username,\n      zoneFileLookupURL: zoneFileLookupURL\n    };\n    return getFileUrlImpl(caller, path, opts);\n  }).then(function (readUrl) {\n    return fetch(readUrl);\n  }).then(function (response) {\n    if (response.status !== 200) {\n      if (response.status === 404) {\n        _logger.Logger.debug(\"getFile \".concat(path, \" returned 404, returning null\"));\n\n        return null;\n      } else {\n        throw new Error(\"getFile \".concat(path, \" failed with HTTP status \").concat(response.status));\n      }\n    }\n\n    var contentType = response.headers.get('Content-Type');\n\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n */\n\n\nfunction getFileSignedUnencrypted(caller, path, opt) {\n  // future optimization note:\n  //    in the case of _multi-player_ reads, this does a lot of excess\n  //    profile lookups to figure out where to read files\n  //    do browsers cache all these requests if Content-Cache is set?\n  return Promise.all([getFileContents(caller, path, opt.app, opt.username, opt.zoneFileLookupURL, false), getFileContents(caller, \"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), opt.app, opt.username, opt.zoneFileLookupURL, true), getGaiaAddress(caller, opt.app, opt.username, opt.zoneFileLookupURL)]).then(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 3),\n        fileContents = _ref2[0],\n        signatureContents = _ref2[1],\n        gaiaAddress = _ref2[2];\n\n    if (!fileContents) {\n      return fileContents;\n    }\n\n    if (!gaiaAddress) {\n      throw new _errors.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    if (!signatureContents || typeof signatureContents !== 'string') {\n      throw new _errors.SignatureVerificationError('Failed to obtain signature for file: ' + \"\".concat(path, \" -- looked in \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    }\n\n    var signature;\n    var publicKey;\n\n    try {\n      var sigObject = JSON.parse(signatureContents);\n      signature = sigObject.signature;\n      publicKey = sigObject.publicKey;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse signature content JSON ' + \"(path: \".concat(path).concat(SIGNATURE_FILE_SUFFIX, \")\") + ' The content may be corrupted.');\n      } else {\n        throw err;\n      }\n    }\n\n    var signerAddress = (0, _keys.publicKeyToAddress)(publicKey);\n\n    if (gaiaAddress !== signerAddress) {\n      throw new _errors.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(gaiaAddress, \")\"));\n    } else if (!(0, _ec.verifyECDSA)(Buffer.from(fileContents), publicKey, signature)) {\n      throw new _errors.SignatureVerificationError('Contents do not match ECDSA signature: ' + \"path: \".concat(path, \", signature: \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    } else {\n      return fileContents;\n    }\n  });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n */\n\n\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n  var appPrivateKey = caller.loadUserData().appPrivateKey;\n  var appPublicKey = (0, _keys.getPublicKeyFromPrivate)(appPrivateKey);\n  var addressPromise;\n\n  if (username) {\n    addressPromise = getGaiaAddress(caller, app, username, zoneFileLookupURL);\n  } else {\n    var address = (0, _keys.publicKeyToAddress)(appPublicKey);\n    addressPromise = Promise.resolve(address);\n  }\n\n  return addressPromise.then(function (address) {\n    if (!address) {\n      throw new _errors.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    var sigObject;\n\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n\n    var signature = sigObject.signature;\n    var signerPublicKey = sigObject.publicKey;\n    var cipherText = sigObject.cipherText;\n    var signerAddress = (0, _keys.publicKeyToAddress)(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new _errors.SignatureVerificationError('Failed to get signature verification data from file:' + \" \".concat(path));\n    } else if (signerAddress !== address) {\n      throw new _errors.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(address, \")\"));\n    } else if (!(0, _ec.verifyECDSA)(cipherText, signerPublicKey, signature)) {\n      throw new _errors.SignatureVerificationError('Contents do not match ECDSA signature in file:' + \" \".concat(path));\n    } else {\n      return caller.decryptContent(cipherText);\n    }\n  });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {UserSession} caller - instance calling this method\n * @param {String} path - the path to the file to read\n * @param {Object} [options=null] - options object\n * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {Boolean} options.verify - Whether the content should be verified, only to be used\n * when `putFile` was set to `sign = true`\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n * @param {String} [options.zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's getNameInfo function instead.\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n * @private\n */\n\n\nfunction getFileImpl(caller, path, options) {\n  var appConfig = caller.appConfig;\n\n  if (!appConfig) {\n    throw new _errors.InvalidStateError('Missing AppConfig');\n  }\n\n  var defaults = {\n    decrypt: true,\n    verify: false,\n    username: null,\n    app: appConfig.appDomain,\n    zoneFileLookupURL: null\n  };\n  var opt = Object.assign({}, defaults, options); // in the case of signature verification, but no\n  //  encryption expected, need to fetch _two_ files.\n\n  if (opt.verify && !opt.decrypt) {\n    return getFileSignedUnencrypted(caller, path, opt);\n  }\n\n  return getFileContents(caller, path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt).then(function (storedContents) {\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return decryptContentImpl(caller, storedContents);\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {UserSession} caller - instance calling this method\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @param {Object} [options=null] - options object\n * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app public key\n *                                                  or the provided public key\n * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with\n *                                         the app private key\n * @param {String} [options.contentType=''] - set a Content-Type header for unencrypted data\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n * @private\n */\n\n\nfunction putFileImpl(caller, path, content, options) {\n  var defaults = {\n    encrypt: true,\n    sign: false,\n    contentType: ''\n  };\n  var opt = Object.assign({}, defaults, options);\n  var contentType = opt.contentType;\n\n  if (!contentType) {\n    contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n  } // First, let's figure out if we need to get public/private keys,\n  //  or if they were passed in\n\n\n  var privateKey = '';\n  var publicKey = '';\n\n  if (opt.sign) {\n    if (typeof opt.sign === 'string') {\n      privateKey = opt.sign;\n    } else {\n      privateKey = caller.loadUserData().appPrivateKey;\n    }\n  }\n\n  if (opt.encrypt) {\n    if (typeof opt.encrypt === 'string') {\n      publicKey = opt.encrypt;\n    } else {\n      if (!privateKey) {\n        privateKey = caller.loadUserData().appPrivateKey;\n      }\n\n      publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);\n    }\n  } // In the case of signing, but *not* encrypting,\n  //   we perform two uploads. So the control-flow\n  //   here will return there.\n\n\n  if (!opt.encrypt && opt.sign) {\n    var signatureObject = (0, _ec.signECDSA)(privateKey, content);\n    var signatureContent = JSON.stringify(signatureObject);\n    return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(function (gaiaHubConfig) {\n      return new Promise(function (resolve, reject) {\n        return Promise.all([(0, _hub.uploadToGaiaHub)(path, content, gaiaHubConfig, contentType), (0, _hub.uploadToGaiaHub)(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, gaiaHubConfig, 'application/json')]).then(resolve).catch(function () {\n          (0, _hub.setLocalGaiaHubConnection)(caller).then(function (freshHubConfig) {\n            return Promise.all([(0, _hub.uploadToGaiaHub)(path, content, freshHubConfig, contentType), (0, _hub.uploadToGaiaHub)(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, freshHubConfig, 'application/json')]).then(resolve).catch(reject);\n          });\n        });\n      });\n    }).then(function (fileUrls) {\n      return fileUrls[0];\n    });\n  } // In all other cases, we only need one upload.\n\n\n  if (opt.encrypt && !opt.sign) {\n    content = encryptContentImpl(caller, content, {\n      publicKey: publicKey\n    });\n    contentType = 'application/json';\n  } else if (opt.encrypt && opt.sign) {\n    var cipherText = encryptContentImpl(caller, content, {\n      publicKey: publicKey\n    });\n\n    var _signatureObject = (0, _ec.signECDSA)(privateKey, cipherText);\n\n    var signedCipherObject = {\n      signature: _signatureObject.signature,\n      publicKey: _signatureObject.publicKey,\n      cipherText: cipherText\n    };\n    content = JSON.stringify(signedCipherObject);\n    contentType = 'application/json';\n  }\n\n  return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(function (gaiaHubConfig) {\n    return new Promise(function (resolve, reject) {\n      (0, _hub.uploadToGaiaHub)(path, content, gaiaHubConfig, contentType).then(resolve).catch(function () {\n        (0, _hub.setLocalGaiaHubConnection)(caller).then(function (freshHubConfig) {\n          return (0, _hub.uploadToGaiaHub)(path, content, freshHubConfig, contentType).then(resolve).catch(reject);\n        });\n      });\n    });\n  });\n}\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\n\n\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return (0, _hub.getBucketUrl)(gaiaHubUrl, appPrivateKey);\n}\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n */\n\n\nfunction listFilesLoop(hubConfig, page, callCount, fileCount, callback) {\n  if (callCount > 65536) {\n    // this is ridiculously huge, and probably indicates\n    // a faulty Gaia hub anyway (e.g. on that serves endless data)\n    throw new Error('Too many entries to list');\n  }\n\n  var httpStatus;\n  var pageRequest = JSON.stringify({\n    page: page\n  });\n  var fetchOptions = {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Content-Length': \"\".concat(pageRequest.length),\n      Authorization: \"bearer \".concat(hubConfig.token)\n    },\n    body: pageRequest\n  };\n  return fetch(\"\".concat(hubConfig.server, \"/list-files/\").concat(hubConfig.address), fetchOptions).then(function (response) {\n    httpStatus = response.status;\n\n    if (httpStatus >= 400) {\n      throw new Error(\"listFiles failed with HTTP status \".concat(httpStatus));\n    }\n\n    return response.text();\n  }).then(function (responseText) {\n    return JSON.parse(responseText);\n  }).then(function (responseJSON) {\n    var entries = responseJSON.entries;\n    var nextPage = responseJSON.page;\n\n    if (entries === null || entries === undefined) {\n      // indicates a misbehaving Gaia hub or a misbehaving driver\n      // (i.e. the data is malformed)\n      throw new Error('Bad listFiles response: no entries');\n    }\n\n    for (var i = 0; i < entries.length; i++) {\n      var rc = callback(entries[i]);\n\n      if (!rc) {\n        // callback indicates that we're done\n        return Promise.resolve(fileCount + i);\n      }\n    }\n\n    if (nextPage && entries.length > 0) {\n      // keep going -- have more entries\n      return listFilesLoop(hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n    } else {\n      // no more entries -- end of data\n      return Promise.resolve(fileCount + entries.length);\n    }\n  });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {UserSession} caller - instance calling this method\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n * @private\n */\n\n\nfunction listFilesImpl(caller, callback) {\n  return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(function (gaiaHubConfig) {\n    return listFilesLoop(gaiaHubConfig, null, 0, 0, callback);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}