{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\nexports.isIssuanceDateValid = isIssuanceDateValid;\nexports.isExpirationDateValid = isExpirationDateValid;\nexports.isManifestUriValid = isManifestUriValid;\nexports.isRedirectUriValid = isRedirectUriValid;\nexports.verifyAuthRequest = verifyAuthRequest;\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\nexports.verifyAuthResponse = verifyAuthResponse;\n\nvar _jsontokens = require(\"jsontokens\");\n\nvar _index = require(\"../index\");\n\nvar _ = require(\".\");\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n */\n\n\nfunction doSignaturesMatchPublicKeys(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  var publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    var publicKey = publicKeys[0];\n\n    try {\n      var tokenVerifier = new _jsontokens.TokenVerifier('ES256k', publicKey);\n      var signatureVerified = tokenVerifier.verify(token);\n\n      if (signatureVerified) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n */\n\n\nfunction doPublicKeysMatchIssuer(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  var publicKeys = payload.public_keys;\n  var addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);\n\n  if (publicKeys.length === 1) {\n    var addressFromPublicKeys = (0, _index.publicKeyToAddress)(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n */\n\n\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n  return Promise.resolve().then(function () {\n    var payload = (0, _jsontokens.decodeToken)(token).payload;\n\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    var username = payload.username;\n    var url = \"\".concat(nameLookupURL.replace(/\\/$/, ''), \"/\").concat(username);\n    return fetch(url).then(function (response) {\n      return response.text();\n    }).then(function (responseText) {\n      var responseJSON = JSON.parse(responseText);\n\n      if (responseJSON.hasOwnProperty('address')) {\n        var nameOwningAddress = responseJSON.address;\n        var addressFromIssuer = (0, _index.getAddressFromDID)(payload.iss);\n\n        if (nameOwningAddress === addressFromIssuer) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    });\n  }).catch(function () {\n    return false;\n  });\n}\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n */\n\n\nfunction isIssuanceDateValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    var issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n */\n\n\nfunction isExpirationDateValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    var expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n */\n\n\nfunction isManifestUriValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  return (0, _index.isSameOriginAbsoluteUrl)(payload.domain_name, payload.manifest_uri);\n}\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n */\n\n\nfunction isRedirectUriValid(token) {\n  var payload = (0, _jsontokens.decodeToken)(token).payload;\n  return (0, _index.isSameOriginAbsoluteUrl)(payload.domain_name, payload.redirect_uri);\n}\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n *  @private\n */\n\n\nfunction verifyAuthRequest(token) {\n  return Promise.resolve().then(function () {\n    if ((0, _jsontokens.decodeToken)(token).header.alg === 'none') {\n      throw new Error('Token must be signed in order to be verified');\n    }\n  }).then(function () {\n    return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)]);\n  }).then(function (values) {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n */\n\n\nfunction verifyAuthRequestAndLoadManifest(token) {\n  return Promise.resolve().then(function () {\n    return verifyAuthRequest(token).then(function (valid) {\n      if (valid) {\n        return (0, _.fetchAppManifest)(token);\n      } else {\n        return Promise.reject();\n      }\n    });\n  });\n}\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n */\n\n\nfunction verifyAuthResponse(token, nameLookupURL) {\n  return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]).then(function (values) {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}