"use strict";

exports.__esModule = true;
exports.hash160 = hash160;
exports.hash128 = hash128;
exports.estimateTXBytes = estimateTXBytes;
exports.sumOutputValues = sumOutputValues;
exports.decodeB40 = decodeB40;
exports.addUTXOsToFund = addUTXOsToFund;
exports.signInputs = signInputs;
exports.DUST_MINIMUM = void 0;

var _bitcoinjsLib = _interopRequireDefault(require("bitcoinjs-lib"));

var _ripemd = _interopRequireDefault(require("ripemd160"));

var _bigi = _interopRequireDefault(require("bigi"));

var _errors = require("../errors");

var _signers = require("./signers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DUST_MINIMUM = 5500;
exports.DUST_MINIMUM = DUST_MINIMUM;

function hash160(buff) {
  const sha256 = _bitcoinjsLib.default.crypto.sha256(buff);

  return new _ripemd.default().update(sha256).digest();
}

function hash128(buff) {
  return Buffer.from(_bitcoinjsLib.default.crypto.sha256(buff).slice(0, 16));
} // COPIED FROM coinselect, because 1 byte matters sometimes.
// baseline estimates, used to improve performance


const TX_EMPTY_SIZE = 4 + 1 + 1 + 4;
const TX_INPUT_BASE = 32 + 4 + 1 + 4;
const TX_INPUT_PUBKEYHASH = 107;
const TX_OUTPUT_BASE = 8 + 1;
const TX_OUTPUT_PUBKEYHASH = 25;

function inputBytes(input) {
  if (input && input.script && input.script.length > 0) {
    return TX_INPUT_BASE + input.script.length;
  } else {
    return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;
  }
}

function outputBytes(output) {
  if (output && output.script && output.script.length > 0) {
    return TX_OUTPUT_BASE + output.script.length;
  } else {
    return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;
  }
}

function transactionBytes(inputs, outputs) {
  return TX_EMPTY_SIZE + inputs.reduce((a, x) => a + inputBytes(x), 0) + outputs.reduce((a, x) => a + outputBytes(x), 0);
} //


function estimateTXBytes(txIn, additionalInputs, additionalOutputs) {
  let innerTx = txIn;

  if (txIn instanceof _bitcoinjsLib.default.TransactionBuilder) {
    innerTx = txIn.__tx;
  }

  const dummyInputs = new Array(additionalInputs);
  dummyInputs.fill(null);
  const dummyOutputs = new Array(additionalOutputs);
  dummyOutputs.fill(null);
  const inputs = [].concat(innerTx.ins, dummyInputs);
  const outputs = [].concat(innerTx.outs, dummyOutputs);
  return transactionBytes(inputs, outputs);
}

function sumOutputValues(txIn) {
  let innerTx = txIn;

  if (txIn instanceof _bitcoinjsLib.default.TransactionBuilder) {
    innerTx = txIn.__tx;
  }

  return innerTx.outs.reduce((agg, x) => agg + x.value, 0);
}

function decodeB40(input) {
  // treat input as a base40 integer, and output a hex encoding
  // of that integer.
  //
  //   for each digit of the string, find its location in `characters`
  //    to get the value of the digit, then multiply by 40^(-index in input)
  // e.g.,
  // the 'right-most' character has value: (digit-value) * 40^0
  //  the next character has value: (digit-value) * 40^1
  //
  // hence, we reverse the characters first, and use the index
  //  to compute the value of each digit, then sum
  const characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';

  const base = _bigi.default.valueOf(40);

  const inputDigits = input.split('').reverse();
  const digitValues = inputDigits.map((character, exponent) => _bigi.default.valueOf(characters.indexOf(character)).multiply(base.pow(_bigi.default.valueOf(exponent))));
  const sum = digitValues.reduce((agg, cur) => agg.add(cur), _bigi.default.ZERO);
  return sum.toHex();
}
/**
 * Adds UTXOs to fund a transaction
 * @param {TransactionBuilder} txBuilderIn - a transaction builder object to add the inputs to. this
 *    object is _always_ mutated. If not enough UTXOs exist to fund, the tx builder object
 *    will still contain as many inputs as could be found.
 * @param {Array<{value: number, tx_hash: string, tx_output_n}>} utxos - the utxo set for the
 *    payer's address.
 * @param {number} amountToFund - the amount of satoshis to fund in the transaction. the payer's
 *    utxos will be included to fund up to this amount of *output* and the corresponding *fees*
 *    for those additional inputs
 * @param {number} feeRate - the satoshis/byte fee rate to use for fee calculation
 * @param {boolean} fundNewFees - if true, this function will fund `amountToFund` and any new fees
 *    associated with including the new inputs.
 *    if false, this function will fund _at most_ `amountToFund`
 * @returns {number} - the amount of leftover change (in satoshis)
 * @private
 */


function addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate, fundNewFees = true) {
  if (utxos.length === 0) {
    throw new _errors.NotEnoughFundsError(amountToFund);
  } // how much are we increasing fees by adding an input ?


  const newFees = feeRate * (estimateTXBytes(txBuilderIn, 1, 0) - estimateTXBytes(txBuilderIn, 0, 0));
  let utxoThreshhold = amountToFund;

  if (fundNewFees) {
    utxoThreshhold += newFees;
  }

  const goodUtxos = utxos.filter(utxo => utxo.value >= utxoThreshhold);

  if (goodUtxos.length > 0) {
    goodUtxos.sort((a, b) => a.value - b.value);
    const selected = goodUtxos[0];
    let change = selected.value - amountToFund;

    if (fundNewFees) {
      change -= newFees;
    }

    txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);
    return change;
  } else {
    utxos.sort((a, b) => b.value - a.value);
    const largest = utxos[0];

    if (newFees >= largest.value) {
      throw new _errors.NotEnoughFundsError(amountToFund);
    }

    txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);
    let remainToFund = amountToFund - largest.value;

    if (fundNewFees) {
      remainToFund += newFees;
    }

    return addUTXOsToFund(txBuilderIn, utxos.slice(1), remainToFund, feeRate, fundNewFees);
  }
}

function signInputs(txB, defaultSigner, otherSigners) {
  const signerArray = txB.__tx.ins.map(() => defaultSigner);

  if (otherSigners) {
    otherSigners.forEach(signerPair => {
      signerArray[signerPair.index] = signerPair.signer;
    });
  }

  let signingPromise = Promise.resolve();

  for (let i = 0; i < txB.__tx.ins.length; i++) {
    signingPromise = signingPromise.then(() => signerArray[i].signTransaction(txB, i));
  }

  return signingPromise.then(() => txB);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9vcGVyYXRpb25zL3V0aWxzLmpzIl0sIm5hbWVzIjpbIkRVU1RfTUlOSU1VTSIsImhhc2gxNjAiLCJidWZmIiwic2hhMjU2IiwiYml0Y29pbmpzIiwiY3J5cHRvIiwiUklQRU1EMTYwIiwidXBkYXRlIiwiZGlnZXN0IiwiaGFzaDEyOCIsIkJ1ZmZlciIsImZyb20iLCJzbGljZSIsIlRYX0VNUFRZX1NJWkUiLCJUWF9JTlBVVF9CQVNFIiwiVFhfSU5QVVRfUFVCS0VZSEFTSCIsIlRYX09VVFBVVF9CQVNFIiwiVFhfT1VUUFVUX1BVQktFWUhBU0giLCJpbnB1dEJ5dGVzIiwiaW5wdXQiLCJzY3JpcHQiLCJsZW5ndGgiLCJvdXRwdXRCeXRlcyIsIm91dHB1dCIsInRyYW5zYWN0aW9uQnl0ZXMiLCJpbnB1dHMiLCJvdXRwdXRzIiwicmVkdWNlIiwiYSIsIngiLCJlc3RpbWF0ZVRYQnl0ZXMiLCJ0eEluIiwiYWRkaXRpb25hbElucHV0cyIsImFkZGl0aW9uYWxPdXRwdXRzIiwiaW5uZXJUeCIsIlRyYW5zYWN0aW9uQnVpbGRlciIsIl9fdHgiLCJkdW1teUlucHV0cyIsIkFycmF5IiwiZmlsbCIsImR1bW15T3V0cHV0cyIsImNvbmNhdCIsImlucyIsIm91dHMiLCJzdW1PdXRwdXRWYWx1ZXMiLCJhZ2ciLCJ2YWx1ZSIsImRlY29kZUI0MCIsImNoYXJhY3RlcnMiLCJiYXNlIiwiYmlnaSIsInZhbHVlT2YiLCJpbnB1dERpZ2l0cyIsInNwbGl0IiwicmV2ZXJzZSIsImRpZ2l0VmFsdWVzIiwibWFwIiwiY2hhcmFjdGVyIiwiZXhwb25lbnQiLCJpbmRleE9mIiwibXVsdGlwbHkiLCJwb3ciLCJzdW0iLCJjdXIiLCJhZGQiLCJaRVJPIiwidG9IZXgiLCJhZGRVVFhPc1RvRnVuZCIsInR4QnVpbGRlckluIiwidXR4b3MiLCJhbW91bnRUb0Z1bmQiLCJmZWVSYXRlIiwiZnVuZE5ld0ZlZXMiLCJOb3RFbm91Z2hGdW5kc0Vycm9yIiwibmV3RmVlcyIsInV0eG9UaHJlc2hob2xkIiwiZ29vZFV0eG9zIiwiZmlsdGVyIiwidXR4byIsInNvcnQiLCJiIiwic2VsZWN0ZWQiLCJjaGFuZ2UiLCJhZGRJbnB1dCIsInR4X2hhc2giLCJ0eF9vdXRwdXRfbiIsImxhcmdlc3QiLCJyZW1haW5Ub0Z1bmQiLCJzaWduSW5wdXRzIiwidHhCIiwiZGVmYXVsdFNpZ25lciIsIm90aGVyU2lnbmVycyIsInNpZ25lckFycmF5IiwiZm9yRWFjaCIsInNpZ25lclBhaXIiLCJpbmRleCIsInNpZ25lciIsInNpZ25pbmdQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpIiwidGhlbiIsInNpZ25UcmFuc2FjdGlvbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBQ0E7Ozs7QUFFTyxNQUFNQSxZQUFZLEdBQUcsSUFBckI7OztBQUVBLFNBQVNDLE9BQVQsQ0FBaUJDLElBQWpCLEVBQStCO0FBQ3BDLFFBQU1DLE1BQU0sR0FBR0Msc0JBQVVDLE1BQVYsQ0FBaUJGLE1BQWpCLENBQXdCRCxJQUF4QixDQUFmOztBQUNBLFNBQVEsSUFBSUksZUFBSixFQUFELENBQWtCQyxNQUFsQixDQUF5QkosTUFBekIsRUFBaUNLLE1BQWpDLEVBQVA7QUFDRDs7QUFFTSxTQUFTQyxPQUFULENBQWlCUCxJQUFqQixFQUErQjtBQUNwQyxTQUFPUSxNQUFNLENBQUNDLElBQVAsQ0FBWVAsc0JBQVVDLE1BQVYsQ0FBaUJGLE1BQWpCLENBQXdCRCxJQUF4QixFQUE4QlUsS0FBOUIsQ0FBb0MsQ0FBcEMsRUFBdUMsRUFBdkMsQ0FBWixDQUFQO0FBQ0QsQyxDQUdEO0FBQ0E7OztBQUNBLE1BQU1DLGFBQWEsR0FBRyxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVksQ0FBbEM7QUFDQSxNQUFNQyxhQUFhLEdBQUcsS0FBSyxDQUFMLEdBQVMsQ0FBVCxHQUFhLENBQW5DO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUcsR0FBNUI7QUFDQSxNQUFNQyxjQUFjLEdBQUcsSUFBSSxD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Qzs7QUFDQSxRQUFJMEIsV0FBSixFQUFpQjtBQUNmZSxNQUFBQSxZQUFZLElBQUliLE9BQWhCO0FBQ0Q7O0FBRUQsV0FBT1AsY0FBYyxDQUFDQyxXQUFELEVBQWNDLEtBQUssQ0FBQ3pELEtBQU4sQ0FBWSxDQUFaLENBQWQsRUFDQzJFLFlBREQsRUFDZWhCLE9BRGYsRUFDd0JDLFdBRHhCLENBQXJCO0FBRUQ7QUFDRjs7QUFHTSxTQUFTZ0IsVUFBVCxDQUFvQkMsR0FBcEIsRUFDb0JDLGFBRHBCLEVBRW9CQyxZQUZwQixFQUVzRjtBQUMzRixRQUFNQyxXQUFXLEdBQUdILEdBQUcsQ0FBQ3JELElBQUosQ0FBU00sR0FBVCxDQUFhYyxHQUFiLENBQWlCLE1BQU1rQyxhQUF2QixDQUFwQjs7QUFDQSxNQUFJQyxZQUFKLEVBQWtCO0FBQ2hCQSxJQUFBQSxZQUFZLENBQUNFLE9BQWIsQ0FBc0JDLFVBQUQsSUFBZ0I7QUFDbkNGLE1BQUFBLFdBQVcsQ0FBQ0UsVUFBVSxDQUFDQyxLQUFaLENBQVgsR0FBZ0NELFVBQVUsQ0FBQ0UsTUFBM0M7QUFDRCxLQUZEO0FBR0Q7O0FBQ0QsTUFBSUMsY0FBYyxHQUFHQyxPQUFPLENBQUNDLE9BQVIsRUFBckI7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHWCxHQUFHLENBQUNyRCxJQUFKLENBQVNNLEdBQVQsQ0FBYXJCLE1BQWpDLEVBQXlDK0UsQ0FBQyxFQUExQyxFQUE4QztBQUM1Q0gsSUFBQUEsY0FBYyxHQUFHQSxjQUFjLENBQUNJLElBQWYsQ0FDZixNQUFNVCxXQUFXLENBQUNRLENBQUQsQ0FBWCxDQUFlRSxlQUFmLENBQStCYixHQUEvQixFQUFvQ1csQ0FBcEMsQ0FEUyxDQUFqQjtBQUdEOztBQUNELFNBQU9ILGNBQWMsQ0FBQ0ksSUFBZixDQUFvQixNQUFNWixHQUExQixDQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBAZmxvdyAqL1xuXG5pbXBvcnQgYml0Y29pbmpzIGZyb20gJ2JpdGNvaW5qcy1saWInXG5pbXBvcnQgUklQRU1EMTYwIGZyb20gJ3JpcGVtZDE2MCdcbmltcG9ydCBiaWdpIGZyb20gJ2JpZ2knXG5cbmltcG9ydCB7IE5vdEVub3VnaEZ1bmRzRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMnXG5pbXBvcnQgeyBUcmFuc2FjdGlvblNpZ25lciB9IGZyb20gJy4vc2lnbmVycydcblxuZXhwb3J0IGNvbnN0IERVU1RfTUlOSU1VTSA9IDU1MDBcblxuZXhwb3J0IGZ1bmN0aW9uIGhhc2gxNjAoYnVmZjogQnVmZmVyKSB7XG4gIGNvbnN0IHNoYTI1NiA9IGJpdGNvaW5qcy5jcnlwdG8uc2hhMjU2KGJ1ZmYpXG4gIHJldHVybiAobmV3IFJJUEVNRDE2MCgpKS51cGRhdGUoc2hhMjU2KS5kaWdlc3QoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzaDEyOChidWZmOiBCdWZmZXIpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJpdGNvaW5qcy5jcnlwdG8uc2hhMjU2KGJ1ZmYpLnNsaWNlKDAsIDE2KSlcbn1cblxuXG4vLyBDT1BJRUQgRlJPTSBjb2luc2VsZWN0LCBiZWNhdXNlIDEgYnl0ZSBtYXR0ZXJzIHNvbWV0aW1lcy5cbi8vIGJhc2VsaW5lIGVzdGltYXRlcywgdXNlZCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG5jb25zdCBUWF9FTVBUWV9TSVpFID0gNCArIDEgKyAxICsgNFxuY29uc3QgVFhfSU5QVVRfQkFTRSA9IDMyICsgNCArIDEgKyA0XG5jb25zdCBUWF9JTlBVVF9QVUJLRVlIQVNIID0gMTA3XG5jb25zdCBUWF9PVVRQVVRfQkFTRSA9IDggKyAxXG5jb25zdCBUWF9PVVRQVVRfUFVCS0VZSEFTSCA9IDI1XG5cbnR5cGUgdHhQb2ludCA9IHtcbiAgc2NyaXB0OiB7IGxlbmd0aDogbnVtYmVyIH1cbn1cblxuZnVuY3Rpb24gaW5wdXRCeXRlcyhpbnB1dDogdHhQb2ludCB8IG51bGwpIHtcbiAgaWYgKGlucHV0ICYmIGlucHV0LnNjcmlwdCAmJiBpbnB1dC5zY3JpcHQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBUWF9JTlBVVF9CQVNFICsgaW5wdXQuc2NyaXB0Lmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHJldHVybiBUWF9JTlBVVF9CQVNFICsgVFhfSU5QVVRfUFVCS0VZSEFTSFxuICB9XG59XG5cbmZ1bmN0aW9uIG91dHB1dEJ5dGVzKG91dHB1dDogdHhQb2ludCB8IG51bGwpIHtcbiAgaWYgKG91dHB1dCAmJiBvdXRwdXQuc2NyaXB0ICYmIG91dHB1dC5zY3JpcHQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBUWF9PVVRQVVRfQkFTRSArIG91dHB1dC5zY3JpcHQubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFRYX09VVFBVVF9CQVNFICsgVFhfT1VUUFVUX1BVQktFWUhBU0hcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2FjdGlvbkJ5dGVzKGlucHV0czogQXJyYXk8dHhQb2ludCB8IG51bGw+LCBvdXRwdXRzOiBBcnJheTx0eFBvaW50IHwgbnVsbD4pIHtcbiAgcmV0dXJuIFRYX0VNUFRZX1NJWkVcbiAgICArIGlucHV0cy5yZWR1Y2UoKGE6IG51bWJlciwgeDogdHhQb2ludCB8IG51bGwpID0+IChhICsgaW5wdXRCeXRlcyh4KSksIDApXG4gICAgKyBvdXRwdXRzLnJlZHVjZSgoYTogbnVtYmVyLCB4OiB0eFBvaW50IHwgbnVsbCkgPT4gKGEgKyBvdXRwdXRCeXRlcyh4KSksIDApXG59XG5cbi8vXG5cbmV4cG9ydCBmdW5jdGlvbiBlc3RpbWF0ZVRYQnl0ZXModHhJbjogYml0Y29pbmpzLlRyYW5zYWN0aW9uIHwgYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25hbElucHV0czogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbmFsT3V0cHV0czogbnVtYmVyKSB7XG4gIGxldCBpbm5lclR4ID0gdHhJblxuICBpZiAodHhJbiBpbnN0YW5jZW9mIGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIpIHtcbiAgICBpbm5lclR4ID0gdHhJbi5fX3R4XG4gIH1cbiAgY29uc3QgZHVtbXlJbnB1dHM6IEFycmF5PG51bGw+ID0gbmV3IEFycmF5KGFkZGl0aW9uYWxJbnB1dHMpXG4gIGR1bW15SW5wdXRzLmZpbGwobnVsbClcbiAgY29uc3QgZHVtbXlPdXRwdXRzOiBBcnJheTxudWxsPiA9IG5ldyBBcnJheShhZGRpdGlvbmFsT3V0cHV0cylcbiAgZHVtbXlPdXRwdXRzLmZpbGwobnVsbClcblxuICBjb25zdCBpbnB1dHM6IEFycmF5PG51bGwgfCB0eFBvaW50PiA9IFtdLmNvbmNhdChpbm5lclR4LmlucywgZHVtbXlJbnB1dHMpXG4gIGNvbnN0IG91dHB1dHM6IEFycmF5PG51bGwgfCB0eFBvaW50PiA9IFtdLmNvbmNhdChpbm5lclR4Lm91dHMsIGR1bW15T3V0cHV0cylcblxuICByZXR1cm4gdHJhbnNhY3Rpb25CeXRlcyhpbnB1dHMsIG91dHB1dHMpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1PdXRwdXRWYWx1ZXModHhJbiA6IGJpdGNvaW5qcy5UcmFuc2FjdGlvbiB8IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIpIHtcbiAgbGV0IGlubmVyVHggPSB0eEluXG4gIGlmICh0eEluIGluc3RhbmNlb2YgYml0Y29pbmpzLlRyYW5zYWN0aW9uQnVpbGRlcikge1xuICAgIGlubmVyVHggPSB0eEluLl9fdHhcbiAgfVxuXG4gIHJldHVybiBpbm5lclR4Lm91dHMucmVkdWNlKChhZ2csIHgpID0+IGFnZyArIHgudmFsdWUsIDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVCNDAoaW5wdXQ6IHN0cmluZykge1xuICAvLyB0cmVhdCBpbnB1dCBhcyBhIGJhc2U0MCBpbnRlZ2VyLCBhbmQgb3V0cHV0IGEgaGV4IGVuY29kaW5nXG4gIC8vIG9mIHRoYXQgaW50ZWdlci5cbiAgLy9cbiAgLy8gICBmb3IgZWFjaCBkaWdpdCBvZiB0aGUgc3RyaW5nLCBmaW5kIGl0cyBsb2NhdGlvbiBpbiBgY2hhcmFjdGVyc2BcbiAgLy8gICAgdG8gZ2V0IHRoZSB2YWx1ZSBvZiB0aGUgZGlnaXQsIHRoZW4gbXVsdGlwbHkgYnkgNDBeKC1pbmRleCBpbiBpbnB1dClcbiAgLy8gZS5nLixcbiAgLy8gdGhlICdyaWdodC1tb3N0JyBjaGFyYWN0ZXIgaGFzIHZhbHVlOiAoZGlnaXQtdmFsdWUpICogNDBeMFxuICAvLyAgdGhlIG5leHQgY2hhcmFjdGVyIGhhcyB2YWx1ZTogKGRpZ2l0LXZhbHVlKSAqIDQwXjFcbiAgLy9cbiAgLy8gaGVuY2UsIHdlIHJldmVyc2UgdGhlIGNoYXJhY3RlcnMgZmlyc3QsIGFuZCB1c2UgdGhlIGluZGV4XG4gIC8vICB0byBjb21wdXRlIHRoZSB2YWx1ZSBvZiBlYWNoIGRpZ2l0LCB0aGVuIHN1bVxuICBjb25zdCBjaGFyYWN0ZXJzID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fLisnXG4gIGNvbnN0IGJhc2UgPSBiaWdpLnZhbHVlT2YoNDApXG4gIGNvbnN0IGlucHV0RGlnaXRzID0gaW5wdXQuc3BsaXQoJycpLnJldmVyc2UoKVxuICBjb25zdCBkaWdpdFZhbHVlcyA9IGlucHV0RGlnaXRzLm1hcChcbiAgICAoKGNoYXJhY3Rlcjogc3RyaW5nLCBleHBvbmVudDogbnVtYmVyKSA9PiBiaWdpLnZhbHVlT2YoY2hhcmFjdGVycy5pbmRleE9mKGNoYXJhY3RlcikpXG4gICAgICAubXVsdGlwbHkoYmFzZS5wb3coYmlnaS52YWx1ZU9mKGV4cG9uZW50KSkpKVxuICApXG4gIGNvbnN0IHN1bSA9IGRpZ2l0VmFsdWVzLnJlZHVjZShcbiAgICAoYWdnOiBiaWdpLkJpZ0ludGVnZXIsIGN1cjogYmlnaS5CaWdJbnRlZ2VyKSA9PiBhZ2cuYWRkKGN1ciksXG4gICAgYmlnaS5aRVJPXG4gIClcbiAgcmV0dXJuIHN1bS50b0hleCgpXG59XG5cbi8qKlxuICogQWRkcyBVVFhPcyB0byBmdW5kIGEgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25CdWlsZGVyfSB0eEJ1aWxkZXJJbiAtIGEgdHJhbnNhY3Rpb24gYnVpbGRlciBvYmplY3QgdG8gYWRkIHRoZSBpbnB1dHMgdG8uIHRoaXNcbiAqICAgIG9iamVjdCBpcyBfYWx3YXlzXyBtdXRhdGVkLiBJZiBub3QgZW5vdWdoIFVUWE9zIGV4aXN0IHRvIGZ1bmQsIHRoZSB0eCBidWlsZGVyIG9iamVjdFxuICogICAgd2lsbCBzdGlsbCBjb250YWluIGFzIG1hbnkgaW5wdXRzIGFzIGNvdWxkIGJlIGZvdW5kLlxuICogQHBhcmFtIHtBcnJheTx7dmFsdWU6IG51bWJlciwgdHhfaGFzaDogc3RyaW5nLCB0eF9vdXRwdXRfbn0+fSB1dHhvcyAtIHRoZSB1dHhvIHNldCBmb3IgdGhlXG4gKiAgICBwYXllcidzIGFkZHJlc3MuXG4gKiBAcGFyYW0ge251bWJlcn0gYW1vdW50VG9GdW5kIC0gdGhlIGFtb3VudCBvZiBzYXRvc2hpcyB0byBmdW5kIGluIHRoZSB0cmFuc2FjdGlvbi4gdGhlIHBheWVyJ3NcbiAqICAgIHV0eG9zIHdpbGwgYmUgaW5jbHVkZWQgdG8gZnVuZCB1cCB0byB0aGlzIGFtb3VudCBvZiAqb3V0cHV0KiBhbmQgdGhlIGNvcnJlc3BvbmRpbmcgKmZlZXMqXG4gKiAgICBmb3IgdGhvc2UgYWRkaXRpb25hbCBpbnB1dHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWVSYXRlIC0gdGhlIHNhdG9zaGlzL2J5dGUgZmVlIHJhdGUgdG8gdXNlIGZvciBmZWUgY2FsY3VsYXRpb25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZnVuZE5ld0ZlZXMgLSBpZiB0cnVlLCB0aGlzIGZ1bmN0aW9uIHdpbGwgZnVuZCBgYW1vdW50VG9GdW5kYCBhbmQgYW55IG5ldyBmZWVzXG4gKiAgICBhc3NvY2lhdGVkIHdpdGggaW5jbHVkaW5nIHRoZSBuZXcgaW5wdXRzLlxuICogICAgaWYgZmFsc2UsIHRoaXMgZnVuY3Rpb24gd2lsbCBmdW5kIF9hdCBtb3N0XyBgYW1vdW50VG9GdW5kYFxuICogQHJldHVybnMge251bWJlcn0gLSB0aGUgYW1vdW50IG9mIGxlZnRvdmVyIGNoYW5nZSAoaW4gc2F0b3NoaXMpXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkVVRYT3NUb0Z1bmQodHhCdWlsZGVySW46IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXR4b3M6IEFycmF5PHt2YWx1ZTogbnVtYmVyLCB0eF9oYXNoOiBzdHJpbmcsIHR4X291dHB1dF9uOiBudW1iZXJ9PixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbW91bnRUb0Z1bmQ6IG51bWJlciwgZmVlUmF0ZTogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmROZXdGZWVzOiA/Ym9vbGVhbiA9IHRydWUpIHtcbiAgaWYgKHV0eG9zLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBOb3RFbm91Z2hGdW5kc0Vycm9yKGFtb3VudFRvRnVuZClcbiAgfVxuXG4gIC8vIGhvdyBtdWNoIGFyZSB3ZSBpbmNyZWFzaW5nIGZlZXMgYnkgYWRkaW5nIGFuIGlucHV0ID9cbiAgY29uc3QgbmV3RmVlcyA9IGZlZVJhdGUgKiAoZXN0aW1hdGVUWEJ5dGVzKHR4QnVpbGRlckluLCAxLCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIGVzdGltYXRlVFhCeXRlcyh0eEJ1aWxkZXJJbiwgMCwgMCkpXG4gIGxldCB1dHhvVGhyZXNoaG9sZCA9IGFtb3VudFRvRnVuZFxuICBpZiAoZnVuZE5ld0ZlZXMpIHtcbiAgICB1dHhvVGhyZXNoaG9sZCArPSBuZXdGZWVzXG4gIH1cblxuICBjb25zdCBnb29kVXR4b3MgPSB1dHhvcy5maWx0ZXIodXR4byA9PiB1dHhvLnZhbHVlID49IHV0eG9UaHJlc2hob2xkKVxuICBpZiAoZ29vZFV0eG9zLmxlbmd0aCA+IDApIHtcbiAgICBnb29kVXR4b3Muc29ydCgoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpXG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBnb29kVXR4b3NbMF1cbiAgICBsZXQgY2hhbmdlID0gc2VsZWN0ZWQudmFsdWUgLSBhbW91bnRUb0Z1bmRcbiAgICBpZiAoZnVuZE5ld0ZlZXMpIHtcbiAgICAgIGNoYW5nZSAtPSBuZXdGZWVzXG4gICAgfVxuXG4gICAgdHhCdWlsZGVySW4uYWRkSW5wdXQoc2VsZWN0ZWQudHhfaGFzaCwgc2VsZWN0ZWQudHhfb3V0cHV0X24pXG4gICAgcmV0dXJuIGNoYW5nZVxuICB9IGVsc2Uge1xuICAgIHV0eG9zLnNvcnQoKGEsIGIpID0+IGIudmFsdWUgLSBhLnZhbHVlKVxuICAgIGNvbnN0IGxhcmdlc3QgPSB1dHhvc1swXVxuXG4gICAgaWYgKG5ld0ZlZXMgPj0gbGFyZ2VzdC52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IE5vdEVub3VnaEZ1bmRzRXJyb3IoYW1vdW50VG9GdW5kKVxuICAgIH1cblxuICAgIHR4QnVpbGRlckluLmFkZElucHV0KGxhcmdlc3QudHhfaGFzaCwgbGFyZ2VzdC50eF9vdXRwdXRfbilcblxuICAgIGxldCByZW1haW5Ub0Z1bmQgPSBhbW91bnRUb0Z1bmQgLSBsYXJnZXN0LnZhbHVlXG4gICAgaWYgKGZ1bmROZXdGZWVzKSB7XG4gICAgICByZW1haW5Ub0Z1bmQgKz0gbmV3RmVlc1xuICAgIH1cblxuICAgIHJldHVybiBhZGRVVFhPc1RvRnVuZCh0eEJ1aWxkZXJJbiwgdXR4b3Muc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbWFpblRvRnVuZCwgZmVlUmF0ZSwgZnVuZE5ld0ZlZXMpXG4gIH1cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gc2lnbklucHV0cyh0eEI6IGJpdGNvaW5qcy5UcmFuc2FjdGlvbkJ1aWxkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0U2lnbmVyOiBUcmFuc2FjdGlvblNpZ25lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyU2lnbmVycz86IEFycmF5PHtpbmRleDogbnVtYmVyLCBzaWduZXI6IFRyYW5zYWN0aW9uU2lnbmVyfT4pIHtcbiAgY29uc3Qgc2lnbmVyQXJyYXkgPSB0eEIuX190eC5pbnMubWFwKCgpID0+IGRlZmF1bHRTaWduZXIpXG4gIGlmIChvdGhlclNpZ25lcnMpIHtcbiAgICBvdGhlclNpZ25lcnMuZm9yRWFjaCgoc2lnbmVyUGFpcikgPT4ge1xuICAgICAgc2lnbmVyQXJyYXlbc2lnbmVyUGFpci5pbmRleF0gPSBzaWduZXJQYWlyLnNpZ25lclxuICAgIH0pXG4gIH1cbiAgbGV0IHNpZ25pbmdQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eEIuX190eC5pbnMubGVuZ3RoOyBpKyspIHtcbiAgICBzaWduaW5nUHJvbWlzZSA9IHNpZ25pbmdQcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiBzaWduZXJBcnJheVtpXS5zaWduVHJhbnNhY3Rpb24odHhCLCBpKVxuICAgIClcbiAgfVxuICByZXR1cm4gc2lnbmluZ1Byb21pc2UudGhlbigoKSA9PiB0eEIpXG59XG4iXX0=