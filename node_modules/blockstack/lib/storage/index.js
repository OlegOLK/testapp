"use strict";

exports.__esModule = true;
exports.encryptContent = encryptContent;
exports.decryptContent = decryptContent;
exports.getFile = getFile;
exports.putFile = putFile;
exports.listFiles = listFiles;
exports.deleteFile = deleteFile;
exports.getUserAppFileUrl = getUserAppFileUrl;
exports.encryptContentImpl = encryptContentImpl;
exports.decryptContentImpl = decryptContentImpl;
exports.getFileUrlImpl = getFileUrlImpl;
exports.getFileUrl = getFileUrl;
exports.getFileImpl = getFileImpl;
exports.putFileImpl = putFileImpl;
exports.getAppBucketUrl = getAppBucketUrl;
exports.listFilesImpl = listFilesImpl;

var _hub = require("./hub");

exports.connectToGaiaHub = _hub.connectToGaiaHub;
exports.uploadToGaiaHub = _hub.uploadToGaiaHub;
exports.BLOCKSTACK_GAIA_HUB_LABEL = _hub.BLOCKSTACK_GAIA_HUB_LABEL;

var _ec = require("../encryption/ec");

var _keys = require("../keys");

var _profiles = require("../profiles");

var _errors = require("../errors");

var _logger = require("../logger");

var _userSession = require("../auth/userSession");

// export { type GaiaHubConfig } from './hub'
const SIGNATURE_FILE_SUFFIX = '.sig';
/**
 * Encrypts the data provided with the app public key.
 * @param {String|Buffer} content - data to encrypt
 * @param {Object} [options=null] - options object
 * @param {String} options.publicKey - the hex string of the ECDSA public
 * key to use for encryption. If not provided, will use user's appPublicKey.
 * @return {String} Stringified ciphertext object
 */

function encryptContent(content, options) {
  console.warn('DEPRECATION WARNING: The static encryptContent() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method encryptContent().');
  const userSession = new _userSession.UserSession();
  return userSession.encryptContent(content, options);
}
/**
 * Decrypts data encrypted with `encryptContent` with the
 * transit private key.
 * @param {String|Buffer} content - encrypted content.
 * @param {Object} [options=null] - options object
 * @param {String} options.privateKey - the hex string of the ECDSA private
 * key to use for decryption. If not provided, will use user's appPrivateKey.
 * @return {String|Buffer} decrypted content.
 */


function decryptContent(content, options) {
  console.warn('DEPRECATION WARNING: The static decryptContent() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method decryptContent().');
  const userSession = new _userSession.UserSession();
  return userSession.decryptContent(content, options);
}
/**
 * Retrieves the specified file from the app's data store.
 * @param {String} path - the path to the file to read
 * @param {Object} [options=null] - options object
 * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key
 * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
 * @param {Boolean} options.verify - Whether the content should be verified, only to be used
 * when `putFile` was set to `sign = true`
 * @param {String} options.app - the app to lookup for multi-player storage -
 * defaults to current origin
 * @param {String} [options.zoneFileLookupURL=null] - The URL
 * to use for zonefile lookup. If falsey, this will use the
 * blockstack.js's getNameInfo function instead.
 * @returns {Promise} that resolves to the raw data in the file
 * or rejects with an error
 */


function getFile(path, options) {
  console.warn('DEPRECATION WARNING: The static getFile() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method getFile().');
  const userSession = new _userSession.UserSession();
  return userSession.getFile(path, options);
}
/**
 * Stores the data provided in the app's data store to to the file specified.
 * @param {String} path - the path to store the data in
 * @param {String|Buffer} content - the data to store in the file
 * @param {Object} [options=null] - options object
 * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app public key
 *                                                  or the provided public key
 * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with
 *                                         the app private key
 * @param {String} [options.contentType=''] - set a Content-Type header for unencrypted data
 * @return {Promise} that resolves if the operation succeed and rejects
 * if it failed
 */


function putFile(path, content, options) {
  console.warn('DEPRECATION WARNING: The static putFile() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method putFile().');
  const userSession = new _userSession.UserSession();
  return userSession.putFile(path, content, options);
}
/**
 * List the set of files in this application's Gaia storage bucket.
 * @param {function} callback - a callback to invoke on each named file that
 * returns `true` to continue the listing operation or `false` to end it
 * @return {Promise} that resolves to the number of files listed
 */


function listFiles(callback) {
  console.warn('DEPRECATION WARNING: The static listFiles() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method listFiles().');
  const userSession = new _userSession.UserSession();
  return userSession.listFiles(callback);
}
/**
 * Deletes the specified file from the app's data store. Currently not implemented.
 * @param {String} path - the path to the file to delete
 * @returns {Promise} that resolves when the file has been removed
 * or rejects with an error
 * @private
 */


function deleteFile(path) {
  Promise.reject(new Error(`Delete of ${path} not supported by gaia hubs`));
}
/**
 * Fetch the public read URL of a user file for the specified app.
 * @param {String} path - the path to the file to read
 * @param {String} username - The Blockstack ID of the user to look up
 * @param {String} appOrigin - The app origin
 * @param {String} [zoneFileLookupURL=null] - The URL
 * to use for zonefile lookup. If falsey, this will use the
 * blockstack.js's getNameInfo function instead.
 * @return {Promise} that resolves to the public read URL of the file
 * or rejects with an error
 */


function getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL = null) {
  return (0, _profiles.lookupProfile)(username, zoneFileLookupURL).then(profile => {
    if (profile.hasOwnProperty('apps')) {
      if (profile.apps.hasOwnProperty(appOrigin)) {
        return profile.apps[appOrigin];
      } else {
        return null;
      }
    } else {
      return null;
    }
  }).then(bucketUrl => {
    if (bucketUrl) {
      const bucket = bucketUrl.replace(/\/?(\?|#|$)/, '/$1');
      return `${bucket}${path}`;
    } else {
      return null;
    }
  });
}
/**
 * Encrypts the data provided with the app public key.
 * @param {UserSession} caller - the instance calling this method
 * @param {String|Buffer} content - data to encrypt
 * @param {Object} [options=null] - options object
 * @param {String} options.publicKey - the hex string of the ECDSA public
 * key to use for encryption. If not provided, will use user's appPublicKey.
 * @return {String} Stringified ciphertext object
 * @private
 */


function encryptContentImpl(caller, content, options) {
  const defaults = {
    publicKey: null
  };
  const opt = Object.assign({}, defaults, options);

  if (!opt.publicKey) {
    const userData = caller.loadUserData();
    const privateKey = userData.appPrivateKey;
    opt.publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);
  }

  const cipherObject = (0, _ec.encryptECIES)(opt.publicKey, content);
  return JSON.stringify(cipherObject);
}
/**
 * Decrypts data encrypted with `encryptContent` with the
 * transit private key.
 * @param {UserSession} caller - the instance calling this method
 * @param {String|Buffer} content - encrypted content.
 * @param {Object} [options=null] - options object
 * @param {String} options.privateKey - the hex string of the ECDSA private
 * key to use for decryption. If not provided, will use user's appPrivateKey.
 * @return {String|Buffer} decrypted content.
 * @private
 */


function decryptContentImpl(caller, content, options) {
  const defaults = {
    privateKey: null
  };
  const opt = Object.assign({}, defaults, options);
  let privateKey = opt.privateKey;

  if (!privateKey) {
    privateKey = caller.loadUserData().appPrivateKey;
  }

  try {
    const cipherObject = JSON.parse(content);
    return (0, _ec.decryptECIES)(privateKey, cipherObject);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');
    } else {
      throw err;
    }
  }
}
/* Get the gaia address used for servicing multiplayer reads for the given
 * (username, app) pair.
 * @private
 */


function getGaiaAddress(caller, app, username, zoneFileLookupURL) {
  return Promise.resolve().then(() => {
    if (username) {
      return getUserAppFileUrl('/', username, app, zoneFileLookupURL);
    } else {
      return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(gaiaHubConfig => (0, _hub.getFullReadUrl)('/', gaiaHubConfig));
    }
  }).then(fileUrl => {
    const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);

    if (!matches) {
      throw new Error('Failed to parse gaia address');
    }

    return matches[matches.length - 1];
  });
}

function getFileUrlImpl(caller, path, options) {
  return Promise.resolve().then(() => {
    const appConfig = caller.appConfig;

    if (!appConfig) {
      throw new _errors.InvalidStateError('Missing AppConfig');
    }

    const defaults = {
      username: null,
      app: appConfig.appDomain,
      zoneFileLookupURL: null
    };
    return Object.assign({}, defaults, options);
  }).then(opts => {
    if (opts.username) {
      return getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);
    } else {
      return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(gaiaHubConfig => (0, _hub.getFullReadUrl)(path, gaiaHubConfig));
    }
  }).then(readUrl => new Promise((resolve, reject) => {
    if (!readUrl) {
      reject(null);
    } else {
      resolve(readUrl);
    }
  }));
}
/**
 * Get the URL for reading a file from an app's data store.
 * @param {String} path - the path to the file to read
 * @param {Object} [options=null] - options object
 * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
 * @param {String} options.app - the app to lookup for multi-player storage -
 * defaults to current origin
 * @param {String} [options.zoneFileLookupURL=null] - The URL
 * to use for zonefile lookup. If falsey, this will use the
 * blockstack.js's getNameInfo function instead.
 * @returns {Promise<string>} that resolves to the URL or rejects with an error
 */


function getFileUrl(path, options) {
  console.warn('DEPRECATION WARNING: The static getFileUrl() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method getFileUrl().');
  const userSession = new _userSession.UserSession();
  return getFileUrlImpl(userSession, path, options);
}
/* Handle fetching the contents from a given path. Handles both
 *  multi-player reads and reads from own storage.
 * @private
 */


function getFileContents(caller, path, app, username, zoneFileLookupURL, forceText) {
  return Promise.resolve().then(() => {
    const opts = {
      app,
      username,
      zoneFileLookupURL
    };
    return getFileUrlImpl(caller, path, opts);
  }).then(readUrl => fetch(readUrl)).then(response => {
    if (response.status !== 200) {
      if (response.status === 404) {
        _logger.Logger.debug(`getFile ${path} returned 404, returning null`);

        return null;
      } else {
        throw new Error(`getFile ${path} failed with HTTP status ${response.status}`);
      }
    }

    const contentType = response.headers.get('Content-Type');

    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {
      return response.text();
    } else {
      return response.arrayBuffer();
    }
  });
}
/* Handle fetching an unencrypted file, its associated signature
 *  and then validate it. Handles both multi-player reads and reads
 *  from own storage.
 * @private
 */


function getFileSignedUnencrypted(caller, path, opt) {
  // future optimization note:
  //    in the case of _multi-player_ reads, this does a lot of excess
  //    profile lookups to figure out where to read files
  //    do browsers cache all these requests if Content-Cache is set?
  return Promise.all([getFileContents(caller, path, opt.app, opt.username, opt.zoneFileLookupURL, false), getFileContents(caller, `${path}${SIGNATURE_FILE_SUFFIX}`, opt.app, opt.username, opt.zoneFileLookupURL, true), getGaiaAddress(caller, opt.app, opt.username, opt.zoneFileLookupURL)]).then(([fileContents, signatureContents, gaiaAddress]) => {
    if (!fileContents) {
      return fileContents;
    }

    if (!gaiaAddress) {
      throw new _errors.SignatureVerificationError('Failed to get gaia address for verification of: ' + `${path}`);
    }

    if (!signatureContents || typeof signatureContents !== 'string') {
      throw new _errors.SignatureVerificationError('Failed to obtain signature for file: ' + `${path} -- looked in ${path}${SIGNATURE_FILE_SUFFIX}`);
    }

    let signature;
    let publicKey;

    try {
      const sigObject = JSON.parse(signatureContents);
      signature = sigObject.signature;
      publicKey = sigObject.publicKey;
    } catch (err) {
      if (err instanceof SyntaxError) {
        throw new Error('Failed to parse signature content JSON ' + `(path: ${path}${SIGNATURE_FILE_SUFFIX})` + ' The content may be corrupted.');
      } else {
        throw err;
      }
    }

    const signerAddress = (0, _keys.publicKeyToAddress)(publicKey);

    if (gaiaAddress !== signerAddress) {
      throw new _errors.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${gaiaAddress})`);
    } else if (!(0, _ec.verifyECDSA)(Buffer.from(fileContents), publicKey, signature)) {
      throw new _errors.SignatureVerificationError('Contents do not match ECDSA signature: ' + `path: ${path}, signature: ${path}${SIGNATURE_FILE_SUFFIX}`);
    } else {
      return fileContents;
    }
  });
}
/* Handle signature verification and decryption for contents which are
 *  expected to be signed and encrypted. This works for single and
 *  multiplayer reads. In the case of multiplayer reads, it uses the
 *  gaia address for verification of the claimed public key.
 * @private
 */


function handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {
  const appPrivateKey = caller.loadUserData().appPrivateKey;
  const appPublicKey = (0, _keys.getPublicKeyFromPrivate)(appPrivateKey);
  let addressPromise;

  if (username) {
    addressPromise = getGaiaAddress(caller, app, username, zoneFileLookupURL);
  } else {
    const address = (0, _keys.publicKeyToAddress)(appPublicKey);
    addressPromise = Promise.resolve(address);
  }

  return addressPromise.then(address => {
    if (!address) {
      throw new _errors.SignatureVerificationError('Failed to get gaia address for verification of: ' + `${path}`);
    }

    let sigObject;

    try {
      sigObject = JSON.parse(storedContents);
    } catch (err) {
      if (err instanceof SyntaxError) {
        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');
      } else {
        throw err;
      }
    }

    const signature = sigObject.signature;
    const signerPublicKey = sigObject.publicKey;
    const cipherText = sigObject.cipherText;
    const signerAddress = (0, _keys.publicKeyToAddress)(signerPublicKey);

    if (!signerPublicKey || !cipherText || !signature) {
      throw new _errors.SignatureVerificationError('Failed to get signature verification data from file:' + ` ${path}`);
    } else if (signerAddress !== address) {
      throw new _errors.SignatureVerificationError(`Signer pubkey address (${signerAddress}) doesn't` + ` match gaia address (${address})`);
    } else if (!(0, _ec.verifyECDSA)(cipherText, signerPublicKey, signature)) {
      throw new _errors.SignatureVerificationError('Contents do not match ECDSA signature in file:' + ` ${path}`);
    } else {
      return caller.decryptContent(cipherText);
    }
  });
}
/**
 * Retrieves the specified file from the app's data store.
 * @param {UserSession} caller - instance calling this method
 * @param {String} path - the path to the file to read
 * @param {Object} [options=null] - options object
 * @param {Boolean} [options.decrypt=true] - try to decrypt the data with the app private key
 * @param {String} options.username - the Blockstack ID to lookup for multi-player storage
 * @param {Boolean} options.verify - Whether the content should be verified, only to be used
 * when `putFile` was set to `sign = true`
 * @param {String} options.app - the app to lookup for multi-player storage -
 * defaults to current origin
 * @param {String} [options.zoneFileLookupURL=null] - The URL
 * to use for zonefile lookup. If falsey, this will use the
 * blockstack.js's getNameInfo function instead.
 * @returns {Promise} that resolves to the raw data in the file
 * or rejects with an error
 * @private
 */


function getFileImpl(caller, path, options) {
  const appConfig = caller.appConfig;

  if (!appConfig) {
    throw new _errors.InvalidStateError('Missing AppConfig');
  }

  const defaults = {
    decrypt: true,
    verify: false,
    username: null,
    app: appConfig.appDomain,
    zoneFileLookupURL: null
  };
  const opt = Object.assign({}, defaults, options); // in the case of signature verification, but no
  //  encryption expected, need to fetch _two_ files.

  if (opt.verify && !opt.decrypt) {
    return getFileSignedUnencrypted(caller, path, opt);
  }

  return getFileContents(caller, path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt).then(storedContents => {
    if (storedContents === null) {
      return storedContents;
    } else if (opt.decrypt && !opt.verify) {
      if (typeof storedContents !== 'string') {
        throw new Error('Expected to get back a string for the cipherText');
      }

      return decryptContentImpl(caller, storedContents);
    } else if (opt.decrypt && opt.verify) {
      if (typeof storedContents !== 'string') {
        throw new Error('Expected to get back a string for the cipherText');
      }

      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);
    } else if (!opt.verify && !opt.decrypt) {
      return storedContents;
    } else {
      throw new Error('Should be unreachable.');
    }
  });
}
/**
 * Stores the data provided in the app's data store to to the file specified.
 * @param {UserSession} caller - instance calling this method
 * @param {String} path - the path to store the data in
 * @param {String|Buffer} content - the data to store in the file
 * @param {Object} [options=null] - options object
 * @param {Boolean|String} [options.encrypt=true] - encrypt the data with the app public key
 *                                                  or the provided public key
 * @param {Boolean} [options.sign=false] - sign the data using ECDSA on SHA256 hashes with
 *                                         the app private key
 * @param {String} [options.contentType=''] - set a Content-Type header for unencrypted data
 * @return {Promise} that resolves if the operation succeed and rejects
 * if it failed
 * @private
 */


function putFileImpl(caller, path, content, options) {
  const defaults = {
    encrypt: true,
    sign: false,
    contentType: ''
  };
  const opt = Object.assign({}, defaults, options);
  let {
    contentType
  } = opt;

  if (!contentType) {
    contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';
  } // First, let's figure out if we need to get public/private keys,
  //  or if they were passed in


  let privateKey = '';
  let publicKey = '';

  if (opt.sign) {
    if (typeof opt.sign === 'string') {
      privateKey = opt.sign;
    } else {
      privateKey = caller.loadUserData().appPrivateKey;
    }
  }

  if (opt.encrypt) {
    if (typeof opt.encrypt === 'string') {
      publicKey = opt.encrypt;
    } else {
      if (!privateKey) {
        privateKey = caller.loadUserData().appPrivateKey;
      }

      publicKey = (0, _keys.getPublicKeyFromPrivate)(privateKey);
    }
  } // In the case of signing, but *not* encrypting,
  //   we perform two uploads. So the control-flow
  //   here will return there.


  if (!opt.encrypt && opt.sign) {
    const signatureObject = (0, _ec.signECDSA)(privateKey, content);
    const signatureContent = JSON.stringify(signatureObject);
    return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(gaiaHubConfig => new Promise((resolve, reject) => Promise.all([(0, _hub.uploadToGaiaHub)(path, content, gaiaHubConfig, contentType), (0, _hub.uploadToGaiaHub)(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, gaiaHubConfig, 'application/json')]).then(resolve).catch(() => {
      (0, _hub.setLocalGaiaHubConnection)(caller).then(freshHubConfig => Promise.all([(0, _hub.uploadToGaiaHub)(path, content, freshHubConfig, contentType), (0, _hub.uploadToGaiaHub)(`${path}${SIGNATURE_FILE_SUFFIX}`, signatureContent, freshHubConfig, 'application/json')]).then(resolve).catch(reject));
    }))).then(fileUrls => fileUrls[0]);
  } // In all other cases, we only need one upload.


  if (opt.encrypt && !opt.sign) {
    content = encryptContentImpl(caller, content, {
      publicKey
    });
    contentType = 'application/json';
  } else if (opt.encrypt && opt.sign) {
    const cipherText = encryptContentImpl(caller, content, {
      publicKey
    });
    const signatureObject = (0, _ec.signECDSA)(privateKey, cipherText);
    const signedCipherObject = {
      signature: signatureObject.signature,
      publicKey: signatureObject.publicKey,
      cipherText
    };
    content = JSON.stringify(signedCipherObject);
    contentType = 'application/json';
  }

  return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(gaiaHubConfig => new Promise((resolve, reject) => {
    (0, _hub.uploadToGaiaHub)(path, content, gaiaHubConfig, contentType).then(resolve).catch(() => {
      (0, _hub.setLocalGaiaHubConnection)(caller).then(freshHubConfig => (0, _hub.uploadToGaiaHub)(path, content, freshHubConfig, contentType).then(resolve).catch(reject));
    });
  }));
}
/**
 * Get the app storage bucket URL
 * @param {String} gaiaHubUrl - the gaia hub URL
 * @param {String} appPrivateKey - the app private key used to generate the app address
 * @returns {Promise} That resolves to the URL of the app index file
 * or rejects if it fails
 */


function getAppBucketUrl(gaiaHubUrl, appPrivateKey) {
  return (0, _hub.getBucketUrl)(gaiaHubUrl, appPrivateKey);
}
/**
 * Loop over the list of files in a Gaia hub, and run a callback on each entry.
 * Not meant to be called by external clients.
 * @param {GaiaHubConfig} hubConfig - the Gaia hub config
 * @param {String | null} page - the page ID
 * @param {number} callCount - the loop count
 * @param {number} fileCount - the number of files listed so far
 * @param {function} callback - the callback to invoke on each file.  If it returns a falsey
 *  value, then the loop stops.  If it returns a truthy value, the loop continues.
 * @returns {Promise} that resolves to the number of files listed.
 * @private
 */


function listFilesLoop(hubConfig, page, callCount, fileCount, callback) {
  if (callCount > 65536) {
    // this is ridiculously huge, and probably indicates
    // a faulty Gaia hub anyway (e.g. on that serves endless data)
    throw new Error('Too many entries to list');
  }

  let httpStatus;
  const pageRequest = JSON.stringify({
    page
  });
  const fetchOptions = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Content-Length': `${pageRequest.length}`,
      Authorization: `bearer ${hubConfig.token}`
    },
    body: pageRequest
  };
  return fetch(`${hubConfig.server}/list-files/${hubConfig.address}`, fetchOptions).then(response => {
    httpStatus = response.status;

    if (httpStatus >= 400) {
      throw new Error(`listFiles failed with HTTP status ${httpStatus}`);
    }

    return response.text();
  }).then(responseText => JSON.parse(responseText)).then(responseJSON => {
    const entries = responseJSON.entries;
    const nextPage = responseJSON.page;

    if (entries === null || entries === undefined) {
      // indicates a misbehaving Gaia hub or a misbehaving driver
      // (i.e. the data is malformed)
      throw new Error('Bad listFiles response: no entries');
    }

    for (let i = 0; i < entries.length; i++) {
      const rc = callback(entries[i]);

      if (!rc) {
        // callback indicates that we're done
        return Promise.resolve(fileCount + i);
      }
    }

    if (nextPage && entries.length > 0) {
      // keep going -- have more entries
      return listFilesLoop(hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);
    } else {
      // no more entries -- end of data
      return Promise.resolve(fileCount + entries.length);
    }
  });
}
/**
 * List the set of files in this application's Gaia storage bucket.
 * @param {UserSession} caller - instance calling this method
 * @param {function} callback - a callback to invoke on each named file that
 * returns `true` to continue the listing operation or `false` to end it
 * @return {Promise} that resolves to the number of files listed
 * @private
 */


function listFilesImpl(caller, callback) {
  return (0, _hub.getOrSetLocalGaiaHubConnection)(caller).then(gaiaHubConfig => listFilesLoop(gaiaHubConfig, null, 0, 0, callback));
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdG9yYWdlL2luZGV4LmpzIl0sIm5hbWVzIjpbIlNJR05BVFVSRV9GSUxFX1NVRkZJWCIsImVuY3J5cHRDb250ZW50IiwiY29udGVudCIsIm9wdGlvbnMiLCJjb25zb2xlIiwid2FybiIsInVzZXJTZXNzaW9uIiwiVXNlclNlc3Npb24iLCJkZWNyeXB0Q29udGVudCIsImdldEZpbGUiLCJwYXRoIiwicHV0RmlsZSIsImxpc3RGaWxlcyIsImNhbGxiYWNrIiwiZGVsZXRlRmlsZSIsIlByb21pc2UiLCJyZWplY3QiLCJFcnJvciIsImdldFVzZXJBcHBGaWxlVXJsIiwidXNlcm5hbWUiLCJhcHBPcmlnaW4iLCJ6b25lRmlsZUxvb2t1cFVSTCIsInRoZW4iLCJwcm9maWxlIiwiaGFzT3duUHJvcGVydHkiLCJhcHBzIiwiYnVja2V0VXJsIiwiYnVja2V0IiwicmVwbGFjZSIsImVuY3J5cHRDb250ZW50SW1wbCIsImNhbGxlciIsImRlZmF1bHRzIiwicHVibGljS2V5Iiwib3B0IiwiT2JqZWN0IiwiYXNzaWduIiwidXNlckRhdGEiLCJsb2FkVXNlckRhdGEiLCJwcml2YXRlS2V5IiwiYXBwUHJpdmF0ZUtleSIsImNpcGhlck9iamVjdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZWNyeXB0Q29udGVudEltcGwiLCJwYXJzZSIsImVyciIsIlN5bnRheEVycm9yIiwiZ2V0R2FpYUFkZHJlc3MiLCJhcHAiLCJyZXNvbHZlIiwiZ2FpYUh1YkNvbmZpZyIsImZpbGVVcmwiLCJtYXRjaGVzIiwibWF0Y2giLCJsZW5ndGgiLCJnZXRGaWxlVXJsSW1wbCIsImFwcENvbmZpZyIsIkludmFsaWRTdGF0ZUVycm9yIiwiYXBwRG9tYWluIiwib3B0cyIsInJlYWRVcmwiLCJnZXRGaWxlVXJsIiwiZ2V0RmlsZUNvbnRlbnRzIiwiZm9yY2VUZXh0IiwiZmV0Y2giLCJyZXNwb25zZSIsInN0YXR1cyIsIkxvZ2dlciIsImRlYnVnIiwiY29udGVudFR5cGUiLCJoZWFkZXJzIiwiZ2V0Iiwic3RhcnRzV2l0aCIsInRleHQiLCJhcnJheUJ1ZmZlciIsImdldEZpbGVTaWduZWRVbmVuY3J5cHRlZCIsImFsbCIsImZpbGVDb250ZW50cyIsInNpZ25hdHVyZUNvbnRlbnRzIiwiZ2FpYUFkZHJlc3MiLCJTaWduYXR1cmVWZXJpZmljYXRpb25FcnJvciIsInNpZ25hdHVyZSIsInNpZ09iamVjdCIsInNpZ25lckFkZHJlc3MiLCJCdWZmZXIiLCJmcm9tIiwiaGFuZGxlU2lnbmVkRW5jcnlwdGVkQ29udGVudHMiLCJzdG9yZWRDb250ZW50cyIsImFwcFB1YmxpY0tleSIsImFkZHJlc3NQcm9taXNlIiwiYWRkcmVzcyIsInNpZ25lclB1YmxpY0tleSIsImNpcGhlclRleHQiLCJnZXRGaWxlSW1wbCIsImRlY3J5cHQiLCJ2ZXJpZnkiLCJwdXRGaWxlSW1wbCIsImVuY3J5cHQiLCJzaWduIiwic2lnbmF0dXJlT2JqZWN0Iiwic2lnbmF0dXJlQ29udGVudCIsImNhdGNoIiwiZnJlc2hIdWJDb25maWciLCJmaWxlVXJscyIsInNpZ25lZENpcGhlck9iamVjdCIsImdldEFwcEJ1Y2tldFVybCIsImdhaWFIdWJVcmwiLCJsaXN0RmlsZXNMb29wIiwiaHViQ29uZmlnIiwicGFnZSIsImNhbGxDb3VudCIsImZpbGVDb3VudCIsImh0dHBTdGF0dXMiLCJwYWdlUmVxdWVzdCIsImZldGNoT3B0aW9ucyIsIm1ldGhvZCIsIkF1dGhvcml6YXRpb24iLCJ0b2tlbiIsImJvZHkiLCJzZXJ2ZXIiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZUpTT04iLCJlbnRyaWVzIiwibmV4dFBhZ2UiLCJ1bmRlZmluZWQiLCJpIiwicmMiLCJsaXN0RmlsZXNJbXBsIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUE7Ozs7OztBQU9BOztBQUdBOztBQUNBOztBQUNBOztBQUlBOztBQUVBOztBQWJBO0FBcUJBLE1BQU1BLHFCQUFxQixHQUFHLE1BQTlCO0FBR0E7Ozs7Ozs7OztBQVFPLFNBQVNDLGNBQVQs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SHViQ29ubmVjdGlvbiwgZ2V0RnVsbFJlYWRVcmwsIHNldExvY2FsR2FpYUh1YkNvbm5lY3Rpb24sXG4gIGNvbm5lY3RUb0dhaWFIdWIsIHVwbG9hZFRvR2FpYUh1YiwgZ2V0QnVja2V0VXJsLCBCTE9DS1NUQUNLX0dBSUFfSFVCX0xBQkVMLCBcbiAgdHlwZSBHYWlhSHViQ29uZmlnXG59IGZyb20gJy4vaHViJ1xuLy8gZXhwb3J0IHsgdHlwZSBHYWlhSHViQ29uZmlnIH0gZnJvbSAnLi9odWInXG5cbmltcG9ydCB7XG4gIGVuY3J5cHRFQ0lFUywgZGVjcnlwdEVDSUVTLCBzaWduRUNEU0EsIHZlcmlmeUVDRFNBXG59IGZyb20gJy4uL2VuY3J5cHRpb24vZWMnXG5pbXBvcnQgeyBnZXRQdWJsaWNLZXlGcm9tUHJpdmF0ZSwgcHVibGljS2V5VG9BZGRyZXNzIH0gZnJvbSAnLi4va2V5cydcbmltcG9ydCB7IGxvb2t1cFByb2ZpbGUgfSBmcm9tICcuLi9wcm9maWxlcydcbmltcG9ydCB7XG4gIEludmFsaWRTdGF0ZUVycm9yLFxuICBTaWduYXR1cmVWZXJpZmljYXRpb25FcnJvclxufSBmcm9tICcuLi9lcnJvcnMnXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInXG5cbmltcG9ydCB7IFVzZXJTZXNzaW9uIH0gZnJvbSAnLi4vYXV0aC91c2VyU2Vzc2lvbidcblxuZXhwb3J0IHR5cGUgUHV0RmlsZU9wdGlvbnMgPSB7XG4gIGVuY3J5cHQ/OiBib29sZWFuIHwgc3RyaW5nLFxuICBzaWduPzogYm9vbGVhbixcbiAgY29udGVudFR5cGU/OiBzdHJpbmdcbn1cblxuY29uc3QgU0lHTkFUVVJFX0ZJTEVfU1VGRklYID0gJy5zaWcnXG5cblxuLyoqXG4gKiBFbmNyeXB0cyB0aGUgZGF0YSBwcm92aWRlZCB3aXRoIHRoZSBhcHAgcHVibGljIGtleS5cbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gY29udGVudCAtIGRhdGEgdG8gZW5jcnlwdFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPW51bGxdIC0gb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnB1YmxpY0tleSAtIHRoZSBoZXggc3RyaW5nIG9mIHRoZSBFQ0RTQSBwdWJsaWNcbiAqIGtleSB0byB1c2UgZm9yIGVuY3J5cHRpb24uIElmIG5vdCBwcm92aWRlZCwgd2lsbCB1c2UgdXNlcidzIGFwcFB1YmxpY0tleS5cbiAqIEByZXR1cm4ge1N0cmluZ30gU3RyaW5naWZpZWQgY2lwaGVydGV4dCBvYmplY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRDb250ZW50KGNvbnRlbnQ6IHN0cmluZyB8IEJ1ZmZlciwgb3B0aW9ucz86IHtwdWJsaWNLZXk/OiBzdHJpbmd9KSB7XG4gIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogVGhlIHN0YXRpYyBlbmNyeXB0Q29udGVudCgpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiAnXG4gICAgKyAndGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2QgZW5jcnlwdENvbnRlbnQoKS4nKVxuICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBVc2VyU2Vzc2lvbigpXG4gIHJldHVybiB1c2VyU2Vzc2lvbi5lbmNyeXB0Q29udGVudChjb250ZW50LCBvcHRpb25zKVxufVxuXG4vKipcbiAqIERlY3J5cHRzIGRhdGEgZW5jcnlwdGVkIHdpdGggYGVuY3J5cHRDb250ZW50YCB3aXRoIHRoZVxuICogdHJhbnNpdCBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gY29udGVudCAtIGVuY3J5cHRlZCBjb250ZW50LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPW51bGxdIC0gb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnByaXZhdGVLZXkgLSB0aGUgaGV4IHN0cmluZyBvZiB0aGUgRUNEU0EgcHJpdmF0ZVxuICoga2V5IHRvIHVzZSBmb3IgZGVjcnlwdGlvbi4gSWYgbm90IHByb3ZpZGVkLCB3aWxsIHVzZSB1c2VyJ3MgYXBwUHJpdmF0ZUtleS5cbiAqIEByZXR1cm4ge1N0cmluZ3xCdWZmZXJ9IGRlY3J5cHRlZCBjb250ZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdENvbnRlbnQoY29udGVudDogc3RyaW5nLCBvcHRpb25zPzoge3ByaXZhdGVLZXk/OiA/c3RyaW5nfSkge1xuICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IFRoZSBzdGF0aWMgZGVjcnlwdENvbnRlbnQoKSBmdW5jdGlvbiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gJ1xuICAgICsgJ3RoZSBuZXh0IG1ham9yIHJlbGVhc2Ugb2YgYmxvY2tzdGFjay5qcy4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFVzZXJTZXNzaW9uIGFuZCBjYWxsIHRoZSAnXG4gICAgKyAnaW5zdGFuY2UgbWV0aG9kIGRlY3J5cHRDb250ZW50KCkuJylcbiAgY29uc3QgdXNlclNlc3Npb24gPSBuZXcgVXNlclNlc3Npb24oKVxuICByZXR1cm4gdXNlclNlc3Npb24uZGVjcnlwdENvbnRlbnQoY29udGVudCwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHNwZWNpZmllZCBmaWxlIGZyb20gdGhlIGFwcCdzIGRhdGEgc3RvcmUuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCAtIHRoZSBwYXRoIHRvIHRoZSBmaWxlIHRvIHJlYWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz1udWxsXSAtIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmRlY3J5cHQ9dHJ1ZV0gLSB0cnkgdG8gZGVjcnlwdCB0aGUgZGF0YSB3aXRoIHRoZSBhcHAgcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVzZXJuYW1lIC0gdGhlIEJsb2Nrc3RhY2sgSUQgdG8gbG9va3VwIGZvciBtdWx0aS1wbGF5ZXIgc3RvcmFnZVxuICogQHBhcmFtIHtCb29sZWFufSBvcHRpb25zLnZlcmlmeSAtIFdoZXRoZXIgdGhlIGNvbnRlbnQgc2hvdWxkIGJlIHZlcmlmaWVkLCBvbmx5IHRvIGJlIHVzZWRcbiAqIHdoZW4gYHB1dEZpbGVgIHdhcyBzZXQgdG8gYHNpZ24gPSB0cnVlYFxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBwIC0gdGhlIGFwcCB0byBsb29rdXAgZm9yIG11bHRpLXBsYXllciBzdG9yYWdlIC1cbiAqIGRlZmF1bHRzIHRvIGN1cnJlbnQgb3JpZ2luXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuem9uZUZpbGVMb29rdXBVUkw9bnVsbF0gLSBUaGUgVVJMXG4gKiB0byB1c2UgZm9yIHpvbmVmaWxlIGxvb2t1cC4gSWYgZmFsc2V5LCB0aGlzIHdpbGwgdXNlIHRoZVxuICogYmxvY2tzdGFjay5qcydzIGdldE5hbWVJbmZvIGZ1bmN0aW9uIGluc3RlYWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB0byB0aGUgcmF3IGRhdGEgaW4gdGhlIGZpbGVcbiAqIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmlsZShwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7XG4gICAgZGVjcnlwdD86IGJvb2xlYW4sXG4gICAgdmVyaWZ5PzogYm9vbGVhbixcbiAgICB1c2VybmFtZT86IHN0cmluZyxcbiAgICBhcHA/OiBzdHJpbmcsXG4gICAgem9uZUZpbGVMb29rdXBVUkw/OiA/c3RyaW5nXG4gIH0pIHtcbiAgY29uc29sZS53YXJuKCdERVBSRUNBVElPTiBXQVJOSU5HOiBUaGUgc3RhdGljIGdldEZpbGUoKSBmdW5jdGlvbiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gJ1xuICAgICsgJ3RoZSBuZXh0IG1ham9yIHJlbGVhc2Ugb2YgYmxvY2tzdGFjay5qcy4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFVzZXJTZXNzaW9uIGFuZCBjYWxsIHRoZSAnXG4gICAgKyAnaW5zdGFuY2UgbWV0aG9kIGdldEZpbGUoKS4nKVxuICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBVc2VyU2Vzc2lvbigpXG4gIHJldHVybiB1c2VyU2Vzc2lvbi5nZXRGaWxlKHBhdGgsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogU3RvcmVzIHRoZSBkYXRhIHByb3ZpZGVkIGluIHRoZSBhcHAncyBkYXRhIHN0b3JlIHRvIHRvIHRoZSBmaWxlIHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gc3RvcmUgdGhlIGRhdGEgaW5cbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcn0gY29udGVudCAtIHRoZSBkYXRhIHRvIHN0b3JlIGluIHRoZSBmaWxlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9bnVsbF0gLSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufFN0cmluZ30gW29wdGlvbnMuZW5jcnlwdD10cnVlXSAtIGVuY3J5cHQgdGhlIGRhdGEgd2l0aCB0aGUgYXBwIHB1YmxpYyBrZXlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciB0aGUgcHJvdmlkZWQgcHVibGljIGtleVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zaWduPWZhbHNlXSAtIHNpZ24gdGhlIGRhdGEgdXNpbmcgRUNEU0Egb24gU0hBMjU2IGhhc2hlcyB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGFwcCBwcml2YXRlIGtleVxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmNvbnRlbnRUeXBlPScnXSAtIHNldCBhIENvbnRlbnQtVHlwZSBoZWFkZXIgZm9yIHVuZW5jcnlwdGVkIGRhdGFcbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgaWYgdGhlIG9wZXJhdGlvbiBzdWNjZWVkIGFuZCByZWplY3RzXG4gKiBpZiBpdCBmYWlsZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1dEZpbGUocGF0aDogc3RyaW5nLCBjb250ZW50OiBzdHJpbmcgfCBCdWZmZXIsIG9wdGlvbnM/OiB7XG4gIGVuY3J5cHQ/OiBib29sZWFuIHwgc3RyaW5nLFxuICBzaWduPzogYm9vbGVhbixcbiAgY29udGVudFR5cGU/OiBzdHJpbmdcbiAgfSkge1xuICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IFRoZSBzdGF0aWMgcHV0RmlsZSgpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiAnXG4gICAgKyAndGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2QgcHV0RmlsZSgpLicpXG4gIGNvbnN0IHVzZXJTZXNzaW9uID0gbmV3IFVzZXJTZXNzaW9uKClcbiAgcmV0dXJuIHVzZXJTZXNzaW9uLnB1dEZpbGUocGF0aCwgY29udGVudCwgb3B0aW9ucylcbn1cblxuLyoqXG4gKiBMaXN0IHRoZSBzZXQgb2YgZmlsZXMgaW4gdGhpcyBhcHBsaWNhdGlvbidzIEdhaWEgc3RvcmFnZSBidWNrZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGEgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggbmFtZWQgZmlsZSB0aGF0XG4gKiByZXR1cm5zIGB0cnVlYCB0byBjb250aW51ZSB0aGUgbGlzdGluZyBvcGVyYXRpb24gb3IgYGZhbHNlYCB0byBlbmQgaXRcbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBmaWxlcyBsaXN0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpc3RGaWxlcyhjYWxsYmFjazogKG5hbWU6IHN0cmluZykgPT4gYm9vbGVhbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IFRoZSBzdGF0aWMgbGlzdEZpbGVzKCkgZnVuY3Rpb24gd2lsbCBiZSBkZXByZWNhdGVkIGluICdcbiAgICArICd0aGUgbmV4dCBtYWpvciByZWxlYXNlIG9mIGJsb2Nrc3RhY2suanMuIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBVc2VyU2Vzc2lvbiBhbmQgY2FsbCB0aGUgJ1xuICAgICsgJ2luc3RhbmNlIG1ldGhvZCBsaXN0RmlsZXMoKS4nKVxuICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBVc2VyU2Vzc2lvbigpXG4gIHJldHVybiB1c2VyU2Vzc2lvbi5saXN0RmlsZXMoY2FsbGJhY2spXG59XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgc3BlY2lmaWVkIGZpbGUgZnJvbSB0aGUgYXBwJ3MgZGF0YSBzdG9yZS4gQ3VycmVudGx5IG5vdCBpbXBsZW1lbnRlZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gZGVsZXRlXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBmaWxlIGhhcyBiZWVuIHJlbW92ZWRcbiAqIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGV0ZUZpbGUocGF0aDogc3RyaW5nKSB7XG4gIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgRGVsZXRlIG9mICR7cGF0aH0gbm90IHN1cHBvcnRlZCBieSBnYWlhIGh1YnNgKSlcbn1cblxuLyoqXG4gKiBGZXRjaCB0aGUgcHVibGljIHJlYWQgVVJMIG9mIGEgdXNlciBmaWxlIGZvciB0aGUgc3BlY2lmaWVkIGFwcC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZFxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIC0gVGhlIEJsb2Nrc3RhY2sgSUQgb2YgdGhlIHVzZXIgdG8gbG9vayB1cFxuICogQHBhcmFtIHtTdHJpbmd9IGFwcE9yaWdpbiAtIFRoZSBhcHAgb3JpZ2luXG4gKiBAcGFyYW0ge1N0cmluZ30gW3pvbmVGaWxlTG9va3VwVVJMPW51bGxdIC0gVGhlIFVSTFxuICogdG8gdXNlIGZvciB6b25lZmlsZSBsb29rdXAuIElmIGZhbHNleSwgdGhpcyB3aWxsIHVzZSB0aGVcbiAqIGJsb2Nrc3RhY2suanMncyBnZXROYW1lSW5mbyBmdW5jdGlvbiBpbnN0ZWFkLlxuICogQHJldHVybiB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB0byB0aGUgcHVibGljIHJlYWQgVVJMIG9mIHRoZSBmaWxlXG4gKiBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVzZXJBcHBGaWxlVXJsKHBhdGg6IHN0cmluZywgdXNlcm5hbWU6IHN0cmluZywgYXBwT3JpZ2luOiBzdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgem9uZUZpbGVMb29rdXBVUkw6ID9zdHJpbmcgPSBudWxsKSB7XG4gIHJldHVybiBsb29rdXBQcm9maWxlKHVzZXJuYW1lLCB6b25lRmlsZUxvb2t1cFVSTClcbiAgICAudGhlbigocHJvZmlsZSkgPT4ge1xuICAgICAgaWYgKHByb2ZpbGUuaGFzT3duUHJvcGVydHkoJ2FwcHMnKSkge1xuICAgICAgICBpZiAocHJvZmlsZS5hcHBzLmhhc093blByb3BlcnR5KGFwcE9yaWdpbikpIHtcbiAgICAgICAgICByZXR1cm4gcHJvZmlsZS5hcHBzW2FwcE9yaWdpbl1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0pXG4gICAgLnRoZW4oKGJ1Y2tldFVybCkgPT4ge1xuICAgICAgaWYgKGJ1Y2tldFVybCkge1xuICAgICAgICBjb25zdCBidWNrZXQgPSBidWNrZXRVcmwucmVwbGFjZSgvXFwvPyhcXD98I3wkKS8sICcvJDEnKVxuICAgICAgICByZXR1cm4gYCR7YnVja2V0fSR7cGF0aH1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogRW5jcnlwdHMgdGhlIGRhdGEgcHJvdmlkZWQgd2l0aCB0aGUgYXBwIHB1YmxpYyBrZXkuXG4gKiBAcGFyYW0ge1VzZXJTZXNzaW9ufSBjYWxsZXIgLSB0aGUgaW5zdGFuY2UgY2FsbGluZyB0aGlzIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBjb250ZW50IC0gZGF0YSB0byBlbmNyeXB0XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9bnVsbF0gLSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHVibGljS2V5IC0gdGhlIGhleCBzdHJpbmcgb2YgdGhlIEVDRFNBIHB1YmxpY1xuICoga2V5IHRvIHVzZSBmb3IgZW5jcnlwdGlvbi4gSWYgbm90IHByb3ZpZGVkLCB3aWxsIHVzZSB1c2VyJ3MgYXBwUHVibGljS2V5LlxuICogQHJldHVybiB7U3RyaW5nfSBTdHJpbmdpZmllZCBjaXBoZXJ0ZXh0IG9iamVjdFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRDb250ZW50SW1wbChjYWxsZXI6IFVzZXJTZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBzdHJpbmcgfCBCdWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM/OiB7cHVibGljS2V5Pzogc3RyaW5nfSkge1xuICBjb25zdCBkZWZhdWx0cyA9IHsgcHVibGljS2V5OiBudWxsIH1cbiAgY29uc3Qgb3B0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIG9wdGlvbnMpXG4gIGlmICghb3B0LnB1YmxpY0tleSkge1xuICAgIGNvbnN0IHVzZXJEYXRhID0gY2FsbGVyLmxvYWRVc2VyRGF0YSgpXG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHVzZXJEYXRhLmFwcFByaXZhdGVLZXlcbiAgICBvcHQucHVibGljS2V5ID0gZ2V0UHVibGljS2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSlcbiAgfVxuXG4gIGNvbnN0IGNpcGhlck9iamVjdCA9IGVuY3J5cHRFQ0lFUyhvcHQucHVibGljS2V5LCBjb250ZW50KVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY2lwaGVyT2JqZWN0KVxufVxuXG4vKipcbiAqIERlY3J5cHRzIGRhdGEgZW5jcnlwdGVkIHdpdGggYGVuY3J5cHRDb250ZW50YCB3aXRoIHRoZVxuICogdHJhbnNpdCBwcml2YXRlIGtleS5cbiAqIEBwYXJhbSB7VXNlclNlc3Npb259IGNhbGxlciAtIHRoZSBpbnN0YW5jZSBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IGNvbnRlbnQgLSBlbmNyeXB0ZWQgY29udGVudC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz1udWxsXSAtIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcml2YXRlS2V5IC0gdGhlIGhleCBzdHJpbmcgb2YgdGhlIEVDRFNBIHByaXZhdGVcbiAqIGtleSB0byB1c2UgZm9yIGRlY3J5cHRpb24uIElmIG5vdCBwcm92aWRlZCwgd2lsbCB1c2UgdXNlcidzIGFwcFByaXZhdGVLZXkuXG4gKiBAcmV0dXJuIHtTdHJpbmd8QnVmZmVyfSBkZWNyeXB0ZWQgY29udGVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNyeXB0Q29udGVudEltcGwoY2FsbGVyOiBVc2VyU2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPzoge3ByaXZhdGVLZXk/OiA/c3RyaW5nfSkge1xuICBjb25zdCBkZWZhdWx0cyA9IHsgcHJpdmF0ZUtleTogbnVsbCB9XG4gIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKVxuICBsZXQgcHJpdmF0ZUtleSA9IG9wdC5wcml2YXRlS2V5XG4gIGlmICghcHJpdmF0ZUtleSkge1xuICAgIHByaXZhdGVLZXkgPSBjYWxsZXIubG9hZFVzZXJEYXRhKCkuYXBwUHJpdmF0ZUtleVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBjaXBoZXJPYmplY3QgPSBKU09OLnBhcnNlKGNvbnRlbnQpXG4gICAgcmV0dXJuIGRlY3J5cHRFQ0lFUyhwcml2YXRlS2V5LCBjaXBoZXJPYmplY3QpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgZW5jcnlwdGVkIGNvbnRlbnQgSlNPTi4gVGhlIGNvbnRlbnQgbWF5IG5vdCAnXG4gICAgICAgICAgICAgICAgICAgICAgKyAnYmUgZW5jcnlwdGVkLiBJZiB1c2luZyBnZXRGaWxlLCB0cnkgcGFzc2luZyB7IGRlY3J5cHQ6IGZhbHNlIH0uJylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG59XG5cbi8qIEdldCB0aGUgZ2FpYSBhZGRyZXNzIHVzZWQgZm9yIHNlcnZpY2luZyBtdWx0aXBsYXllciByZWFkcyBmb3IgdGhlIGdpdmVuXG4gKiAodXNlcm5hbWUsIGFwcCkgcGFpci5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGdldEdhaWFBZGRyZXNzKGNhbGxlcjogVXNlclNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcHA6IHN0cmluZywgdXNlcm5hbWU6ID9zdHJpbmcsIHpvbmVGaWxlTG9va3VwVVJMOiA/c3RyaW5nKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmICh1c2VybmFtZSkge1xuICAgICAgICByZXR1cm4gZ2V0VXNlckFwcEZpbGVVcmwoJy8nLCB1c2VybmFtZSwgYXBwLCB6b25lRmlsZUxvb2t1cFVSTClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRPclNldExvY2FsR2FpYUh1YkNvbm5lY3Rpb24oY2FsbGVyKVxuICAgICAgICAgIC50aGVuKGdhaWFIdWJDb25maWcgPT4gZ2V0RnVsbFJlYWRVcmwoJy8nLCBnYWlhSHViQ29uZmlnKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC50aGVuKChmaWxlVXJsKSA9PiB7XG4gICAgICBjb25zdCBtYXRjaGVzID0gZmlsZVVybC5tYXRjaCgvKFsxM11bYS1rbS16QS1ISi1OUC1aMC05XXsyNiwzNX0pLylcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBnYWlhIGFkZHJlc3MnKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXVxuICAgIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlVXJsSW1wbChjYWxsZXI6IFVzZXJTZXNzaW9uLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7XG4gICAgYXBwPzogc3RyaW5nLCBcbiAgICB1c2VybmFtZT86IHN0cmluZywgXG4gICAgem9uZUZpbGVMb29rdXBVUkw/OiA/c3RyaW5nIFxuICB9KTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgYXBwQ29uZmlnID0gY2FsbGVyLmFwcENvbmZpZ1xuICAgICAgaWYgKCFhcHBDb25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKCdNaXNzaW5nIEFwcENvbmZpZycpXG4gICAgICB9XG4gICAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgICAgdXNlcm5hbWU6IG51bGwsXG4gICAgICAgIGFwcDogYXBwQ29uZmlnLmFwcERvbWFpbixcbiAgICAgICAgem9uZUZpbGVMb29rdXBVUkw6IG51bGxcbiAgICAgIH1cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucylcbiAgICB9KVxuICAgIC50aGVuKChvcHRzKSA9PiB7XG4gICAgICBpZiAob3B0cy51c2VybmFtZSkge1xuICAgICAgICByZXR1cm4gZ2V0VXNlckFwcEZpbGVVcmwocGF0aCwgb3B0cy51c2VybmFtZSwgb3B0cy5hcHAsIG9wdHMuem9uZUZpbGVMb29rdXBVUkwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0T3JTZXRMb2NhbEdhaWFIdWJDb25uZWN0aW9uKGNhbGxlcilcbiAgICAgICAgICAudGhlbihnYWlhSHViQ29uZmlnID0+IGdldEZ1bGxSZWFkVXJsKHBhdGgsIGdhaWFIdWJDb25maWcpKVxuICAgICAgfVxuICAgIH0pXG4gICAgLnRoZW4ocmVhZFVybCA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIXJlYWRVcmwpIHtcbiAgICAgICAgcmVqZWN0KG51bGwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKHJlYWRVcmwpXG4gICAgICB9XG4gICAgfSkpXG59XG5cbi8qKlxuICogR2V0IHRoZSBVUkwgZm9yIHJlYWRpbmcgYSBmaWxlIGZyb20gYW4gYXBwJ3MgZGF0YSBzdG9yZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIC0gdGhlIHBhdGggdG8gdGhlIGZpbGUgdG8gcmVhZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPW51bGxdIC0gb3B0aW9ucyBvYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLnVzZXJuYW1lIC0gdGhlIEJsb2Nrc3RhY2sgSUQgdG8gbG9va3VwIGZvciBtdWx0aS1wbGF5ZXIgc3RvcmFnZVxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuYXBwIC0gdGhlIGFwcCB0byBsb29rdXAgZm9yIG11bHRpLXBsYXllciBzdG9yYWdlIC1cbiAqIGRlZmF1bHRzIHRvIGN1cnJlbnQgb3JpZ2luXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuem9uZUZpbGVMb29rdXBVUkw9bnVsbF0gLSBUaGUgVVJMXG4gKiB0byB1c2UgZm9yIHpvbmVmaWxlIGxvb2t1cC4gSWYgZmFsc2V5LCB0aGlzIHdpbGwgdXNlIHRoZVxuICogYmxvY2tzdGFjay5qcydzIGdldE5hbWVJbmZvIGZ1bmN0aW9uIGluc3RlYWQuXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSB0aGF0IHJlc29sdmVzIHRvIHRoZSBVUkwgb3IgcmVqZWN0cyB3aXRoIGFuIGVycm9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlVXJsKHBhdGg6IHN0cmluZywgb3B0aW9ucz86IHtcbiAgICB1c2VybmFtZT86IHN0cmluZyxcbiAgICBhcHA/OiBzdHJpbmcsXG4gICAgem9uZUZpbGVMb29rdXBVUkw/OiA/c3RyaW5nXG4gIH0pOiBQcm9taXNlPHN0cmluZz4ge1xuICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IFRoZSBzdGF0aWMgZ2V0RmlsZVVybCgpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiAnXG4gICAgKyAndGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2QgZ2V0RmlsZVVybCgpLicpXG4gIGNvbnN0IHVzZXJTZXNzaW9uID0gbmV3IFVzZXJTZXNzaW9uKClcbiAgcmV0dXJuIGdldEZpbGVVcmxJbXBsKHVzZXJTZXNzaW9uLCBwYXRoLCBvcHRpb25zKVxufVxuXG4vKiBIYW5kbGUgZmV0Y2hpbmcgdGhlIGNvbnRlbnRzIGZyb20gYSBnaXZlbiBwYXRoLiBIYW5kbGVzIGJvdGhcbiAqICBtdWx0aS1wbGF5ZXIgcmVhZHMgYW5kIHJlYWRzIGZyb20gb3duIHN0b3JhZ2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRGaWxlQ29udGVudHMoY2FsbGVyOiBVc2VyU2Vzc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBzdHJpbmcsIGFwcDogc3RyaW5nLCB1c2VybmFtZTogP3N0cmluZywgem9uZUZpbGVMb29rdXBVUkw6ID9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VUZXh0OiBib29sZWFuKSA6IFByb21pc2U8P3N0cmluZyB8ID9BcnJheUJ1ZmZlcj4ge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCBvcHRzOiBhbnkgPSB7IGFwcCwgdXNlcm5hbWUsIHpvbmVGaWxlTG9va3VwVVJMIH1cbiAgICAgIHJldHVybiBnZXRGaWxlVXJsSW1wbChjYWxsZXIsIHBhdGgsIG9wdHMpXG4gICAgfSlcbiAgICAudGhlbihyZWFkVXJsID0+IGZldGNoKHJlYWRVcmwpKVxuICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgIExvZ2dlci5kZWJ1ZyhgZ2V0RmlsZSAke3BhdGh9IHJldHVybmVkIDQwNCwgcmV0dXJuaW5nIG51bGxgKVxuICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBnZXRGaWxlICR7cGF0aH0gZmFpbGVkIHdpdGggSFRUUCBzdGF0dXMgJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJylcbiAgICAgIGlmIChmb3JjZVRleHQgfHwgY29udGVudFR5cGUgPT09IG51bGxcbiAgICAgICAgICB8fCBjb250ZW50VHlwZS5zdGFydHNXaXRoKCd0ZXh0JylcbiAgICAgICAgICB8fCBjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL2pzb24nKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpXG4gICAgICB9XG4gICAgfSlcbn1cblxuLyogSGFuZGxlIGZldGNoaW5nIGFuIHVuZW5jcnlwdGVkIGZpbGUsIGl0cyBhc3NvY2lhdGVkIHNpZ25hdHVyZVxuICogIGFuZCB0aGVuIHZhbGlkYXRlIGl0LiBIYW5kbGVzIGJvdGggbXVsdGktcGxheWVyIHJlYWRzIGFuZCByZWFkc1xuICogIGZyb20gb3duIHN0b3JhZ2UuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRGaWxlU2lnbmVkVW5lbmNyeXB0ZWQoY2FsbGVyOiBVc2VyU2Vzc2lvbiwgcGF0aDogc3RyaW5nLCBvcHQ6IHtcbiAgdXNlcm5hbWU/OiA/c3RyaW5nLFxuICBhcHA6IHN0cmluZyxcbiAgem9uZUZpbGVMb29rdXBVUkw/OiA/c3RyaW5nXG59KSB7XG4gIC8vIGZ1dHVyZSBvcHRpbWl6YXRpb24gbm90ZTpcbiAgLy8gICAgaW4gdGhlIGNhc2Ugb2YgX211bHRpLXBsYXllcl8gcmVhZHMsIHRoaXMgZG9lcyBhIGxvdCBvZiBleGNlc3NcbiAgLy8gICAgcHJvZmlsZSBsb29rdXBzIHRvIGZpZ3VyZSBvdXQgd2hlcmUgdG8gcmVhZCBmaWxlc1xuICAvLyAgICBkbyBicm93c2VycyBjYWNoZSBhbGwgdGhlc2UgcmVxdWVzdHMgaWYgQ29udGVudC1DYWNoZSBpcyBzZXQ/XG4gIHJldHVybiBQcm9taXNlLmFsbChcbiAgICBbZ2V0RmlsZUNvbnRlbnRzKGNhbGxlciwgcGF0aCwgb3B0LmFwcCwgb3B0LnVzZXJuYW1lLCBvcHQuem9uZUZpbGVMb29rdXBVUkwsIGZhbHNlKSxcbiAgICAgZ2V0RmlsZUNvbnRlbnRzKGNhbGxlciwgYCR7cGF0aH0ke1NJR05BVFVSRV9GSUxFX1NVRkZJWH1gLCBvcHQuYXBwLCBvcHQudXNlcm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICBvcHQuem9uZUZpbGVMb29rdXBVUkwsIHRydWUpLFxuICAgICBnZXRHYWlhQWRkcmVzcyhjYWxsZXIsIG9wdC5hcHAsIG9wdC51c2VybmFtZSwgb3B0LnpvbmVGaWxlTG9va3VwVVJMKV1cbiAgKVxuICAgIC50aGVuKChbZmlsZUNvbnRlbnRzLCBzaWduYXR1cmVDb250ZW50cywgZ2FpYUFkZHJlc3NdKSA9PiB7XG4gICAgICBpZiAoIWZpbGVDb250ZW50cykge1xuICAgICAgICByZXR1cm4gZmlsZUNvbnRlbnRzXG4gICAgICB9XG4gICAgICBpZiAoIWdhaWFBZGRyZXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduYXR1cmVWZXJpZmljYXRpb25FcnJvcignRmFpbGVkIHRvIGdldCBnYWlhIGFkZHJlc3MgZm9yIHZlcmlmaWNhdGlvbiBvZjogJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBgJHtwYXRofWApXG4gICAgICB9XG4gICAgICBpZiAoIXNpZ25hdHVyZUNvbnRlbnRzIHx8IHR5cGVvZiBzaWduYXR1cmVDb250ZW50cyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZVZlcmlmaWNhdGlvbkVycm9yKCdGYWlsZWQgdG8gb2J0YWluIHNpZ25hdHVyZSBmb3IgZmlsZTogJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBgJHtwYXRofSAtLSBsb29rZWQgaW4gJHtwYXRofSR7U0lHTkFUVVJFX0ZJTEVfU1VGRklYfWApXG4gICAgICB9XG4gICAgICBsZXQgc2lnbmF0dXJlXG4gICAgICBsZXQgcHVibGljS2V5XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBzaWdPYmplY3QgPSBKU09OLnBhcnNlKHNpZ25hdHVyZUNvbnRlbnRzKVxuICAgICAgICBzaWduYXR1cmUgPSBzaWdPYmplY3Quc2lnbmF0dXJlXG4gICAgICAgIHB1YmxpY0tleSA9IHNpZ09iamVjdC5wdWJsaWNLZXlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgU3ludGF4RXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBzaWduYXR1cmUgY29udGVudCBKU09OICdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKyBgKHBhdGg6ICR7cGF0aH0ke1NJR05BVFVSRV9GSUxFX1NVRkZJWH0pYFxuICAgICAgICAgICAgICAgICAgICAgICAgICArICcgVGhlIGNvbnRlbnQgbWF5IGJlIGNvcnJ1cHRlZC4nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVyclxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzaWduZXJBZGRyZXNzID0gcHVibGljS2V5VG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICAgIGlmIChnYWlhQWRkcmVzcyAhPT0gc2lnbmVyQWRkcmVzcykge1xuICAgICAgICB0aHJvdyBuZXcgU2lnbmF0dXJlVmVyaWZpY2F0aW9uRXJyb3IoYFNpZ25lciBwdWJrZXkgYWRkcmVzcyAoJHtzaWduZXJBZGRyZXNzfSkgZG9lc24ndGBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYCBtYXRjaCBnYWlhIGFkZHJlc3MgKCR7Z2FpYUFkZHJlc3N9KWApXG4gICAgICB9IGVsc2UgaWYgKCF2ZXJpZnlFQ0RTQShCdWZmZXIuZnJvbShmaWxlQ29udGVudHMpLCBwdWJsaWNLZXksIHNpZ25hdHVyZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZVZlcmlmaWNhdGlvbkVycm9yKFxuICAgICAgICAgICdDb250ZW50cyBkbyBub3QgbWF0Y2ggRUNEU0Egc2lnbmF0dXJlOiAnXG4gICAgICAgICAgICArIGBwYXRoOiAke3BhdGh9LCBzaWduYXR1cmU6ICR7cGF0aH0ke1NJR05BVFVSRV9GSUxFX1NVRkZJWH1gXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmaWxlQ29udGVudHNcbiAgICAgIH1cbiAgICB9KVxufVxuXG5cbi8qIEhhbmRsZSBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGFuZCBkZWNyeXB0aW9uIGZvciBjb250ZW50cyB3aGljaCBhcmVcbiAqICBleHBlY3RlZCB0byBiZSBzaWduZWQgYW5kIGVuY3J5cHRlZC4gVGhpcyB3b3JrcyBmb3Igc2luZ2xlIGFuZFxuICogIG11bHRpcGxheWVyIHJlYWRzLiBJbiB0aGUgY2FzZSBvZiBtdWx0aXBsYXllciByZWFkcywgaXQgdXNlcyB0aGVcbiAqICBnYWlhIGFkZHJlc3MgZm9yIHZlcmlmaWNhdGlvbiBvZiB0aGUgY2xhaW1lZCBwdWJsaWMga2V5LlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlU2lnbmVkRW5jcnlwdGVkQ29udGVudHMoY2FsbGVyOiBVc2VyU2Vzc2lvbiwgcGF0aDogc3RyaW5nLCBzdG9yZWRDb250ZW50czogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwOiBzdHJpbmcsIHVzZXJuYW1lOiA/c3RyaW5nLCB6b25lRmlsZUxvb2t1cFVSTDogP3N0cmluZykge1xuICBjb25zdCBhcHBQcml2YXRlS2V5ID0gY2FsbGVyLmxvYWRVc2VyRGF0YSgpLmFwcFByaXZhdGVLZXlcbiAgY29uc3QgYXBwUHVibGljS2V5ID0gZ2V0UHVibGljS2V5RnJvbVByaXZhdGUoYXBwUHJpdmF0ZUtleSlcblxuICBsZXQgYWRkcmVzc1Byb21pc2VcbiAgaWYgKHVzZXJuYW1lKSB7XG4gICAgYWRkcmVzc1Byb21pc2UgPSBnZXRHYWlhQWRkcmVzcyhjYWxsZXIsIGFwcCwgdXNlcm5hbWUsIHpvbmVGaWxlTG9va3VwVVJMKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBwdWJsaWNLZXlUb0FkZHJlc3MoYXBwUHVibGljS2V5KVxuICAgIGFkZHJlc3NQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFkZHJlc3MpXG4gIH1cblxuICByZXR1cm4gYWRkcmVzc1Byb21pc2UudGhlbigoYWRkcmVzcykgPT4ge1xuICAgIGlmICghYWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZVZlcmlmaWNhdGlvbkVycm9yKCdGYWlsZWQgdG8gZ2V0IGdhaWEgYWRkcmVzcyBmb3IgdmVyaWZpY2F0aW9uIG9mOiAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBgJHtwYXRofWApXG4gICAgfVxuICAgIGxldCBzaWdPYmplY3RcbiAgICB0cnkge1xuICAgICAgc2lnT2JqZWN0ID0gSlNPTi5wYXJzZShzdG9yZWRDb250ZW50cylcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBlbmNyeXB0ZWQsIHNpZ25lZCBjb250ZW50IEpTT04uIFRoZSBjb250ZW50IG1heSBub3QgJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnYmUgZW5jcnlwdGVkLiBJZiB1c2luZyBnZXRGaWxlLCB0cnkgcGFzc2luZydcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJyB7IHZlcmlmeTogZmFsc2UsIGRlY3J5cHQ6IGZhbHNlIH0uJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWduYXR1cmUgPSBzaWdPYmplY3Quc2lnbmF0dXJlXG4gICAgY29uc3Qgc2lnbmVyUHVibGljS2V5ID0gc2lnT2JqZWN0LnB1YmxpY0tleVxuICAgIGNvbnN0IGNpcGhlclRleHQgPSBzaWdPYmplY3QuY2lwaGVyVGV4dFxuICAgIGNvbnN0IHNpZ25lckFkZHJlc3MgPSBwdWJsaWNLZXlUb0FkZHJlc3Moc2lnbmVyUHVibGljS2V5KVxuXG4gICAgaWYgKCFzaWduZXJQdWJsaWNLZXkgfHwgIWNpcGhlclRleHQgfHwgIXNpZ25hdHVyZSkge1xuICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZVZlcmlmaWNhdGlvbkVycm9yKFxuICAgICAgICAnRmFpbGVkIHRvIGdldCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uIGRhdGEgZnJvbSBmaWxlOidcbiAgICAgICAgICArIGAgJHtwYXRofWBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKHNpZ25lckFkZHJlc3MgIT09IGFkZHJlc3MpIHtcbiAgICAgIHRocm93IG5ldyBTaWduYXR1cmVWZXJpZmljYXRpb25FcnJvcihgU2lnbmVyIHB1YmtleSBhZGRyZXNzICgke3NpZ25lckFkZHJlc3N9KSBkb2Vzbid0YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYCBtYXRjaCBnYWlhIGFkZHJlc3MgKCR7YWRkcmVzc30pYClcbiAgICB9IGVsc2UgaWYgKCF2ZXJpZnlFQ0RTQShjaXBoZXJUZXh0LCBzaWduZXJQdWJsaWNLZXksIHNpZ25hdHVyZSkpIHtcbiAgICAgIHRocm93IG5ldyBTaWduYXR1cmVWZXJpZmljYXRpb25FcnJvcignQ29udGVudHMgZG8gbm90IG1hdGNoIEVDRFNBIHNpZ25hdHVyZSBpbiBmaWxlOidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGAgJHtwYXRofWApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYWxsZXIuZGVjcnlwdENvbnRlbnQoY2lwaGVyVGV4dClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBzcGVjaWZpZWQgZmlsZSBmcm9tIHRoZSBhcHAncyBkYXRhIHN0b3JlLlxuICogQHBhcmFtIHtVc2VyU2Vzc2lvbn0gY2FsbGVyIC0gaW5zdGFuY2UgY2FsbGluZyB0aGlzIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSB0aGUgcGF0aCB0byB0aGUgZmlsZSB0byByZWFkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9bnVsbF0gLSBvcHRpb25zIG9iamVjdFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5kZWNyeXB0PXRydWVdIC0gdHJ5IHRvIGRlY3J5cHQgdGhlIGRhdGEgd2l0aCB0aGUgYXBwIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy51c2VybmFtZSAtIHRoZSBCbG9ja3N0YWNrIElEIHRvIGxvb2t1cCBmb3IgbXVsdGktcGxheWVyIHN0b3JhZ2VcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy52ZXJpZnkgLSBXaGV0aGVyIHRoZSBjb250ZW50IHNob3VsZCBiZSB2ZXJpZmllZCwgb25seSB0byBiZSB1c2VkXG4gKiB3aGVuIGBwdXRGaWxlYCB3YXMgc2V0IHRvIGBzaWduID0gdHJ1ZWBcbiAqIEBwYXJhbSB7U3RyaW5nfSBvcHRpb25zLmFwcCAtIHRoZSBhcHAgdG8gbG9va3VwIGZvciBtdWx0aS1wbGF5ZXIgc3RvcmFnZSAtXG4gKiBkZWZhdWx0cyB0byBjdXJyZW50IG9yaWdpblxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnpvbmVGaWxlTG9va3VwVVJMPW51bGxdIC0gVGhlIFVSTFxuICogdG8gdXNlIGZvciB6b25lZmlsZSBsb29rdXAuIElmIGZhbHNleSwgdGhpcyB3aWxsIHVzZSB0aGVcbiAqIGJsb2Nrc3RhY2suanMncyBnZXROYW1lSW5mbyBmdW5jdGlvbiBpbnN0ZWFkLlxuICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJhdyBkYXRhIGluIHRoZSBmaWxlXG4gKiBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlSW1wbChjYWxsZXI6IFVzZXJTZXNzaW9uLCBwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7XG4gICAgZGVjcnlwdD86IGJvb2xlYW4sXG4gICAgdmVyaWZ5PzogYm9vbGVhbixcbiAgICB1c2VybmFtZT86IHN0cmluZyxcbiAgICBhcHA/OiBzdHJpbmcsXG4gICAgem9uZUZpbGVMb29rdXBVUkw/OiA/c3RyaW5nXG4gIH0pIHtcbiAgY29uc3QgYXBwQ29uZmlnID0gY2FsbGVyLmFwcENvbmZpZ1xuICBpZiAoIWFwcENvbmZpZykge1xuICAgIHRocm93IG5ldyBJbnZhbGlkU3RhdGVFcnJvcignTWlzc2luZyBBcHBDb25maWcnKVxuICB9XG4gIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgIGRlY3J5cHQ6IHRydWUsXG4gICAgdmVyaWZ5OiBmYWxzZSxcbiAgICB1c2VybmFtZTogbnVsbCxcbiAgICBhcHA6IGFwcENvbmZpZy5hcHBEb21haW4sXG4gICAgem9uZUZpbGVMb29rdXBVUkw6IG51bGxcbiAgfVxuXG4gIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKVxuXG4gIC8vIGluIHRoZSBjYXNlIG9mIHNpZ25hdHVyZSB2ZXJpZmljYXRpb24sIGJ1dCBub1xuICAvLyAgZW5jcnlwdGlvbiBleHBlY3RlZCwgbmVlZCB0byBmZXRjaCBfdHdvXyBmaWxlcy5cbiAgaWYgKG9wdC52ZXJpZnkgJiYgIW9wdC5kZWNyeXB0KSB7XG4gICAgcmV0dXJuIGdldEZpbGVTaWduZWRVbmVuY3J5cHRlZChjYWxsZXIsIHBhdGgsIG9wdClcbiAgfVxuXG4gIHJldHVybiBnZXRGaWxlQ29udGVudHMoY2FsbGVyLCBwYXRoLCBvcHQuYXBwLCBvcHQudXNlcm5hbWUsIG9wdC56b25lRmlsZUxvb2t1cFVSTCwgISFvcHQuZGVjcnlwdClcbiAgICAudGhlbigoc3RvcmVkQ29udGVudHMpID0+IHtcbiAgICAgIGlmIChzdG9yZWRDb250ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gc3RvcmVkQ29udGVudHNcbiAgICAgIH0gZWxzZSBpZiAob3B0LmRlY3J5cHQgJiYgIW9wdC52ZXJpZnkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRDb250ZW50cyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGdldCBiYWNrIGEgc3RyaW5nIGZvciB0aGUgY2lwaGVyVGV4dCcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlY3J5cHRDb250ZW50SW1wbChjYWxsZXIsIHN0b3JlZENvbnRlbnRzKVxuICAgICAgfSBlbHNlIGlmIChvcHQuZGVjcnlwdCAmJiBvcHQudmVyaWZ5KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkQ29udGVudHMgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBnZXQgYmFjayBhIHN0cmluZyBmb3IgdGhlIGNpcGhlclRleHQnKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVTaWduZWRFbmNyeXB0ZWRDb250ZW50cyhjYWxsZXIsIHBhdGgsIHN0b3JlZENvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0LmFwcCwgb3B0LnVzZXJuYW1lLCBvcHQuem9uZUZpbGVMb29rdXBVUkwpXG4gICAgICB9IGVsc2UgaWYgKCFvcHQudmVyaWZ5ICYmICFvcHQuZGVjcnlwdCkge1xuICAgICAgICByZXR1cm4gc3RvcmVkQ29udGVudHNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIGJlIHVucmVhY2hhYmxlLicpXG4gICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBTdG9yZXMgdGhlIGRhdGEgcHJvdmlkZWQgaW4gdGhlIGFwcCdzIGRhdGEgc3RvcmUgdG8gdG8gdGhlIGZpbGUgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtVc2VyU2Vzc2lvbn0gY2FsbGVyIC0gaW5zdGFuY2UgY2FsbGluZyB0aGlzIG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSB0aGUgcGF0aCB0byBzdG9yZSB0aGUgZGF0YSBpblxuICogQHBhcmFtIHtTdHJpbmd8QnVmZmVyfSBjb250ZW50IC0gdGhlIGRhdGEgdG8gc3RvcmUgaW4gdGhlIGZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz1udWxsXSAtIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge0Jvb2xlYW58U3RyaW5nfSBbb3B0aW9ucy5lbmNyeXB0PXRydWVdIC0gZW5jcnlwdCB0aGUgZGF0YSB3aXRoIHRoZSBhcHAgcHVibGljIGtleVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yIHRoZSBwcm92aWRlZCBwdWJsaWMga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNpZ249ZmFsc2VdIC0gc2lnbiB0aGUgZGF0YSB1c2luZyBFQ0RTQSBvbiBTSEEyNTYgaGFzaGVzIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgYXBwIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY29udGVudFR5cGU9JyddIC0gc2V0IGEgQ29udGVudC1UeXBlIGhlYWRlciBmb3IgdW5lbmNyeXB0ZWQgZGF0YVxuICogQHJldHVybiB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyBpZiB0aGUgb3BlcmF0aW9uIHN1Y2NlZWQgYW5kIHJlamVjdHNcbiAqIGlmIGl0IGZhaWxlZFxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHB1dEZpbGVJbXBsKGNhbGxlcjogVXNlclNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHN0cmluZyB8IEJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zPzogUHV0RmlsZU9wdGlvbnMpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgZW5jcnlwdDogdHJ1ZSxcbiAgICBzaWduOiBmYWxzZSxcbiAgICBjb250ZW50VHlwZTogJydcbiAgfVxuXG4gIGNvbnN0IG9wdCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKVxuXG4gIGxldCB7IGNvbnRlbnRUeXBlIH0gPSBvcHRcbiAgaWYgKCFjb250ZW50VHlwZSkge1xuICAgIGNvbnRlbnRUeXBlID0gKHR5cGVvZiAoY29udGVudCkgPT09ICdzdHJpbmcnKSA/ICd0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04JyA6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gIH1cblxuICAvLyBGaXJzdCwgbGV0J3MgZmlndXJlIG91dCBpZiB3ZSBuZWVkIHRvIGdldCBwdWJsaWMvcHJpdmF0ZSBrZXlzLFxuICAvLyAgb3IgaWYgdGhleSB3ZXJlIHBhc3NlZCBpblxuXG4gIGxldCBwcml2YXRlS2V5ID0gJydcbiAgbGV0IHB1YmxpY0tleSA9ICcnXG4gIGlmIChvcHQuc2lnbikge1xuICAgIGlmICh0eXBlb2YgKG9wdC5zaWduKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHByaXZhdGVLZXkgPSBvcHQuc2lnblxuICAgIH0gZWxzZSB7XG4gICAgICBwcml2YXRlS2V5ID0gY2FsbGVyLmxvYWRVc2VyRGF0YSgpLmFwcFByaXZhdGVLZXlcbiAgICB9XG4gIH1cbiAgaWYgKG9wdC5lbmNyeXB0KSB7XG4gICAgaWYgKHR5cGVvZiAob3B0LmVuY3J5cHQpID09PSAnc3RyaW5nJykge1xuICAgICAgcHVibGljS2V5ID0gb3B0LmVuY3J5cHRcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFwcml2YXRlS2V5KSB7XG4gICAgICAgIHByaXZhdGVLZXkgPSBjYWxsZXIubG9hZFVzZXJEYXRhKCkuYXBwUHJpdmF0ZUtleVxuICAgICAgfVxuICAgICAgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5RnJvbVByaXZhdGUocHJpdmF0ZUtleSlcbiAgICB9XG4gIH1cblxuICAvLyBJbiB0aGUgY2FzZSBvZiBzaWduaW5nLCBidXQgKm5vdCogZW5jcnlwdGluZyxcbiAgLy8gICB3ZSBwZXJmb3JtIHR3byB1cGxvYWRzLiBTbyB0aGUgY29udHJvbC1mbG93XG4gIC8vICAgaGVyZSB3aWxsIHJldHVybiB0aGVyZS5cbiAgaWYgKCFvcHQuZW5jcnlwdCAmJiBvcHQuc2lnbikge1xuICAgIGNvbnN0IHNpZ25hdHVyZU9iamVjdCA9IHNpZ25FQ0RTQShwcml2YXRlS2V5LCBjb250ZW50KVxuICAgIGNvbnN0IHNpZ25hdHVyZUNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzaWduYXR1cmVPYmplY3QpXG4gICAgcmV0dXJuIGdldE9yU2V0TG9jYWxHYWlhSHViQ29ubmVjdGlvbihjYWxsZXIpXG4gICAgICAudGhlbihnYWlhSHViQ29uZmlnID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgdXBsb2FkVG9HYWlhSHViKHBhdGgsIGNvbnRlbnQsIGdhaWFIdWJDb25maWcsIGNvbnRlbnRUeXBlKSxcbiAgICAgICAgdXBsb2FkVG9HYWlhSHViKGAke3BhdGh9JHtTSUdOQVRVUkVfRklMRV9TVUZGSVh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZUNvbnRlbnQsIGdhaWFIdWJDb25maWcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgIF0pXG4gICAgICAgIC50aGVuKHJlc29sdmUpXG4gICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgc2V0TG9jYWxHYWlhSHViQ29ubmVjdGlvbihjYWxsZXIpXG4gICAgICAgICAgICAudGhlbihmcmVzaEh1YkNvbmZpZyA9PiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgIHVwbG9hZFRvR2FpYUh1YihwYXRoLCBjb250ZW50LCBmcmVzaEh1YkNvbmZpZywgY29udGVudFR5cGUpLFxuICAgICAgICAgICAgICB1cGxvYWRUb0dhaWFIdWIoYCR7cGF0aH0ke1NJR05BVFVSRV9GSUxFX1NVRkZJWH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlQ29udGVudCwgZnJlc2hIdWJDb25maWcsICdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCkpXG4gICAgICAgIH0pKSlcbiAgICAgIC50aGVuKGZpbGVVcmxzID0+IGZpbGVVcmxzWzBdKVxuICB9XG5cbiAgLy8gSW4gYWxsIG90aGVyIGNhc2VzLCB3ZSBvbmx5IG5lZWQgb25lIHVwbG9hZC5cbiAgaWYgKG9wdC5lbmNyeXB0ICYmICFvcHQuc2lnbikge1xuICAgIGNvbnRlbnQgPSBlbmNyeXB0Q29udGVudEltcGwoY2FsbGVyLCBjb250ZW50LCB7IHB1YmxpY0tleSB9KVxuICAgIGNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH0gZWxzZSBpZiAob3B0LmVuY3J5cHQgJiYgb3B0LnNpZ24pIHtcbiAgICBjb25zdCBjaXBoZXJUZXh0ID0gZW5jcnlwdENvbnRlbnRJbXBsKGNhbGxlciwgY29udGVudCwgeyBwdWJsaWNLZXkgfSlcbiAgICBjb25zdCBzaWduYXR1cmVPYmplY3QgPSBzaWduRUNEU0EocHJpdmF0ZUtleSwgY2lwaGVyVGV4dClcbiAgICBjb25zdCBzaWduZWRDaXBoZXJPYmplY3QgPSB7XG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZU9iamVjdC5zaWduYXR1cmUsXG4gICAgICBwdWJsaWNLZXk6IHNpZ25hdHVyZU9iamVjdC5wdWJsaWNLZXksXG4gICAgICBjaXBoZXJUZXh0XG4gICAgfVxuICAgIGNvbnRlbnQgPSBKU09OLnN0cmluZ2lmeShzaWduZWRDaXBoZXJPYmplY3QpXG4gICAgY29udGVudFR5cGUgPSAnYXBwbGljYXRpb24vanNvbidcbiAgfVxuICByZXR1cm4gZ2V0T3JTZXRMb2NhbEdhaWFIdWJDb25uZWN0aW9uKGNhbGxlcilcbiAgICAudGhlbihnYWlhSHViQ29uZmlnID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHVwbG9hZFRvR2FpYUh1YihwYXRoLCBjb250ZW50LCBnYWlhSHViQ29uZmlnLCBjb250ZW50VHlwZSlcbiAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICBzZXRMb2NhbEdhaWFIdWJDb25uZWN0aW9uKGNhbGxlcilcbiAgICAgICAgICAgIC50aGVuKGZyZXNoSHViQ29uZmlnID0+IHVwbG9hZFRvR2FpYUh1YihwYXRoLCBjb250ZW50LCBmcmVzaEh1YkNvbmZpZywgY29udGVudFR5cGUpXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmUpLmNhdGNoKHJlamVjdCkpXG4gICAgICAgIH0pXG4gICAgfSkpXG59XG5cbi8qKlxuICogR2V0IHRoZSBhcHAgc3RvcmFnZSBidWNrZXQgVVJMXG4gKiBAcGFyYW0ge1N0cmluZ30gZ2FpYUh1YlVybCAtIHRoZSBnYWlhIGh1YiBVUkxcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcHBQcml2YXRlS2V5IC0gdGhlIGFwcCBwcml2YXRlIGtleSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBhcHAgYWRkcmVzc1xuICogQHJldHVybnMge1Byb21pc2V9IFRoYXQgcmVzb2x2ZXMgdG8gdGhlIFVSTCBvZiB0aGUgYXBwIGluZGV4IGZpbGVcbiAqIG9yIHJlamVjdHMgaWYgaXQgZmFpbHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEFwcEJ1Y2tldFVybChnYWlhSHViVXJsOiBzdHJpbmcsIGFwcFByaXZhdGVLZXk6IHN0cmluZykge1xuICByZXR1cm4gZ2V0QnVja2V0VXJsKGdhaWFIdWJVcmwsIGFwcFByaXZhdGVLZXkpXG59XG5cbi8qKlxuICogTG9vcCBvdmVyIHRoZSBsaXN0IG9mIGZpbGVzIGluIGEgR2FpYSBodWIsIGFuZCBydW4gYSBjYWxsYmFjayBvbiBlYWNoIGVudHJ5LlxuICogTm90IG1lYW50IHRvIGJlIGNhbGxlZCBieSBleHRlcm5hbCBjbGllbnRzLlxuICogQHBhcmFtIHtHYWlhSHViQ29uZmlnfSBodWJDb25maWcgLSB0aGUgR2FpYSBodWIgY29uZmlnXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bGx9IHBhZ2UgLSB0aGUgcGFnZSBJRFxuICogQHBhcmFtIHtudW1iZXJ9IGNhbGxDb3VudCAtIHRoZSBsb29wIGNvdW50XG4gKiBAcGFyYW0ge251bWJlcn0gZmlsZUNvdW50IC0gdGhlIG51bWJlciBvZiBmaWxlcyBsaXN0ZWQgc28gZmFyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIHRoZSBjYWxsYmFjayB0byBpbnZva2Ugb24gZWFjaCBmaWxlLiAgSWYgaXQgcmV0dXJucyBhIGZhbHNleVxuICogIHZhbHVlLCB0aGVuIHRoZSBsb29wIHN0b3BzLiAgSWYgaXQgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSwgdGhlIGxvb3AgY29udGludWVzLlxuICogQHJldHVybnMge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBmaWxlcyBsaXN0ZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsaXN0RmlsZXNMb29wKGh1YkNvbmZpZzogR2FpYUh1YkNvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgcGFnZTogc3RyaW5nIHwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvdW50OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgIGZpbGVDb3VudDogbnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKG5hbWU6IHN0cmluZykgPT4gYm9vbGVhbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICBpZiAoY2FsbENvdW50ID4gNjU1MzYpIHtcbiAgICAvLyB0aGlzIGlzIHJpZGljdWxvdXNseSBodWdlLCBhbmQgcHJvYmFibHkgaW5kaWNhdGVzXG4gICAgLy8gYSBmYXVsdHkgR2FpYSBodWIgYW55d2F5IChlLmcuIG9uIHRoYXQgc2VydmVzIGVuZGxlc3MgZGF0YSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IGVudHJpZXMgdG8gbGlzdCcpXG4gIH1cblxuICBsZXQgaHR0cFN0YXR1c1xuICBjb25zdCBwYWdlUmVxdWVzdCA9IEpTT04uc3RyaW5naWZ5KHsgcGFnZSB9KVxuXG4gIGNvbnN0IGZldGNoT3B0aW9ucyA9IHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBoZWFkZXJzOiB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogYCR7cGFnZVJlcXVlc3QubGVuZ3RofWAsXG4gICAgICBBdXRob3JpemF0aW9uOiBgYmVhcmVyICR7aHViQ29uZmlnLnRva2VufWBcbiAgICB9LFxuICAgIGJvZHk6IHBhZ2VSZXF1ZXN0XG4gIH1cblxuICByZXR1cm4gZmV0Y2goYCR7aHViQ29uZmlnLnNlcnZlcn0vbGlzdC1maWxlcy8ke2h1YkNvbmZpZy5hZGRyZXNzfWAsIGZldGNoT3B0aW9ucylcbiAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgIGh0dHBTdGF0dXMgPSByZXNwb25zZS5zdGF0dXNcbiAgICAgIGlmIChodHRwU3RhdHVzID49IDQwMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGxpc3RGaWxlcyBmYWlsZWQgd2l0aCBIVFRQIHN0YXR1cyAke2h0dHBTdGF0dXN9YClcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KClcbiAgICB9KVxuICAgIC50aGVuKHJlc3BvbnNlVGV4dCA9PiBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCkpXG4gICAgLnRoZW4oKHJlc3BvbnNlSlNPTikgPT4ge1xuICAgICAgY29uc3QgZW50cmllcyA9IHJlc3BvbnNlSlNPTi5lbnRyaWVzXG4gICAgICBjb25zdCBuZXh0UGFnZSA9IHJlc3BvbnNlSlNPTi5wYWdlXG4gICAgICBpZiAoZW50cmllcyA9PT0gbnVsbCB8fCBlbnRyaWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gaW5kaWNhdGVzIGEgbWlzYmVoYXZpbmcgR2FpYSBodWIgb3IgYSBtaXNiZWhhdmluZyBkcml2ZXJcbiAgICAgICAgLy8gKGkuZS4gdGhlIGRhdGEgaXMgbWFsZm9ybWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBsaXN0RmlsZXMgcmVzcG9uc2U6IG5vIGVudHJpZXMnKVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJjID0gY2FsbGJhY2soZW50cmllc1tpXSlcbiAgICAgICAgaWYgKCFyYykge1xuICAgICAgICAgIC8vIGNhbGxiYWNrIGluZGljYXRlcyB0aGF0IHdlJ3JlIGRvbmVcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZpbGVDb3VudCArIGkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChuZXh0UGFnZSAmJiBlbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8ga2VlcCBnb2luZyAtLSBoYXZlIG1vcmUgZW50cmllc1xuICAgICAgICByZXR1cm4gbGlzdEZpbGVzTG9vcChcbiAgICAgICAgICBodWJDb25maWcsIG5leHRQYWdlLCBjYWxsQ291bnQgKyAxLCBmaWxlQ291bnQgKyBlbnRyaWVzLmxlbmd0aCwgY2FsbGJhY2tcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbW9yZSBlbnRyaWVzIC0tIGVuZCBvZiBkYXRhXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmlsZUNvdW50ICsgZW50cmllcy5sZW5ndGgpXG4gICAgICB9XG4gICAgfSlcbn1cblxuLyoqXG4gKiBMaXN0IHRoZSBzZXQgb2YgZmlsZXMgaW4gdGhpcyBhcHBsaWNhdGlvbidzIEdhaWEgc3RvcmFnZSBidWNrZXQuXG4gKiBAcGFyYW0ge1VzZXJTZXNzaW9ufSBjYWxsZXIgLSBpbnN0YW5jZSBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIGEgY2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggbmFtZWQgZmlsZSB0aGF0XG4gKiByZXR1cm5zIGB0cnVlYCB0byBjb250aW51ZSB0aGUgbGlzdGluZyBvcGVyYXRpb24gb3IgYGZhbHNlYCB0byBlbmQgaXRcbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIG51bWJlciBvZiBmaWxlcyBsaXN0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaXN0RmlsZXNJbXBsKGNhbGxlcjogVXNlclNlc3Npb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogKG5hbWU6IHN0cmluZykgPT4gYm9vbGVhbikgOiBQcm9taXNlPG51bWJlcj4ge1xuICByZXR1cm4gZ2V0T3JTZXRMb2NhbEdhaWFIdWJDb25uZWN0aW9uKGNhbGxlcilcbiAgICAudGhlbihnYWlhSHViQ29uZmlnID0+IGxpc3RGaWxlc0xvb3AoZ2FpYUh1YkNvbmZpZywgbnVsbCwgMCwgMCwgY2FsbGJhY2spKVxufVxuXG5leHBvcnQgeyBjb25uZWN0VG9HYWlhSHViLCB1cGxvYWRUb0dhaWFIdWIsIEJMT0NLU1RBQ0tfR0FJQV9IVUJfTEFCRUwgfVxuIl19