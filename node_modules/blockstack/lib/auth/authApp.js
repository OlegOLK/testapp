"use strict";

exports.__esModule = true;
exports.isUserSignedIn = isUserSignedIn;
exports.isSignInPending = isSignInPending;
exports.handlePendingSignIn = handlePendingSignIn;
exports.loadUserData = loadUserData;
exports.signUserOut = signUserOut;
exports.makeAuthRequest = makeAuthRequest;
exports.redirectToSignInWithAuthRequestImpl = redirectToSignInWithAuthRequestImpl;
exports.redirectToSignIn = redirectToSignIn;
exports.redirectToSignInImpl = redirectToSignInImpl;
exports.handlePendingSignInImpl = handlePendingSignInImpl;
exports.loadUserDataImpl = loadUserDataImpl;
exports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;

var _queryString = _interopRequireDefault(require("query-string"));

var _jsontokens = require("jsontokens");

var _index = require("./index");

var _utils = require("../utils");

var _index2 = require("../index");

var _errors = require("../errors");

var _authMessages = require("./authMessages");

var _authConstants = require("./authConstants");

var _profiles = require("../profiles");

var _userSession = require("./userSession");

var _config = require("../config");

var _logger = require("../logger");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_PROFILE = {
  '@type': 'Person',
  '@context': 'http://schema.org'
  /**
   * Check if a user is currently signed in.
   * @method isUserSignedIn
   * @return {Boolean} `true` if the user is signed in, `false` if not.
   */

};

function isUserSignedIn() {
  console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isUserSignedIn().');
  const userSession = new _userSession.UserSession();
  return userSession.isUserSignedIn();
}
/**
 * Check if there is a authentication request that hasn't been handled.
 * @return {Boolean} `true` if there is a pending sign in, otherwise `false`
 */


function isSignInPending() {
  console.warn('DEPRECATION WARNING: The static isSignInPending() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isSignInPending().');
  const userSession = new _userSession.UserSession();
  return userSession.isSignInPending();
}
/**
 * Try to process any pending sign in request by returning a `Promise` that resolves
 * to the user data object if the sign in succeeds.
 *
 * @param {String} nameLookupURL - the endpoint against which to verify public
 * keys match claimed username
 * @param {String} authResponseToken - the signed authentication response token
 * @param {String} transitKey - the transit private key that corresponds to the transit public key
 * that was provided in the authentication request
 * @return {Promise} that resolves to the user data object if successful and rejects
 * if handling the sign in request fails or there was no pending sign in request.
 */

/* eslint-disable no-unused-vars, no-use-before-define */


function handlePendingSignIn(nameLookupURL = '', authResponseToken = getAuthResponseToken(), transitKey = '') {
  console.warn('DEPRECATION WARNING: The static handlePendingSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method handlePendingSignIn().');
  console.warn('DEPRECATION WARNING: handlePendingSignIn() no long supports setting of nameLookupURL and ' + 'transitKey. The nameLookupURL and transitKey now defaults to values in the default user session.');
  const userSession = new _userSession.UserSession();
  return userSession.handlePendingSignIn(authResponseToken);
}
/* eslint-enable no-unused-vars */

/**
 * Retrieve the authentication token from the URL query
 * @return {String} the authentication token if it exists otherwise `null`
 */


function getAuthResponseToken() {
  const queryDict = _queryString.default.parse(location.search);

  return queryDict.authResponse ? queryDict.authResponse : '';
}
/**
 * Retrieves the user data object. The user's profile is stored in the key `profile`.
 * @return {Object} User data object.
 */


function loadUserData() {
  console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method loadUserData().');
  const userSession = new _userSession.UserSession();
  return userSession.loadUserData();
}
/**
 * Sign the user out and optionally redirect to given location.
 * @param  {String} [redirectURL=null] Location to redirect user to after sign out.
 * @return {void}
 */


function signUserOut(redirectURL = null) {
  // eslint-disable-line no-unused-vars
  console.warn('DEPRECATION WARNING: The static signUserOut() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method signUserOut().');
  const userSession = new _userSession.UserSession();
  userSession.signUserOut();
  window.location = redirectURL;
}
/**
 * Generates an authentication request that can be sent to the Blockstack
 * browser for the user to approve sign in. This authentication request can
 * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`
 * method.
 *
 * *Note: This method should only be used if you want to roll your own authentication
 * flow. Typically you'd use `redirectToSignIn` which takes care of this
 * under the hood.*
 *
 * @param  {String} transitPrivateKey - hex encoded transit private key
 * @param {String} redirectURI - location to redirect user to after sign in approval
 * @param {String} manifestURI - location of this app's manifest file
 * @param {Array<String>} scopes - the permissions this app is requesting
 * @param {String} appDomain - the origin of this app
 * @param {Number} expiresAt - the time at which this request is no longer valid
 * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.
 * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported
 * by special authenticators.
 * @return {String} the authentication request
 */


function makeAuthRequest(transitPrivateKey, redirectURI = `${window.location.origin}/`, manifestURI = `${window.location.origin}/manifest.json`, scopes = _authConstants.DEFAULT_SCOPE, appDomain = window.location.origin, expiresAt = (0, _utils.nextMonth)().getTime(), extraParams = {}) {
  console.warn('DEPRECATION WARNING: The makeAuthRequest() function will be deprecated in the ' + 'next major release of blockstack.js. Use UserSession to configure your auth request.');
  const userSession = new _userSession.UserSession();
  const transitKey = transitPrivateKey == null ? userSession.generateAndStoreTransitKey() : transitPrivateKey;
  return (0, _authMessages.makeAuthRequestImpl)(transitKey, redirectURI, manifestURI, scopes, appDomain, expiresAt, extraParams);
}
/**
 * Detects if the native auth-browser is installed and is successfully 
 * launched via a custom protocol URI. 
 * @param {String} authRequest
 * The encoded authRequest to be used as a query param in the custom URI. 
 * @param {String} successCallback
 * The callback that is invoked when the protocol handler was detected. 
 * @param {String} failCallback
 * The callback that is invoked when the protocol handler was not detected. 
 * @return {void}
 */


function detectProtocolLaunch(authRequest, successCallback, failCallback) {
  // Create a unique ID used for this protocol detection attempt.
  const echoReplyID = Math.random().toString(36).substr(2, 9);
  const echoReplyKeyPrefix = 'echo-reply-';
  const echoReplyKey = `${echoReplyKeyPrefix}${echoReplyID}`; // Use localStorage as a reliable cross-window communication method.
  // Create the storage entry to signal a protocol detection attempt for the
  // next browser window to check.

  window.localStorage.setItem(echoReplyKey, Date.now().toString());

  const cleanUpLocalStorage = () => {
    try {
      window.localStorage.removeItem(echoReplyKey); // Also clear out any stale echo-reply keys older than 1 hour.

      for (let i = 0; i < window.localStorage.length; i++) {
        const storageKey = window.localStorage.key(i);

        if (storageKey.startsWith(echoReplyKeyPrefix)) {
          const storageValue = window.localStorage.getItem(storageKey);

          if (storageValue === 'success' || Date.now() - parseInt(storageValue, 10) > 3600000) {
            window.localStorage.removeItem(storageKey);
          }
        }
      }
    } catch (err) {
      _logger.Logger.error('Exception cleaning up echo-reply entries in localStorage');

      _logger.Logger.error(err);
    }
  };

  const detectionTimeout = 1000;
  let redirectToWebAuthTimer = 0;

  const cancelWebAuthRedirectTimer = () => {
    if (redirectToWebAuthTimer) {
      window.clearTimeout(redirectToWebAuthTimer);
      redirectToWebAuthTimer = 0;
    }
  };

  const startWebAuthRedirectTimer = (timeout = detectionTimeout) => {
    cancelWebAuthRedirectTimer();
    redirectToWebAuthTimer = window.setTimeout(() => {
      if (redirectToWebAuthTimer) {
        cancelWebAuthRedirectTimer();
        let nextFunc;

        if (window.localStorage.getItem(echoReplyKey) === 'success') {
          _logger.Logger.info('Protocol echo reply detected.');

          nextFunc = successCallback;
        } else {
          _logger.Logger.info('Protocol handler not detected.');

          nextFunc = failCallback;
        }

        failCallback = () => {};

        successCallback = () => {};

        cleanUpLocalStorage(); // Briefly wait since localStorage changes can 
        // sometimes be ignored when immediately redirected.

        setTimeout(() => nextFunc(), 100);
      }
    }, timeout);
  };

  startWebAuthRedirectTimer();
  const inputPromptTracker = document.createElement('input');
  inputPromptTracker.type = 'text'; // Prevent this element from inherited any css.

  inputPromptTracker.style.all = 'initial'; // Setting display=none on an element prevents them from being focused/blurred.
  // So hide the element using other properties..

  inputPromptTracker.style.opacity = '0';
  inputPromptTracker.style.filter = 'alpha(opacity=0)';
  inputPromptTracker.style.height = '0';
  inputPromptTracker.style.width = '0'; // If the the focus of a page element is immediately changed then this likely indicates 
  // the protocol handler is installed, and the browser is prompting the user if they want 
  // to open the application. 

  const inputBlurredFunc = () => {
    // Use a timeout of 100ms to ignore instant toggles between blur and focus.
    // Browsers often perform an instant blur & focus when the protocol handler is working
    // but not showing any browser prompts, so we want to ignore those instances.
    let isRefocused = false;
    inputPromptTracker.addEventListener('focus', () => {
      isRefocused = true;
    }, {
      once: true,
      capture: true
    });
    setTimeout(() => {
      if (redirectToWebAuthTimer && !isRefocused) {
        _logger.Logger.info('Detected possible browser prompt for opening the protocol handler app.');

        window.clearTimeout(redirectToWebAuthTimer);
        inputPromptTracker.addEventListener('focus', () => {
          if (redirectToWebAuthTimer) {
            _logger.Logger.info('Possible browser prompt closed, restarting auth redirect timeout.');

            startWebAuthRedirectTimer();
          }
        }, {
          once: true,
          capture: true
        });
      }
    }, 100);
  };

  inputPromptTracker.addEventListener('blur', inputBlurredFunc, {
    once: true,
    capture: true
  });
  setTimeout(() => inputPromptTracker.removeEventListener('blur', inputBlurredFunc), 200); // Flow complains without this check.

  if (document.body) document.body.appendChild(inputPromptTracker);
  inputPromptTracker.focus(); // Detect if document.visibility is immediately changed which is a strong 
  // indication that the protocol handler is working. We don't know for sure and 
  // can't predict future browser changes, so only increase the redirect timeout.
  // This reduces the probability of a false-negative (where local auth works, but 
  // the original page was redirect to web auth because something took too long),

  const pageVisibilityChanged = () => {
    if (document.hidden && redirectToWebAuthTimer) {
      _logger.Logger.info('Detected immediate page visibility change (protocol handler probably working).');

      startWebAuthRedirectTimer(3000);
    }
  };

  document.addEventListener('visibilitychange', pageVisibilityChanged, {
    once: true,
    capture: true
  });
  setTimeout(() => document.removeEventListener('visibilitychange', pageVisibilityChanged), 500); // Listen for the custom protocol echo reply via localStorage update event.

  window.addEventListener('storage', function replyEventListener(event) {
    if (event.key === echoReplyKey && window.localStorage.getItem(echoReplyKey) === 'success') {
      // Custom protocol worked, cancel the web auth redirect timer.
      cancelWebAuthRedirectTimer();
      inputPromptTracker.removeEventListener('blur', inputBlurredFunc);

      _logger.Logger.info('Protocol echo reply detected from localStorage event.'); // Clean up event listener and localStorage.


      window.removeEventListener('storage', replyEventListener);
      const nextFunc = successCallback;

      successCallback = () => {};

      failCallback = () => {};

      cleanUpLocalStorage(); // Briefly wait since localStorage changes can sometimes 
      // be ignored when immediately redirected.

      setTimeout(() => nextFunc(), 100);
    }
  }, false); // Use iframe technique for launching the protocol URI rather than setting `window.location`.
  // This method prevents browsers like Safari, Opera, Firefox from showing error prompts
  // about unknown protocol handler when app is not installed, and avoids an empty
  // browser tab when the app is installed. 

  _logger.Logger.info('Attempting protocol launch via iframe injection.');

  const locationSrc = `${_utils.BLOCKSTACK_HANDLER}:${authRequest}&echo=${echoReplyID}`;
  const iframe = document.createElement('iframe');
  iframe.style.all = 'initial';
  iframe.style.display = 'none';
  iframe.src = locationSrc; // Flow complains without this check.

  if (document.body) {
    document.body.appendChild(iframe);
  } else {
    _logger.Logger.error('document.body is null when attempting iframe injection for protoocol URI launch');
  }
}
/**
 * Redirects the user to the Blockstack browser to approve the sign in request
 * given.
 *
 * The user is redirected to the `blockstackIDHost` if the `blockstack:`
 * protocol handler is not detected. Please note that the protocol handler detection
 * does not work on all browsers.
 * @param  {UserSession} caller - the instance calling this method
 * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
 * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack
 *                                     protocol handler is not detected
 * @return {void}
 * @private
 */


function redirectToSignInWithAuthRequestImpl(caller, authRequest) {
  let httpsURI = `${_authConstants.DEFAULT_BLOCKSTACK_HOST}?authRequest=${authRequest}`;

  if (caller.appConfig && caller.appConfig.authenticatorURL) {
    httpsURI = `${caller.appConfig.authenticatorURL}?authRequest=${authRequest}`;
  } // If they're on a mobile OS, always redirect them to HTTPS site


  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {
    _logger.Logger.info('detected mobile OS, sending to https');

    window.location = httpsURI;
    return;
  }

  function successCallback() {
    _logger.Logger.info('protocol handler detected'); // The detection function should open the link for us

  }

  function failCallback() {
    _logger.Logger.warn('protocol handler not detected');

    window.location = httpsURI;
  }

  detectProtocolLaunch(authRequest, successCallback, failCallback);
}
/**
 * Generates an authentication request and redirects the user to the Blockstack
 * browser to approve the sign in request.
 *
 * Please note that this requires that the web browser properly handles the
 * `blockstack:` URL protocol handler.
 *
 * Most applications should use this
 * method for sign in unless they require more fine grained control over how the
 * authentication request is generated. If your app falls into this category,
 * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.
 *
 * @param {String} [redirectURI=`${window.location.origin}/`]
 * The location to which the identity provider will redirect the user after
 * the user approves sign in.
 * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]
 * Location of the manifest file.
 * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to
 * this app's data store.
 * An array of strings indicating which permissions this app is requesting.
 * @return {void}
 */


function redirectToSignIn(redirectURI = `${window.location.origin}/`, manifestURI = `${window.location.origin}/manifest.json`, scopes = _authConstants.DEFAULT_SCOPE) {
  console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method redirectToSignIn().');
  const authRequest = makeAuthRequest(null, redirectURI, manifestURI, scopes);
  redirectToSignInWithAuthRequest(authRequest);
}
/**
 * Generates an authentication request and redirects the user to the Blockstack
 * browser to approve the sign in request.
 *
 * Please note that this requires that the web browser properly handles the
 * `blockstack:` URL protocol handler.
 *
 * Most web applications should use this
 * method for sign in unless they require more fine grained control over how the
 * authentication request is generated. If your app falls into this category,
 * use `makeAuthRequest`,
 * and `redirectToSignInWithAuthRequest` to build your own sign in process.
 * @param {UserSession} caller - the instance calling this function
 * @return {void}
 * @private
 */


function redirectToSignInImpl(caller) {
  const transitKey = caller.generateAndStoreTransitKey();
  const authRequest = caller.makeAuthRequest(transitKey);
  redirectToSignInWithAuthRequestImpl(caller, authRequest);
}
/**
 * Try to process any pending sign in request by returning a `Promise` that resolves
 * to the user data object if the sign in succeeds.
 *
 * @param {UserSession} caller - the instance calling this function
 * @param {String} authResponseToken - the signed authentication response token
 * @return {Promise} that resolves to the user data object if successful and rejects
 * if handling the sign in request fails or there was no pending sign in request.
 * @private
 */


function handlePendingSignInImpl(caller, authResponseToken) {
  const transitKey = caller.store.getSessionData().transitKey;
  const coreNodeSessionValue = caller.store.getSessionData().coreNode;
  let nameLookupURL = null;

  if (!coreNodeSessionValue) {
    const tokenPayload = (0, _jsontokens.decodeToken)(authResponseToken).payload;

    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.3.0') && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {
      // override globally
      _logger.Logger.info(`Overriding ${_config.config.network.blockstackAPIUrl} ` + `with ${tokenPayload.blockstackAPIUrl}`);

      _config.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;
    }

    nameLookupURL = `${_config.config.network.blockstackAPIUrl}${_authConstants.NAME_LOOKUP_PATH}`;
  } else {
    nameLookupURL = `${coreNodeSessionValue}${_authConstants.NAME_LOOKUP_PATH}`;
  }

  return (0, _index.verifyAuthResponse)(authResponseToken, nameLookupURL).then(isValid => {
    if (!isValid) {
      throw new _errors.LoginFailedError('Invalid authentication response.');
    }

    const tokenPayload = (0, _jsontokens.decodeToken)(authResponseToken).payload; // TODO: real version handling

    let appPrivateKey = tokenPayload.private_key;
    let coreSessionToken = tokenPayload.core_token;

    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.1.0')) {
      if (transitKey !== undefined && transitKey != null) {
        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {
          try {
            appPrivateKey = (0, _authMessages.decryptPrivateKey)(transitKey, tokenPayload.private_key);
          } catch (e) {
            _logger.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');

            try {
              (0, _utils.hexStringToECPair)(tokenPayload.private_key);
            } catch (ecPairError) {
              throw new _errors.LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');
            }
          }
        }

        if (coreSessionToken !== undefined && coreSessionToken !== null) {
          try {
            coreSessionToken = (0, _authMessages.decryptPrivateKey)(transitKey, coreSessionToken);
          } catch (e) {
            _logger.Logger.info('Failed decryption of coreSessionToken, will try to use as given');
          }
        }
      } else {
        throw new _errors.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');
      }
    }

    let hubUrl = _authConstants.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;
    let gaiaAssociationToken;

    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {
      hubUrl = tokenPayload.hubUrl;
    }

    if ((0, _utils.isLaterVersion)(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {
      gaiaAssociationToken = tokenPayload.associationToken;
    }

    const userData = {
      username: tokenPayload.username,
      profile: tokenPayload.profile,
      email: tokenPayload.email,
      decentralizedID: tokenPayload.iss,
      identityAddress: (0, _index2.getAddressFromDID)(tokenPayload.iss),
      appPrivateKey,
      coreSessionToken,
      authResponseToken,
      hubUrl,
      gaiaAssociationToken
    };
    const profileURL = tokenPayload.profile_url;

    if ((userData.profile === null || userData.profile === undefined) && profileURL !== undefined && profileURL !== null) {
      return fetch(profileURL).then(response => {
        if (!response.ok) {
          // return blank profile if we fail to fetch
          userData.profile = Object.assign({}, DEFAULT_PROFILE);
          const sessionData = caller.store.getSessionData();
          sessionData.userData = userData;
          caller.store.setSessionData(sessionData);
          return userData;
        } else {
          return response.text().then(responseText => JSON.parse(responseText)).then(wrappedProfile => (0, _profiles.extractProfile)(wrappedProfile[0].token)).then(profile => {
            const sessionData = caller.store.getSessionData();
            userData.profile = profile;
            sessionData.userData = userData;
            caller.store.setSessionData(sessionData);
            return userData;
          });
        }
      });
    } else {
      const sessionData = caller.store.getSessionData();
      userData.profile = tokenPayload.profile;
      sessionData.userData = userData;
      caller.store.setSessionData(sessionData);
      return userData;
    }
  });
}
/**
 * Retrieves the user data object. The user's profile is stored in the key `profile`.
 *
 *  @param {UserSession} caller - the instance calling this function
 *  @return {Object} User data object.
 *  @private
 */


function loadUserDataImpl(caller) {
  const userData = caller.store.getSessionData().userData;

  if (!userData) {
    throw new _errors.InvalidStateError('No user data found. Did the user sign in?');
  }

  return userData;
}
/**
 * Redirects the user to the Blockstack browser to approve the sign in request
 * given.
 *
 * The user is redirected to the `blockstackIDHost` if the `blockstack:`
 * protocol handler is not detected. Please note that the protocol handler detection
 * does not work on all browsers.
 * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`
 * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack
 *                                     protocol handler is not detected
 * @return {void}
 */


function redirectToSignInWithAuthRequest(authRequest, blockstackIDHost = _authConstants.DEFAULT_BLOCKSTACK_HOST) {
  console.warn('DEPRECATION WARNING: The static redirectToSignInWithAuthRequest() function will ' + 'be deprecated in the next major release of blockstack.js. Create an instance of UserSession ' + 'and call the instance method redirectToSignInWithAuthRequest().');
  const userSession = new _userSession.UserSession();
  const sessionAuthRequest = authRequest == null ? userSession.makeAuthRequest(userSession.generateAndStoreTransitKey()) : authRequest;
  userSession.appConfig.authenticatorURL = blockstackIDHost;
  redirectToSignInWithAuthRequestImpl(userSession, sessionAuthRequest);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9hdXRoL2F1dGhBcHAuanMiXSwibmFtZXMiOlsiREVGQVVMVF9QUk9GSUxFIiwiaXNVc2VyU2lnbmVkSW4iLCJjb25zb2xlIiwid2FybiIsInVzZXJTZXNzaW9uIiwiVXNlclNlc3Npb24iLCJpc1NpZ25JblBlbmRpbmciLCJoYW5kbGVQZW5kaW5nU2lnbkluIiwibmFtZUxvb2t1cFVSTCIsImF1dGhSZXNwb25zZVRva2VuIiwiZ2V0QXV0aFJlc3BvbnNlVG9rZW4iLCJ0cmFuc2l0S2V5IiwicXVlcnlEaWN0IiwicXVlcnlTdHJpbmciLCJwYXJzZSIsImxvY2F0aW9uIiwic2VhcmNoIiwiYXV0aFJlc3BvbnNlIiwibG9hZFVzZXJEYXRhIiwic2lnblVzZXJPdXQiLCJyZWRpcmVjdFVSTCIsIndpbmRvdyIsIm1ha2VBdXRoUmVxdWVzdCIsInRyYW5zaXRQcml2YXRlS2V5IiwicmVkaXJlY3RVUkkiLCJvcmlnaW4iLCJtYW5pZmVzdFVSSSIsInNjb3BlcyIsIkRFRkFVTFRfU0NPUEUiLCJhcHBEb21haW4iLCJleHBpcmVzQXQiLCJnZXRUaW1lIiwiZXh0cmFQYXJhbXMiLCJnZW5lcmF0ZUFuZFN0b3JlVHJhbnNpdEtleSIsImRldGVjdFByb3RvY29sTGF1bmNoIiwiYXV0aFJlcXVlc3QiLCJzdWNjZXNzQ2FsbGJhY2siLCJmYWlsQ2FsbGJhY2siLCJlY2hvUmVwbHlJRCIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0ciIsImVjaG9SZXBseUtleVByZWZpeCIsImVjaG9SZXBseUtleSIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJEYXRlIiwibm93IiwiY2xlYW5VcExvY2FsU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJpIiwibGVuZ3RoIiwic3RvcmFnZUtleSIsImtleSIsInN0YXJ0c1dpdGgiLCJzdG9yYWdlVmFsdWUiLCJnZXRJdGVtIiwicGFyc2VJbnQiLCJlcnIiLCJMb2dnZXIiLCJlcnJvciIsImRldGVjdGlvblRpbWVvdXQiLCJyZWRpcmVjdFRvV2ViQXV0aFRpbWVyIiwiY2FuY2VsV2ViQXV0aFJlZGlyZWN0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJzdGFydFdlYkF1dGhSZWRpcmVjdFRpbWVyIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJuZXh0RnVuYyIsImluZm8iLCJpbnB1dFByb21wdFRyYWNrZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwic3R5bGUiLCJhbGwiLCJvcGFjaXR5IiwiZmlsdGVyIiwiaGVpZ2h0Iiwid2lkdGgiLCJpbnB1dEJsdXJyZWRGdW5jIiwiaXNSZWZvY3VzZWQiLCJhZGRFdmVudExpc3RlbmVyIiwib25jZSIsImNhcHR1cmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZm9jdXMiLCJwYWdlVmlzaWJpbGl0eUNoYW5nZWQiLCJoaWRkZW4iLCJyZXBseUV2ZW50TGlzdGVuZXIiLCJldmVudCIsImxvY2F0aW9uU3JjIiwiQkxPQ0tTVEFDS19IQU5ETEVSIiwiaWZyYW1lIiwiZGlzcGxheSIsInNyYyIsInJlZGlyZWN0VG9TaWduSW5XaXRoQXV0aFJlcXVlc3RJbXBsIiwiY2FsbGVyIiwiaHR0cHNVUkkiLCJERUZBVUxUX0JMT0NLU1RBQ0tfSE9TVCIsImFwcENvbmZpZyIsImF1dGhlbnRpY2F0b3JVUkwiLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicmVkaXJlY3RUb1NpZ25JbiIsInJlZGlyZWN0VG9TaWduSW5XaXRoQXV0aFJlcXVlc3QiLCJyZWRpcmVjdFRvU2lnbkluSW1wbCIsImhhbmRsZVBlbmRpbmdTaWduSW5JbXBsIiwic3RvcmUiLCJnZXRTZXNzaW9uRGF0YSIsImNvcmVOb2RlU2Vzc2lvblZhbHVlIiwiY29yZU5vZGUiLCJ0b2tlblBheWxvYWQiLCJwYXlsb2FkIiwidmVyc2lvbiIsImJsb2Nrc3RhY2tBUElVcmwiLCJ1bmRlZmluZWQiLCJjb25maWciLCJuZXR3b3JrIiwiTkFNRV9MT09LVVBfUEFUSCIsInRoZW4iLCJpc1ZhbGlkIiwiTG9naW5GYWlsZWRFcnJvciIsImFwcFByaXZhdGVLZXkiLCJwcml2YXRlX2tleSIsImNvcmVTZXNzaW9uVG9rZW4iLCJjb3JlX3Rva2VuIiwiZSIsImVjUGFpckVycm9yIiwiaHViVXJsIiwiQkxPQ0tTVEFDS19ERUZBVUxUX0dBSUFfSFVCX1VSTCIsImdhaWFBc3NvY2lhdGlvblRva2VuIiwiYXNzb2NpYXRpb25Ub2tlbiIsInVzZXJEYXRhIiwidXNlcm5hbWUiLCJwcm9maWxlIiwiZW1haWwiLCJkZWNlbnRyYWxpemVkSUQiLCJpc3MiLCJpZGVudGl0eUFkZHJlc3MiLCJwcm9maWxlVVJMIiwicHJvZmlsZV91cmwiLCJmZXRjaCIsInJlc3BvbnNlIiwib2siLCJPYmplY3QiLCJhc3NpZ24iLCJzZXNzaW9uRGF0YSIsInNldFNlc3Npb25EYXRhIiwidGV4dCIsInJlc3BvbnNlVGV4dCIsIkpTT04iLCJ3cmFwcGVkUHJvZmlsZSIsInRva2VuIiwibG9hZFVzZXJEYXRhSW1wbCIsIkludmFsaWRTdGF0ZUVycm9yIiwiYmxvY2tzdGFja0lESG9zdCIsInNlc3Npb25BdXRoUmVxdWVzdCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOztBQUNBOztBQUNBOztBQU9BOztBQUVBOztBQUNBOztBQUVBOzs7O0FBRUEsTUFBTUEsZUFBZSxHQUFHO0FBQ3RCLFdBQVMsUUFEYTtBQUV0QixjQUFZO0FBR2Q7Ozs7OztBQUx3QixDQUF4Qjs7QUFVTyxTQUFTQyxjQUFULEdBQTBCO0FBQy9CQyxFQUFBQSxPQUFPLENBQUNDLElBQVIsQ0FBYSxxRkFDVCwwRkFEUyxHQUVULG1DQUZKO0FBR0EsUUFBTUMsV0FBVyxHQUFHLElBQUlDLHdCQUFKLEVBQXBCO0FBQ0EsU0FBT0QsV0FBVyxDQUFDSCxjQUFaLEVBQVA7QUFDRDtBQUVEOzs7Ozs7QUFJTyxTQUFTSyxlQUFULEdBQTJCO0FBQ2hDSixFQUFBQSxPQUFPLENBQUND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QUFKLENBQXNCLDJDQUF0QixDQUFOO0FBQ0Q7O0FBQ0QsU0FBT3RCLFFBQVA7QUFDRDtBQUVEOzs7Ozs7Ozs7Ozs7OztBQVlPLFNBQVM1QiwrQkFBVCxDQUF5QzFFLFdBQXpDLEVBQ3lDNkgsZ0JBQXdCLEdBQ3hCMUQsc0NBRnpDLEVBRWtFO0FBQ3ZFcEcsRUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWEscUZBQ1QsOEZBRFMsR0FFVCxpRUFGSjtBQUdBLFFBQU1DLFdBQVcsR0FBRyxJQUFJQyx3QkFBSixFQUFwQjtBQUVBLFFBQU00SixrQkFBa0IsR0FBSTlILFdBQVcsSUFBSSxJQUFoQixHQUN2Qi9CLFdBQVcsQ0FBQ2tCLGVBQVosQ0FBNEJsQixXQUFXLENBQUM2QiwwQkFBWixFQUE1QixDQUR1QixHQUNpREUsV0FENUU7QUFHQS9CLEVBQUFBLFdBQVcsQ0FBQ21HLFNBQVosQ0FBc0JDLGdCQUF0QixHQUF5Q3dELGdCQUF6QztBQUVBN0QsRUFBQUEsbUNBQW1DLENBQUMvRixXQUFELEVBQWM2SixrQkFBZCxDQUFuQztBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiLyogQGZsb3cgKi9cbmltcG9ydCBxdWVyeVN0cmluZyBmcm9tICdxdWVyeS1zdHJpbmcnXG5pbXBvcnQgeyBkZWNvZGVUb2tlbiB9IGZyb20gJ2pzb250b2tlbnMnXG5pbXBvcnQgeyB2ZXJpZnlBdXRoUmVzcG9uc2UgfSBmcm9tICcuL2luZGV4J1xuaW1wb3J0IHsgXG4gIEJMT0NLU1RBQ0tfSEFORExFUiwgaXNMYXRlclZlcnNpb24sIGhleFN0cmluZ1RvRUNQYWlyLCBuZXh0TW9udGggXG59IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgZ2V0QWRkcmVzc0Zyb21ESUQgfSBmcm9tICcuLi9pbmRleCdcbmltcG9ydCB7IEludmFsaWRTdGF0ZUVycm9yLCBMb2dpbkZhaWxlZEVycm9yIH0gZnJvbSAnLi4vZXJyb3JzJ1xuaW1wb3J0IHsgZGVjcnlwdFByaXZhdGVLZXksIG1ha2VBdXRoUmVxdWVzdEltcGwgfSBmcm9tICcuL2F1dGhNZXNzYWdlcydcbmltcG9ydCB7XG4gIEJMT0NLU1RBQ0tfREVGQVVMVF9HQUlBX0hVQl9VUkwsXG4gIERFRkFVTFRfQkxPQ0tTVEFDS19IT1NULFxuICBOQU1FX0xPT0tVUF9QQVRILFxuICBERUZBVUxUX1NDT1BFXG59IGZyb20gJy4vYXV0aENvbnN0YW50cydcblxuaW1wb3J0IHsgZXh0cmFjdFByb2ZpbGUgfSBmcm9tICcuLi9wcm9maWxlcydcblxuaW1wb3J0IHsgVXNlclNlc3Npb24gfSBmcm9tICcuL3VzZXJTZXNzaW9uJ1xuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSAnLi4vY29uZmlnJ1xuXG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICcuLi9sb2dnZXInXG5cbmNvbnN0IERFRkFVTFRfUFJPRklMRSA9IHtcbiAgJ0B0eXBlJzogJ1BlcnNvbicsXG4gICdAY29udGV4dCc6ICdodHRwOi8vc2NoZW1hLm9yZydcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHVzZXIgaXMgY3VycmVudGx5IHNpZ25lZCBpbi5cbiAqIEBtZXRob2QgaXNVc2VyU2lnbmVkSW5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdXNlciBpcyBzaWduZWQgaW4sIGBmYWxzZWAgaWYgbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVc2VyU2lnbmVkSW4oKSB7XG4gIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogVGhlIHN0YXRpYyBpc1VzZXJTaWduZWRJbigpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiAnXG4gICAgKyAndGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2QgaXNVc2VyU2lnbmVkSW4oKS4nKVxuICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBVc2VyU2Vzc2lvbigpXG4gIHJldHVybiB1c2VyU2Vzc2lvbi5pc1VzZXJTaWduZWRJbigpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlcmUgaXMgYSBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IHRoYXQgaGFzbid0IGJlZW4gaGFuZGxlZC5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGVyZSBpcyBhIHBlbmRpbmcgc2lnbiBpbiwgb3RoZXJ3aXNlIGBmYWxzZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2lnbkluUGVuZGluZygpIHtcbiAgY29uc29sZS53YXJuKCdERVBSRUNBVElPTiBXQVJOSU5HOiBUaGUgc3RhdGljIGlzU2lnbkluUGVuZGluZygpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgJ1xuICAgICsgJ25leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2QgaXNTaWduSW5QZW5kaW5nKCkuJylcbiAgY29uc3QgdXNlclNlc3Npb24gPSBuZXcgVXNlclNlc3Npb24oKVxuICByZXR1cm4gdXNlclNlc3Npb24uaXNTaWduSW5QZW5kaW5nKClcbn1cblxuLyoqXG4gKiBUcnkgdG8gcHJvY2VzcyBhbnkgcGVuZGluZyBzaWduIGluIHJlcXVlc3QgYnkgcmV0dXJuaW5nIGEgYFByb21pc2VgIHRoYXQgcmVzb2x2ZXNcbiAqIHRvIHRoZSB1c2VyIGRhdGEgb2JqZWN0IGlmIHRoZSBzaWduIGluIHN1Y2NlZWRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lTG9va3VwVVJMIC0gdGhlIGVuZHBvaW50IGFnYWluc3Qgd2hpY2ggdG8gdmVyaWZ5IHB1YmxpY1xuICoga2V5cyBtYXRjaCBjbGFpbWVkIHVzZXJuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aFJlc3BvbnNlVG9rZW4gLSB0aGUgc2lnbmVkIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlIHRva2VuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNpdEtleSAtIHRoZSB0cmFuc2l0IHByaXZhdGUga2V5IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIHRyYW5zaXQgcHVibGljIGtleVxuICogdGhhdCB3YXMgcHJvdmlkZWQgaW4gdGhlIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3RcbiAqIEByZXR1cm4ge1Byb21pc2V9IHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHVzZXIgZGF0YSBvYmplY3QgaWYgc3VjY2Vzc2Z1bCBhbmQgcmVqZWN0c1xuICogaWYgaGFuZGxpbmcgdGhlIHNpZ24gaW4gcmVxdWVzdCBmYWlscyBvciB0aGVyZSB3YXMgbm8gcGVuZGluZyBzaWduIGluIHJlcXVlc3QuXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby11c2UtYmVmb3JlLWRlZmluZSAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhbmRsZVBlbmRpbmdTaWduSW4obmFtZUxvb2t1cFVSTDogc3RyaW5nID0gJycsIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXV0aFJlc3BvbnNlVG9rZW46IHN0cmluZyA9IGdldEF1dGhSZXNwb25zZVRva2VuKCksIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdEtleTogc3RyaW5nID0gJycpIHsgXG4gIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogVGhlIHN0YXRpYyBoYW5kbGVQZW5kaW5nU2lnbkluKCkgZnVuY3Rpb24gd2lsbCBiZSBkZXByZWNhdGVkIGluIHRoZSAnXG4gICAgKyAnbmV4dCBtYWpvciByZWxlYXNlIG9mIGJsb2Nrc3RhY2suanMuIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBVc2VyU2Vzc2lvbiBhbmQgY2FsbCB0aGUgJ1xuICAgICsgJ2luc3RhbmNlIG1ldGhvZCBoYW5kbGVQZW5kaW5nU2lnbkluKCkuJylcbiAgY29uc29sZS53YXJuKCdERVBSRUNBVElPTiBXQVJOSU5HOiBoYW5kbGVQZW5kaW5nU2lnbkluKCkgbm8gbG9uZyBzdXBwb3J0cyBzZXR0aW5nIG9mIG5hbWVMb29rdXBVUkwgYW5kICdcbiAgICArICd0cmFuc2l0S2V5LiBUaGUgbmFtZUxvb2t1cFVSTCBhbmQgdHJhbnNpdEtleSBub3cgZGVmYXVsdHMgdG8gdmFsdWVzIGluIHRoZSBkZWZhdWx0IHVzZXIgc2Vzc2lvbi4nKVxuICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBVc2VyU2Vzc2lvbigpXG4gIHJldHVybiB1c2VyU2Vzc2lvbi5oYW5kbGVQZW5kaW5nU2lnbkluKGF1dGhSZXNwb25zZVRva2VuKVxufVxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlbiBmcm9tIHRoZSBVUkwgcXVlcnlcbiAqIEByZXR1cm4ge1N0cmluZ30gdGhlIGF1dGhlbnRpY2F0aW9uIHRva2VuIGlmIGl0IGV4aXN0cyBvdGhlcndpc2UgYG51bGxgXG4gKi9cbmZ1bmN0aW9uIGdldEF1dGhSZXNwb25zZVRva2VuKCk6IHN0cmluZyB7XG4gIGNvbnN0IHF1ZXJ5RGljdCA9IHF1ZXJ5U3RyaW5nLnBhcnNlKGxvY2F0aW9uLnNlYXJjaClcbiAgcmV0dXJuIHF1ZXJ5RGljdC5hdXRoUmVzcG9uc2UgPyBxdWVyeURpY3QuYXV0aFJlc3BvbnNlIDogJydcbn1cblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIHVzZXIgZGF0YSBvYmplY3QuIFRoZSB1c2VyJ3MgcHJvZmlsZSBpcyBzdG9yZWQgaW4gdGhlIGtleSBgcHJvZmlsZWAuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFVzZXIgZGF0YSBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkVXNlckRhdGEoKSB7XG4gIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogVGhlIHN0YXRpYyBsb2FkVXNlckRhdGEoKSBmdW5jdGlvbiB3aWxsIGJlIGRlcHJlY2F0ZWQgaW4gdGhlICdcbiAgICArICduZXh0IG1ham9yIHJlbGVhc2Ugb2YgYmxvY2tzdGFjay5qcy4gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFVzZXJTZXNzaW9uIGFuZCBjYWxsIHRoZSAnXG4gICAgKyAnaW5zdGFuY2UgbWV0aG9kIGxvYWRVc2VyRGF0YSgpLicpXG4gIGNvbnN0IHVzZXJTZXNzaW9uID0gbmV3IFVzZXJTZXNzaW9uKClcbiAgcmV0dXJuIHVzZXJTZXNzaW9uLmxvYWRVc2VyRGF0YSgpXG59XG5cbi8qKlxuICogU2lnbiB0aGUgdXNlciBvdXQgYW5kIG9wdGlvbmFsbHkgcmVkaXJlY3QgdG8gZ2l2ZW4gbG9jYXRpb24uXG4gKiBAcGFyYW0gIHtTdHJpbmd9IFtyZWRpcmVjdFVSTD1udWxsXSBMb2NhdGlvbiB0byByZWRpcmVjdCB1c2VyIHRvIGFmdGVyIHNpZ24gb3V0LlxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ25Vc2VyT3V0KHJlZGlyZWN0VVJMOiA/c3RyaW5nID0gbnVsbCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogVGhlIHN0YXRpYyBzaWduVXNlck91dCgpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgJ1xuICAgICsgJ25leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2Qgc2lnblVzZXJPdXQoKS4nKVxuICBjb25zdCB1c2VyU2Vzc2lvbiA9IG5ldyBVc2VyU2Vzc2lvbigpXG4gIHVzZXJTZXNzaW9uLnNpZ25Vc2VyT3V0KClcbiAgd2luZG93LmxvY2F0aW9uID0gcmVkaXJlY3RVUkxcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCB0aGF0IGNhbiBiZSBzZW50IHRvIHRoZSBCbG9ja3N0YWNrXG4gKiBicm93c2VyIGZvciB0aGUgdXNlciB0byBhcHByb3ZlIHNpZ24gaW4uIFRoaXMgYXV0aGVudGljYXRpb24gcmVxdWVzdCBjYW5cbiAqIHRoZW4gYmUgdXNlZCBmb3Igc2lnbiBpbiBieSBwYXNzaW5nIGl0IHRvIHRoZSBgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdGBcbiAqIG1ldGhvZC5cbiAqXG4gKiAqTm90ZTogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCBpZiB5b3Ugd2FudCB0byByb2xsIHlvdXIgb3duIGF1dGhlbnRpY2F0aW9uXG4gKiBmbG93LiBUeXBpY2FsbHkgeW91J2QgdXNlIGByZWRpcmVjdFRvU2lnbkluYCB3aGljaCB0YWtlcyBjYXJlIG9mIHRoaXNcbiAqIHVuZGVyIHRoZSBob29kLipcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHRyYW5zaXRQcml2YXRlS2V5IC0gaGV4IGVuY29kZWQgdHJhbnNpdCBwcml2YXRlIGtleVxuICogQHBhcmFtIHtTdHJpbmd9IHJlZGlyZWN0VVJJIC0gbG9jYXRpb24gdG8gcmVkaXJlY3QgdXNlciB0byBhZnRlciBzaWduIGluIGFwcHJvdmFsXG4gKiBAcGFyYW0ge1N0cmluZ30gbWFuaWZlc3RVUkkgLSBsb2NhdGlvbiBvZiB0aGlzIGFwcCdzIG1hbmlmZXN0IGZpbGVcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gc2NvcGVzIC0gdGhlIHBlcm1pc3Npb25zIHRoaXMgYXBwIGlzIHJlcXVlc3RpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBhcHBEb21haW4gLSB0aGUgb3JpZ2luIG9mIHRoaXMgYXBwXG4gKiBAcGFyYW0ge051bWJlcn0gZXhwaXJlc0F0IC0gdGhlIHRpbWUgYXQgd2hpY2ggdGhpcyByZXF1ZXN0IGlzIG5vIGxvbmdlciB2YWxpZFxuICogQHBhcmFtIHtPYmplY3R9IGV4dHJhUGFyYW1zIC0gQW55IGV4dHJhIHBhcmFtZXRlcnMgeW91J2QgbGlrZSB0byBwYXNzIHRvIHRoZSBhdXRoZW50aWNhdG9yLlxuICogVXNlIHRoaXMgdG8gcGFzcyBvcHRpb25zIHRoYXQgYXJlbid0IHBhcnQgb2YgdGhlIEJsb2Nrc3RhY2sgYXV0aCBzcGVjLCBidXQgbWlnaHQgYmUgc3VwcG9ydGVkXG4gKiBieSBzcGVjaWFsIGF1dGhlbnRpY2F0b3JzLlxuICogQHJldHVybiB7U3RyaW5nfSB0aGUgYXV0aGVudGljYXRpb24gcmVxdWVzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFrZUF1dGhSZXF1ZXN0KHRyYW5zaXRQcml2YXRlS2V5OiA/c3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVSSTogc3RyaW5nID0gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vYCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0VVJJOiBzdHJpbmcgPSBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9tYW5pZmVzdC5qc29uYCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlczogQXJyYXk8c3RyaW5nPiA9IERFRkFVTFRfU0NPUEUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcERvbWFpbjogc3RyaW5nID0gd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwaXJlc0F0OiBudW1iZXIgPSBuZXh0TW9udGgoKS5nZXRUaW1lKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhUGFyYW1zOiBPYmplY3QgPSB7fSk6IHN0cmluZyB7XG4gIGNvbnNvbGUud2FybignREVQUkVDQVRJT04gV0FSTklORzogVGhlIG1ha2VBdXRoUmVxdWVzdCgpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgJ1xuICAgICsgJ25leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBVc2UgVXNlclNlc3Npb24gdG8gY29uZmlndXJlIHlvdXIgYXV0aCByZXF1ZXN0LicpXG4gIGNvbnN0IHVzZXJTZXNzaW9uID0gbmV3IFVzZXJTZXNzaW9uKClcbiAgY29uc3QgdHJhbnNpdEtleSA9ICh0cmFuc2l0UHJpdmF0ZUtleSA9PSBudWxsKSBcbiAgICA/IHVzZXJTZXNzaW9uLmdlbmVyYXRlQW5kU3RvcmVUcmFuc2l0S2V5KCkgOiB0cmFuc2l0UHJpdmF0ZUtleVxuXG4gIHJldHVybiBtYWtlQXV0aFJlcXVlc3RJbXBsKHRyYW5zaXRLZXksIHJlZGlyZWN0VVJJLCBtYW5pZmVzdFVSSSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVzLCBhcHBEb21haW4sIGV4cGlyZXNBdCwgZXh0cmFQYXJhbXMpXG59XG5cbi8qKlxuICogRGV0ZWN0cyBpZiB0aGUgbmF0aXZlIGF1dGgtYnJvd3NlciBpcyBpbnN0YWxsZWQgYW5kIGlzIHN1Y2Nlc3NmdWxseSBcbiAqIGxhdW5jaGVkIHZpYSBhIGN1c3RvbSBwcm90b2NvbCBVUkkuIFxuICogQHBhcmFtIHtTdHJpbmd9IGF1dGhSZXF1ZXN0XG4gKiBUaGUgZW5jb2RlZCBhdXRoUmVxdWVzdCB0byBiZSB1c2VkIGFzIGEgcXVlcnkgcGFyYW0gaW4gdGhlIGN1c3RvbSBVUkkuIFxuICogQHBhcmFtIHtTdHJpbmd9IHN1Y2Nlc3NDYWxsYmFja1xuICogVGhlIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuIHRoZSBwcm90b2NvbCBoYW5kbGVyIHdhcyBkZXRlY3RlZC4gXG4gKiBAcGFyYW0ge1N0cmluZ30gZmFpbENhbGxiYWNrXG4gKiBUaGUgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW4gdGhlIHByb3RvY29sIGhhbmRsZXIgd2FzIG5vdCBkZXRlY3RlZC4gXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5mdW5jdGlvbiBkZXRlY3RQcm90b2NvbExhdW5jaChcbiAgYXV0aFJlcXVlc3Q6IHN0cmluZywgXG4gIHN1Y2Nlc3NDYWxsYmFjazogKCkgPT4gdm9pZCwgXG4gIGZhaWxDYWxsYmFjazogKCkgPT4gdm9pZCkge1xuICAvLyBDcmVhdGUgYSB1bmlxdWUgSUQgdXNlZCBmb3IgdGhpcyBwcm90b2NvbCBkZXRlY3Rpb24gYXR0ZW1wdC5cbiAgY29uc3QgZWNob1JlcGx5SUQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHIoMiwgOSlcbiAgY29uc3QgZWNob1JlcGx5S2V5UHJlZml4ID0gJ2VjaG8tcmVwbHktJ1xuICBjb25zdCBlY2hvUmVwbHlLZXkgPSBgJHtlY2hvUmVwbHlLZXlQcmVmaXh9JHtlY2hvUmVwbHlJRH1gXG5cbiAgLy8gVXNlIGxvY2FsU3RvcmFnZSBhcyBhIHJlbGlhYmxlIGNyb3NzLXdpbmRvdyBjb21tdW5pY2F0aW9uIG1ldGhvZC5cbiAgLy8gQ3JlYXRlIHRoZSBzdG9yYWdlIGVudHJ5IHRvIHNpZ25hbCBhIHByb3RvY29sIGRldGVjdGlvbiBhdHRlbXB0IGZvciB0aGVcbiAgLy8gbmV4dCBicm93c2VyIHdpbmRvdyB0byBjaGVjay5cbiAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGVjaG9SZXBseUtleSwgRGF0ZS5ub3coKS50b1N0cmluZygpKVxuICBjb25zdCBjbGVhblVwTG9jYWxTdG9yYWdlID0gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oZWNob1JlcGx5S2V5KVxuICAgICAgLy8gQWxzbyBjbGVhciBvdXQgYW55IHN0YWxlIGVjaG8tcmVwbHkga2V5cyBvbGRlciB0aGFuIDEgaG91ci5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2luZG93LmxvY2FsU3RvcmFnZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5ID0gd2luZG93LmxvY2FsU3RvcmFnZS5rZXkoaSlcbiAgICAgICAgaWYgKHN0b3JhZ2VLZXkuc3RhcnRzV2l0aChlY2hvUmVwbHlLZXlQcmVmaXgpKSB7XG4gICAgICAgICAgY29uc3Qgc3RvcmFnZVZhbHVlID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKHN0b3JhZ2VLZXkpXG4gICAgICAgICAgaWYgKHN0b3JhZ2VWYWx1ZSA9PT0gJ3N1Y2Nlc3MnIHx8IChEYXRlLm5vdygpIC0gcGFyc2VJbnQoc3RvcmFnZVZhbHVlLCAxMCkpID4gMzYwMDAwMCkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBMb2dnZXIuZXJyb3IoJ0V4Y2VwdGlvbiBjbGVhbmluZyB1cCBlY2hvLXJlcGx5IGVudHJpZXMgaW4gbG9jYWxTdG9yYWdlJylcbiAgICAgIExvZ2dlci5lcnJvcihlcnIpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZGV0ZWN0aW9uVGltZW91dCA9IDEwMDBcbiAgbGV0IHJlZGlyZWN0VG9XZWJBdXRoVGltZXIgPSAwXG4gIGNvbnN0IGNhbmNlbFdlYkF1dGhSZWRpcmVjdFRpbWVyID0gKCkgPT4ge1xuICAgIGlmIChyZWRpcmVjdFRvV2ViQXV0aFRpbWVyKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJlZGlyZWN0VG9XZWJBdXRoVGltZXIpXG4gICAgICByZWRpcmVjdFRvV2ViQXV0aFRpbWVyID0gMFxuICAgIH1cbiAgfVxuICBjb25zdCBzdGFydFdlYkF1dGhSZWRpcmVjdFRpbWVyID0gKHRpbWVvdXQgPSBkZXRlY3Rpb25UaW1lb3V0KSA9PiB7XG4gICAgY2FuY2VsV2ViQXV0aFJlZGlyZWN0VGltZXIoKVxuICAgIHJlZGlyZWN0VG9XZWJBdXRoVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAocmVkaXJlY3RUb1dlYkF1dGhUaW1lcikge1xuICAgICAgICBjYW5jZWxXZWJBdXRoUmVkaXJlY3RUaW1lcigpXG4gICAgICAgIGxldCBuZXh0RnVuY1xuICAgICAgICBpZiAod2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGVjaG9SZXBseUtleSkgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgIExvZ2dlci5pbmZvKCdQcm90b2NvbCBlY2hvIHJlcGx5IGRldGVjdGVkLicpXG4gICAgICAgICAgbmV4dEZ1bmMgPSBzdWNjZXNzQ2FsbGJhY2tcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMb2dnZXIuaW5mbygnUHJvdG9jb2wgaGFuZGxlciBub3QgZGV0ZWN0ZWQuJylcbiAgICAgICAgICBuZXh0RnVuYyA9IGZhaWxDYWxsYmFja1xuICAgICAgICB9XG4gICAgICAgIGZhaWxDYWxsYmFjayA9ICgpID0+IHt9XG4gICAgICAgIHN1Y2Nlc3NDYWxsYmFjayA9ICgpID0+IHt9XG4gICAgICAgIGNsZWFuVXBMb2NhbFN0b3JhZ2UoKVxuICAgICAgICAvLyBCcmllZmx5IHdhaXQgc2luY2UgbG9jYWxTdG9yYWdlIGNoYW5nZXMgY2FuIFxuICAgICAgICAvLyBzb21ldGltZXMgYmUgaWdub3JlZCB3aGVuIGltbWVkaWF0ZWx5IHJlZGlyZWN0ZWQuXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gbmV4dEZ1bmMoKSwgMTAwKVxuICAgICAgfVxuICAgIH0sIHRpbWVvdXQpXG4gIH1cblxuICBzdGFydFdlYkF1dGhSZWRpcmVjdFRpbWVyKClcblxuICBjb25zdCBpbnB1dFByb21wdFRyYWNrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gIGlucHV0UHJvbXB0VHJhY2tlci50eXBlID0gJ3RleHQnXG4gIC8vIFByZXZlbnQgdGhpcyBlbGVtZW50IGZyb20gaW5oZXJpdGVkIGFueSBjc3MuXG4gIGlucHV0UHJvbXB0VHJhY2tlci5zdHlsZS5hbGwgPSAnaW5pdGlhbCdcbiAgLy8gU2V0dGluZyBkaXNwbGF5PW5vbmUgb24gYW4gZWxlbWVudCBwcmV2ZW50cyB0aGVtIGZyb20gYmVpbmcgZm9jdXNlZC9ibHVycmVkLlxuICAvLyBTbyBoaWRlIHRoZSBlbGVtZW50IHVzaW5nIG90aGVyIHByb3BlcnRpZXMuLlxuICBpbnB1dFByb21wdFRyYWNrZXIuc3R5bGUub3BhY2l0eSA9ICcwJ1xuICBpbnB1dFByb21wdFRyYWNrZXIuc3R5bGUuZmlsdGVyID0gJ2FscGhhKG9wYWNpdHk9MCknXG4gIGlucHV0UHJvbXB0VHJhY2tlci5zdHlsZS5oZWlnaHQgPSAnMCdcbiAgaW5wdXRQcm9tcHRUcmFja2VyLnN0eWxlLndpZHRoID0gJzAnXG5cbiAgLy8gSWYgdGhlIHRoZSBmb2N1cyBvZiBhIHBhZ2UgZWxlbWVudCBpcyBpbW1lZGlhdGVseSBjaGFuZ2VkIHRoZW4gdGhpcyBsaWtlbHkgaW5kaWNhdGVzIFxuICAvLyB0aGUgcHJvdG9jb2wgaGFuZGxlciBpcyBpbnN0YWxsZWQsIGFuZCB0aGUgYnJvd3NlciBpcyBwcm9tcHRpbmcgdGhlIHVzZXIgaWYgdGhleSB3YW50IFxuICAvLyB0byBvcGVuIHRoZSBhcHBsaWNhdGlvbi4gXG4gIGNvbnN0IGlucHV0Qmx1cnJlZEZ1bmMgPSAoKSA9PiB7XG4gICAgLy8gVXNlIGEgdGltZW91dCBvZiAxMDBtcyB0byBpZ25vcmUgaW5zdGFudCB0b2dnbGVzIGJldHdlZW4gYmx1ciBhbmQgZm9jdXMuXG4gICAgLy8gQnJvd3NlcnMgb2Z0ZW4gcGVyZm9ybSBhbiBpbnN0YW50IGJsdXIgJiBmb2N1cyB3aGVuIHRoZSBwcm90b2NvbCBoYW5kbGVyIGlzIHdvcmtpbmdcbiAgICAvLyBidXQgbm90IHNob3dpbmcgYW55IGJyb3dzZXIgcHJvbXB0cywgc28gd2Ugd2FudCB0byBpZ25vcmUgdGhvc2UgaW5zdGFuY2VzLlxuICAgIGxldCBpc1JlZm9jdXNlZCA9IGZhbHNlXG4gICAgaW5wdXRQcm9tcHRUcmFja2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgKCkgPT4geyBpc1JlZm9jdXNlZCA9IHRydWUgfSwgeyBvbmNlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAocmVkaXJlY3RUb1dlYkF1dGhUaW1lciAmJiAhaXNSZWZvY3VzZWQpIHtcbiAgICAgICAgTG9nZ2VyLmluZm8oJ0RldGVjdGVkIHBvc3NpYmxlIGJyb3dzZXIgcHJvbXB0IGZvciBvcGVuaW5nIHRoZSBwcm90b2NvbCBoYW5kbGVyIGFwcC4nKVxuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHJlZGlyZWN0VG9XZWJBdXRoVGltZXIpXG4gICAgICAgIGlucHV0UHJvbXB0VHJhY2tlci5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsICgpID0+IHtcbiAgICAgICAgICBpZiAocmVkaXJlY3RUb1dlYkF1dGhUaW1lcikge1xuICAgICAgICAgICAgTG9nZ2VyLmluZm8oJ1Bvc3NpYmxlIGJyb3dzZXIgcHJvbXB0IGNsb3NlZCwgcmVzdGFydGluZyBhdXRoIHJlZGlyZWN0IHRpbWVvdXQuJylcbiAgICAgICAgICAgIHN0YXJ0V2ViQXV0aFJlZGlyZWN0VGltZXIoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgeyBvbmNlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pXG4gICAgICB9XG4gICAgfSwgMTAwKVxuICB9XG4gIGlucHV0UHJvbXB0VHJhY2tlci5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgaW5wdXRCbHVycmVkRnVuYywgeyBvbmNlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pXG4gIHNldFRpbWVvdXQoKCkgPT4gaW5wdXRQcm9tcHRUcmFja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBpbnB1dEJsdXJyZWRGdW5jKSwgMjAwKVxuICAvLyBGbG93IGNvbXBsYWlucyB3aXRob3V0IHRoaXMgY2hlY2suXG4gIGlmIChkb2N1bWVudC5ib2R5KSBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlucHV0UHJvbXB0VHJhY2tlcilcbiAgaW5wdXRQcm9tcHRUcmFja2VyLmZvY3VzKClcbiAgXG4gIC8vIERldGVjdCBpZiBkb2N1bWVudC52aXNpYmlsaXR5IGlzIGltbWVkaWF0ZWx5IGNoYW5nZWQgd2hpY2ggaXMgYSBzdHJvbmcgXG4gIC8vIGluZGljYXRpb24gdGhhdCB0aGUgcHJvdG9jb2wgaGFuZGxlciBpcyB3b3JraW5nLiBXZSBkb24ndCBrbm93IGZvciBzdXJlIGFuZCBcbiAgLy8gY2FuJ3QgcHJlZGljdCBmdXR1cmUgYnJvd3NlciBjaGFuZ2VzLCBzbyBvbmx5IGluY3JlYXNlIHRoZSByZWRpcmVjdCB0aW1lb3V0LlxuICAvLyBUaGlzIHJlZHVjZXMgdGhlIHByb2JhYmlsaXR5IG9mIGEgZmFsc2UtbmVnYXRpdmUgKHdoZXJlIGxvY2FsIGF1dGggd29ya3MsIGJ1dCBcbiAgLy8gdGhlIG9yaWdpbmFsIHBhZ2Ugd2FzIHJlZGlyZWN0IHRvIHdlYiBhdXRoIGJlY2F1c2Ugc29tZXRoaW5nIHRvb2sgdG9vIGxvbmcpLFxuICBjb25zdCBwYWdlVmlzaWJpbGl0eUNoYW5nZWQgPSAoKSA9PiB7XG4gICAgaWYgKGRvY3VtZW50LmhpZGRlbiAmJiByZWRpcmVjdFRvV2ViQXV0aFRpbWVyKSB7XG4gICAgICBMb2dnZXIuaW5mbygnRGV0ZWN0ZWQgaW1tZWRpYXRlIHBhZ2UgdmlzaWJpbGl0eSBjaGFuZ2UgKHByb3RvY29sIGhhbmRsZXIgcHJvYmFibHkgd29ya2luZykuJylcbiAgICAgIHN0YXJ0V2ViQXV0aFJlZGlyZWN0VGltZXIoMzAwMClcbiAgICB9XG4gIH1cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHBhZ2VWaXNpYmlsaXR5Q2hhbmdlZCwgeyBvbmNlOiB0cnVlLCBjYXB0dXJlOiB0cnVlIH0pXG4gIHNldFRpbWVvdXQoKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIHBhZ2VWaXNpYmlsaXR5Q2hhbmdlZCksIDUwMClcblxuXG4gIC8vIExpc3RlbiBmb3IgdGhlIGN1c3RvbSBwcm90b2NvbCBlY2hvIHJlcGx5IHZpYSBsb2NhbFN0b3JhZ2UgdXBkYXRlIGV2ZW50LlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIGZ1bmN0aW9uIHJlcGx5RXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgIGlmIChldmVudC5rZXkgPT09IGVjaG9SZXBseUtleSAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oZWNob1JlcGx5S2V5KSA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAvLyBDdXN0b20gcHJvdG9jb2wgd29ya2VkLCBjYW5jZWwgdGhlIHdlYiBhdXRoIHJlZGlyZWN0IHRpbWVyLlxuICAgICAgY2FuY2VsV2ViQXV0aFJlZGlyZWN0VGltZXIoKVxuICAgICAgaW5wdXRQcm9tcHRUcmFja2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCBpbnB1dEJsdXJyZWRGdW5jKVxuICAgICAgTG9nZ2VyLmluZm8oJ1Byb3RvY29sIGVjaG8gcmVwbHkgZGV0ZWN0ZWQgZnJvbSBsb2NhbFN0b3JhZ2UgZXZlbnQuJylcbiAgICAgIC8vIENsZWFuIHVwIGV2ZW50IGxpc3RlbmVyIGFuZCBsb2NhbFN0b3JhZ2UuXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIHJlcGx5RXZlbnRMaXN0ZW5lcilcbiAgICAgIGNvbnN0IG5leHRGdW5jID0gc3VjY2Vzc0NhbGxiYWNrXG4gICAgICBzdWNjZXNzQ2FsbGJhY2sgPSAoKSA9PiB7fVxuICAgICAgZmFpbENhbGxiYWNrID0gKCkgPT4ge31cbiAgICAgIGNsZWFuVXBMb2NhbFN0b3JhZ2UoKVxuICAgICAgLy8gQnJpZWZseSB3YWl0IHNpbmNlIGxvY2FsU3RvcmFnZSBjaGFuZ2VzIGNhbiBzb21ldGltZXMgXG4gICAgICAvLyBiZSBpZ25vcmVkIHdoZW4gaW1tZWRpYXRlbHkgcmVkaXJlY3RlZC5cbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gbmV4dEZ1bmMoKSwgMTAwKVxuICAgIH1cbiAgfSwgZmFsc2UpXG5cbiAgLy8gVXNlIGlmcmFtZSB0ZWNobmlxdWUgZm9yIGxhdW5jaGluZyB0aGUgcHJvdG9jb2wgVVJJIHJhdGhlciB0aGFuIHNldHRpbmcgYHdpbmRvdy5sb2NhdGlvbmAuXG4gIC8vIFRoaXMgbWV0aG9kIHByZXZlbnRzIGJyb3dzZXJzIGxpa2UgU2FmYXJpLCBPcGVyYSwgRmlyZWZveCBmcm9tIHNob3dpbmcgZXJyb3IgcHJvbXB0c1xuICAvLyBhYm91dCB1bmtub3duIHByb3RvY29sIGhhbmRsZXIgd2hlbiBhcHAgaXMgbm90IGluc3RhbGxlZCwgYW5kIGF2b2lkcyBhbiBlbXB0eVxuICAvLyBicm93c2VyIHRhYiB3aGVuIHRoZSBhcHAgaXMgaW5zdGFsbGVkLiBcbiAgTG9nZ2VyLmluZm8oJ0F0dGVtcHRpbmcgcHJvdG9jb2wgbGF1bmNoIHZpYSBpZnJhbWUgaW5qZWN0aW9uLicpXG4gIGNvbnN0IGxvY2F0aW9uU3JjID0gYCR7QkxPQ0tTVEFDS19IQU5ETEVSfToke2F1dGhSZXF1ZXN0fSZlY2hvPSR7ZWNob1JlcGx5SUR9YFxuICBjb25zdCBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICBpZnJhbWUuc3R5bGUuYWxsID0gJ2luaXRpYWwnXG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gIGlmcmFtZS5zcmMgPSBsb2NhdGlvblNyY1xuICAvLyBGbG93IGNvbXBsYWlucyB3aXRob3V0IHRoaXMgY2hlY2suXG4gIGlmIChkb2N1bWVudC5ib2R5KSB7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpXG4gIH0gZWxzZSB7XG4gICAgTG9nZ2VyLmVycm9yKCdkb2N1bWVudC5ib2R5IGlzIG51bGwgd2hlbiBhdHRlbXB0aW5nIGlmcmFtZSBpbmplY3Rpb24gZm9yIHByb3Rvb2NvbCBVUkkgbGF1bmNoJylcbiAgfVxufVxuXG4vKipcbiAqIFJlZGlyZWN0cyB0aGUgdXNlciB0byB0aGUgQmxvY2tzdGFjayBicm93c2VyIHRvIGFwcHJvdmUgdGhlIHNpZ24gaW4gcmVxdWVzdFxuICogZ2l2ZW4uXG4gKlxuICogVGhlIHVzZXIgaXMgcmVkaXJlY3RlZCB0byB0aGUgYGJsb2Nrc3RhY2tJREhvc3RgIGlmIHRoZSBgYmxvY2tzdGFjazpgXG4gKiBwcm90b2NvbCBoYW5kbGVyIGlzIG5vdCBkZXRlY3RlZC4gUGxlYXNlIG5vdGUgdGhhdCB0aGUgcHJvdG9jb2wgaGFuZGxlciBkZXRlY3Rpb25cbiAqIGRvZXMgbm90IHdvcmsgb24gYWxsIGJyb3dzZXJzLlxuICogQHBhcmFtICB7VXNlclNlc3Npb259IGNhbGxlciAtIHRoZSBpbnN0YW5jZSBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF1dGhSZXF1ZXN0IC0gdGhlIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgZ2VuZXJhdGVkIGJ5IGBtYWtlQXV0aFJlcXVlc3RgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJsb2Nrc3RhY2tJREhvc3QgLSB0aGUgVVJMIHRvIHJlZGlyZWN0IHRoZSB1c2VyIHRvIGlmIHRoZSBibG9ja3N0YWNrXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCBoYW5kbGVyIGlzIG5vdCBkZXRlY3RlZFxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0SW1wbChjYWxsZXI6IFVzZXJTZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhSZXF1ZXN0OiBzdHJpbmcpIHtcbiAgbGV0IGh0dHBzVVJJID0gYCR7REVGQVVMVF9CTE9DS1NUQUNLX0hPU1R9P2F1dGhSZXF1ZXN0PSR7YXV0aFJlcXVlc3R9YFxuXG4gIGlmIChjYWxsZXIuYXBwQ29uZmlnXG4gICAgICAmJiBjYWxsZXIuYXBwQ29uZmlnLmF1dGhlbnRpY2F0b3JVUkwpIHtcbiAgICBodHRwc1VSSSA9IGAke2NhbGxlci5hcHBDb25maWcuYXV0aGVudGljYXRvclVSTH0/YXV0aFJlcXVlc3Q9JHthdXRoUmVxdWVzdH1gXG4gIH1cblxuICAvLyBJZiB0aGV5J3JlIG9uIGEgbW9iaWxlIE9TLCBhbHdheXMgcmVkaXJlY3QgdGhlbSB0byBIVFRQUyBzaXRlXG4gIGlmICgvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfE9wZXJhIE1pbmkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgTG9nZ2VyLmluZm8oJ2RldGVjdGVkIG1vYmlsZSBPUywgc2VuZGluZyB0byBodHRwcycpXG4gICAgd2luZG93LmxvY2F0aW9uID0gaHR0cHNVUklcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjaygpIHtcbiAgICBMb2dnZXIuaW5mbygncHJvdG9jb2wgaGFuZGxlciBkZXRlY3RlZCcpXG4gICAgLy8gVGhlIGRldGVjdGlvbiBmdW5jdGlvbiBzaG91bGQgb3BlbiB0aGUgbGluayBmb3IgdXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGZhaWxDYWxsYmFjaygpIHtcbiAgICBMb2dnZXIud2FybigncHJvdG9jb2wgaGFuZGxlciBub3QgZGV0ZWN0ZWQnKVxuICAgIHdpbmRvdy5sb2NhdGlvbiA9IGh0dHBzVVJJXG4gIH1cblxuICBkZXRlY3RQcm90b2NvbExhdW5jaChhdXRoUmVxdWVzdCwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsQ2FsbGJhY2spXG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgYW5kIHJlZGlyZWN0cyB0aGUgdXNlciB0byB0aGUgQmxvY2tzdGFja1xuICogYnJvd3NlciB0byBhcHByb3ZlIHRoZSBzaWduIGluIHJlcXVlc3QuXG4gKlxuICogUGxlYXNlIG5vdGUgdGhhdCB0aGlzIHJlcXVpcmVzIHRoYXQgdGhlIHdlYiBicm93c2VyIHByb3Blcmx5IGhhbmRsZXMgdGhlXG4gKiBgYmxvY2tzdGFjazpgIFVSTCBwcm90b2NvbCBoYW5kbGVyLlxuICpcbiAqIE1vc3QgYXBwbGljYXRpb25zIHNob3VsZCB1c2UgdGhpc1xuICogbWV0aG9kIGZvciBzaWduIGluIHVubGVzcyB0aGV5IHJlcXVpcmUgbW9yZSBmaW5lIGdyYWluZWQgY29udHJvbCBvdmVyIGhvdyB0aGVcbiAqIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgaXMgZ2VuZXJhdGVkLiBJZiB5b3VyIGFwcCBmYWxscyBpbnRvIHRoaXMgY2F0ZWdvcnksXG4gKiB1c2UgYG1ha2VBdXRoUmVxdWVzdGAgYW5kIGByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0YCB0byBidWlsZCB5b3VyIG93biBzaWduIGluIHByb2Nlc3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtyZWRpcmVjdFVSST1gJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9gXVxuICogVGhlIGxvY2F0aW9uIHRvIHdoaWNoIHRoZSBpZGVudGl0eSBwcm92aWRlciB3aWxsIHJlZGlyZWN0IHRoZSB1c2VyIGFmdGVyXG4gKiB0aGUgdXNlciBhcHByb3ZlcyBzaWduIGluLlxuICogQHBhcmFtICB7U3RyaW5nfSBbbWFuaWZlc3RVUkk9YCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vbWFuaWZlc3QuanNvbmBdXG4gKiBMb2NhdGlvbiBvZiB0aGUgbWFuaWZlc3QgZmlsZS5cbiAqIEBwYXJhbSAge0FycmF5fSBbc2NvcGVzPURFRkFVTFRfU0NPUEVdIERlZmF1bHRzIHRvIHJlcXVlc3Rpbmcgd3JpdGUgYWNjZXNzIHRvXG4gKiB0aGlzIGFwcCdzIGRhdGEgc3RvcmUuXG4gKiBBbiBhcnJheSBvZiBzdHJpbmdzIGluZGljYXRpbmcgd2hpY2ggcGVybWlzc2lvbnMgdGhpcyBhcHAgaXMgcmVxdWVzdGluZy5cbiAqIEByZXR1cm4ge3ZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWRpcmVjdFRvU2lnbkluKHJlZGlyZWN0VVJJOiBzdHJpbmcgPSBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9gLCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0VVJJOiBzdHJpbmcgPSBgJHt3aW5kb3cubG9jYXRpb24ub3JpZ2lufS9tYW5pZmVzdC5qc29uYCwgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZXM6IEFycmF5PHN0cmluZz4gPSBERUZBVUxUX1NDT1BFKSB7IFxuICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IFRoZSBzdGF0aWMgcmVkaXJlY3RUb1NpZ25JbigpIGZ1bmN0aW9uIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgJ1xuICAgICsgJ25leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gYW5kIGNhbGwgdGhlICdcbiAgICArICdpbnN0YW5jZSBtZXRob2QgcmVkaXJlY3RUb1NpZ25JbigpLicpXG4gIGNvbnN0IGF1dGhSZXF1ZXN0ID0gbWFrZUF1dGhSZXF1ZXN0KG51bGwsIHJlZGlyZWN0VVJJLCBtYW5pZmVzdFVSSSwgc2NvcGVzKVxuICByZWRpcmVjdFRvU2lnbkluV2l0aEF1dGhSZXF1ZXN0KGF1dGhSZXF1ZXN0KVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0IGFuZCByZWRpcmVjdHMgdGhlIHVzZXIgdG8gdGhlIEJsb2Nrc3RhY2tcbiAqIGJyb3dzZXIgdG8gYXBwcm92ZSB0aGUgc2lnbiBpbiByZXF1ZXN0LlxuICpcbiAqIFBsZWFzZSBub3RlIHRoYXQgdGhpcyByZXF1aXJlcyB0aGF0IHRoZSB3ZWIgYnJvd3NlciBwcm9wZXJseSBoYW5kbGVzIHRoZVxuICogYGJsb2Nrc3RhY2s6YCBVUkwgcHJvdG9jb2wgaGFuZGxlci5cbiAqXG4gKiBNb3N0IHdlYiBhcHBsaWNhdGlvbnMgc2hvdWxkIHVzZSB0aGlzXG4gKiBtZXRob2QgZm9yIHNpZ24gaW4gdW5sZXNzIHRoZXkgcmVxdWlyZSBtb3JlIGZpbmUgZ3JhaW5lZCBjb250cm9sIG92ZXIgaG93IHRoZVxuICogYXV0aGVudGljYXRpb24gcmVxdWVzdCBpcyBnZW5lcmF0ZWQuIElmIHlvdXIgYXBwIGZhbGxzIGludG8gdGhpcyBjYXRlZ29yeSxcbiAqIHVzZSBgbWFrZUF1dGhSZXF1ZXN0YCxcbiAqIGFuZCBgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdGAgdG8gYnVpbGQgeW91ciBvd24gc2lnbiBpbiBwcm9jZXNzLlxuICogQHBhcmFtIHtVc2VyU2Vzc2lvbn0gY2FsbGVyIC0gdGhlIGluc3RhbmNlIGNhbGxpbmcgdGhpcyBmdW5jdGlvblxuICogQHJldHVybiB7dm9pZH1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWRpcmVjdFRvU2lnbkluSW1wbChjYWxsZXI6IFVzZXJTZXNzaW9uKSB7XG4gIGNvbnN0IHRyYW5zaXRLZXkgPSBjYWxsZXIuZ2VuZXJhdGVBbmRTdG9yZVRyYW5zaXRLZXkoKVxuICBjb25zdCBhdXRoUmVxdWVzdCA9IGNhbGxlci5tYWtlQXV0aFJlcXVlc3QodHJhbnNpdEtleSlcbiAgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdEltcGwoY2FsbGVyLCBhdXRoUmVxdWVzdClcbn1cblxuXG4vKipcbiAqIFRyeSB0byBwcm9jZXNzIGFueSBwZW5kaW5nIHNpZ24gaW4gcmVxdWVzdCBieSByZXR1cm5pbmcgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlc1xuICogdG8gdGhlIHVzZXIgZGF0YSBvYmplY3QgaWYgdGhlIHNpZ24gaW4gc3VjY2VlZHMuXG4gKlxuICogQHBhcmFtIHtVc2VyU2Vzc2lvbn0gY2FsbGVyIC0gdGhlIGluc3RhbmNlIGNhbGxpbmcgdGhpcyBmdW5jdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGF1dGhSZXNwb25zZVRva2VuIC0gdGhlIHNpZ25lZCBhdXRoZW50aWNhdGlvbiByZXNwb25zZSB0b2tlblxuICogQHJldHVybiB7UHJvbWlzZX0gdGhhdCByZXNvbHZlcyB0byB0aGUgdXNlciBkYXRhIG9iamVjdCBpZiBzdWNjZXNzZnVsIGFuZCByZWplY3RzXG4gKiBpZiBoYW5kbGluZyB0aGUgc2lnbiBpbiByZXF1ZXN0IGZhaWxzIG9yIHRoZXJlIHdhcyBubyBwZW5kaW5nIHNpZ24gaW4gcmVxdWVzdC5cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYW5kbGVQZW5kaW5nU2lnbkluSW1wbChjYWxsZXI6IFVzZXJTZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhSZXNwb25zZVRva2VuOiBzdHJpbmcpIHtcbiAgY29uc3QgdHJhbnNpdEtleSA9IGNhbGxlci5zdG9yZS5nZXRTZXNzaW9uRGF0YSgpLnRyYW5zaXRLZXlcbiAgY29uc3QgY29yZU5vZGVTZXNzaW9uVmFsdWUgPSBjYWxsZXIuc3RvcmUuZ2V0U2Vzc2lvbkRhdGEoKS5jb3JlTm9kZVxuICBsZXQgbmFtZUxvb2t1cFVSTCA9IG51bGxcblxuICBpZiAoIWNvcmVOb2RlU2Vzc2lvblZhbHVlKSB7XG4gICAgY29uc3QgdG9rZW5QYXlsb2FkID0gZGVjb2RlVG9rZW4oYXV0aFJlc3BvbnNlVG9rZW4pLnBheWxvYWRcbiAgICBpZiAoaXNMYXRlclZlcnNpb24odG9rZW5QYXlsb2FkLnZlcnNpb24sICcxLjMuMCcpXG4gICAgICAgJiYgdG9rZW5QYXlsb2FkLmJsb2Nrc3RhY2tBUElVcmwgIT09IG51bGwgJiYgdG9rZW5QYXlsb2FkLmJsb2Nrc3RhY2tBUElVcmwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gb3ZlcnJpZGUgZ2xvYmFsbHlcbiAgICAgIExvZ2dlci5pbmZvKGBPdmVycmlkaW5nICR7Y29uZmlnLm5ldHdvcmsuYmxvY2tzdGFja0FQSVVybH0gYFxuICAgICAgICArIGB3aXRoICR7dG9rZW5QYXlsb2FkLmJsb2Nrc3RhY2tBUElVcmx9YClcbiAgICAgIGNvbmZpZy5uZXR3b3JrLmJsb2Nrc3RhY2tBUElVcmwgPSB0b2tlblBheWxvYWQuYmxvY2tzdGFja0FQSVVybFxuICAgIH1cbiAgICBuYW1lTG9va3VwVVJMID0gYCR7Y29uZmlnLm5ldHdvcmsuYmxvY2tzdGFja0FQSVVybH0ke05BTUVfTE9PS1VQX1BBVEh9YFxuICB9IGVsc2Uge1xuICAgIG5hbWVMb29rdXBVUkwgPSBgJHtjb3JlTm9kZVNlc3Npb25WYWx1ZX0ke05BTUVfTE9PS1VQX1BBVEh9YFxuICB9XG4gIHJldHVybiB2ZXJpZnlBdXRoUmVzcG9uc2UoYXV0aFJlc3BvbnNlVG9rZW4sIG5hbWVMb29rdXBVUkwpXG4gICAgLnRoZW4oKGlzVmFsaWQpID0+IHtcbiAgICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgTG9naW5GYWlsZWRFcnJvcignSW52YWxpZCBhdXRoZW50aWNhdGlvbiByZXNwb25zZS4nKVxuICAgICAgfVxuICAgICAgY29uc3QgdG9rZW5QYXlsb2FkID0gZGVjb2RlVG9rZW4oYXV0aFJlc3BvbnNlVG9rZW4pLnBheWxvYWRcbiAgICAgIC8vIFRPRE86IHJlYWwgdmVyc2lvbiBoYW5kbGluZ1xuICAgICAgbGV0IGFwcFByaXZhdGVLZXkgPSB0b2tlblBheWxvYWQucHJpdmF0ZV9rZXlcbiAgICAgIGxldCBjb3JlU2Vzc2lvblRva2VuID0gdG9rZW5QYXlsb2FkLmNvcmVfdG9rZW5cbiAgICAgIGlmIChpc0xhdGVyVmVyc2lvbih0b2tlblBheWxvYWQudmVyc2lvbiwgJzEuMS4wJykpIHtcbiAgICAgICAgaWYgKHRyYW5zaXRLZXkgIT09IHVuZGVmaW5lZCAmJiB0cmFuc2l0S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAodG9rZW5QYXlsb2FkLnByaXZhdGVfa2V5ICE9PSB1bmRlZmluZWQgJiYgdG9rZW5QYXlsb2FkLnByaXZhdGVfa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBhcHBQcml2YXRlS2V5ID0gZGVjcnlwdFByaXZhdGVLZXkodHJhbnNpdEtleSwgdG9rZW5QYXlsb2FkLnByaXZhdGVfa2V5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBMb2dnZXIud2FybignRmFpbGVkIGRlY3J5cHRpb24gb2YgYXBwUHJpdmF0ZUtleSwgd2lsbCB0cnkgdG8gdXNlIGFzIGdpdmVuJylcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoZXhTdHJpbmdUb0VDUGFpcih0b2tlblBheWxvYWQucHJpdmF0ZV9rZXkpXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVjUGFpckVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IExvZ2luRmFpbGVkRXJyb3IoJ0ZhaWxlZCBkZWNyeXB0aW5nIGFwcFByaXZhdGVLZXkuIFVzdWFsbHkgbWVhbnMnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgJyB0aGF0IHRoZSB0cmFuc2l0IGtleSBoYXMgY2hhbmdlZCBkdXJpbmcgbG9naW4uJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29yZVNlc3Npb25Ub2tlbiAhPT0gdW5kZWZpbmVkICYmIGNvcmVTZXNzaW9uVG9rZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvcmVTZXNzaW9uVG9rZW4gPSBkZWNyeXB0UHJpdmF0ZUtleSh0cmFuc2l0S2V5LCBjb3JlU2Vzc2lvblRva2VuKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnRmFpbGVkIGRlY3J5cHRpb24gb2YgY29yZVNlc3Npb25Ub2tlbiwgd2lsbCB0cnkgdG8gdXNlIGFzIGdpdmVuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IExvZ2luRmFpbGVkRXJyb3IoJ0F1dGhlbnRpY2F0aW5nIHdpdGggcHJvdG9jb2wgPiAxLjEuMCByZXF1aXJlcyB0cmFuc2l0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArICcga2V5LCBhbmQgbm9uZSBmb3VuZC4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsZXQgaHViVXJsID0gQkxPQ0tTVEFDS19ERUZBVUxUX0dBSUFfSFVCX1VSTFxuICAgICAgbGV0IGdhaWFBc3NvY2lhdGlvblRva2VuXG4gICAgICBpZiAoaXNMYXRlclZlcnNpb24odG9rZW5QYXlsb2FkLnZlcnNpb24sICcxLjIuMCcpXG4gICAgICAgICYmIHRva2VuUGF5bG9hZC5odWJVcmwgIT09IG51bGwgJiYgdG9rZW5QYXlsb2FkLmh1YlVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGh1YlVybCA9IHRva2VuUGF5bG9hZC5odWJVcmxcbiAgICAgIH1cbiAgICAgIGlmIChpc0xhdGVyVmVyc2lvbih0b2tlblBheWxvYWQudmVyc2lvbiwgJzEuMy4wJylcbiAgICAgICAgJiYgdG9rZW5QYXlsb2FkLmFzc29jaWF0aW9uVG9rZW4gIT09IG51bGwgJiYgdG9rZW5QYXlsb2FkLmFzc29jaWF0aW9uVG9rZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnYWlhQXNzb2NpYXRpb25Ub2tlbiA9IHRva2VuUGF5bG9hZC5hc3NvY2lhdGlvblRva2VuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVzZXJEYXRhID0ge1xuICAgICAgICB1c2VybmFtZTogdG9rZW5QYXlsb2FkLnVzZXJuYW1lLFxuICAgICAgICBwcm9maWxlOiB0b2tlblBheWxvYWQucHJvZmlsZSxcbiAgICAgICAgZW1haWw6IHRva2VuUGF5bG9hZC5lbWFpbCxcbiAgICAgICAgZGVjZW50cmFsaXplZElEOiB0b2tlblBheWxvYWQuaXNzLFxuICAgICAgICBpZGVudGl0eUFkZHJlc3M6IGdldEFkZHJlc3NGcm9tRElEKHRva2VuUGF5bG9hZC5pc3MpLFxuICAgICAgICBhcHBQcml2YXRlS2V5LFxuICAgICAgICBjb3JlU2Vzc2lvblRva2VuLFxuICAgICAgICBhdXRoUmVzcG9uc2VUb2tlbixcbiAgICAgICAgaHViVXJsLFxuICAgICAgICBnYWlhQXNzb2NpYXRpb25Ub2tlblxuICAgICAgfVxuICAgICAgY29uc3QgcHJvZmlsZVVSTCA9IHRva2VuUGF5bG9hZC5wcm9maWxlX3VybFxuICAgICAgaWYgKCh1c2VyRGF0YS5wcm9maWxlID09PSBudWxsXG4gICAgICAgICB8fCB1c2VyRGF0YS5wcm9maWxlID09PSB1bmRlZmluZWQpXG4gICAgICAgICYmIHByb2ZpbGVVUkwgIT09IHVuZGVmaW5lZCAmJiBwcm9maWxlVVJMICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmZXRjaChwcm9maWxlVVJMKVxuICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykgeyAvLyByZXR1cm4gYmxhbmsgcHJvZmlsZSBpZiB3ZSBmYWlsIHRvIGZldGNoXG4gICAgICAgICAgICAgIHVzZXJEYXRhLnByb2ZpbGUgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1BST0ZJTEUpXG4gICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25EYXRhID0gY2FsbGVyLnN0b3JlLmdldFNlc3Npb25EYXRhKClcbiAgICAgICAgICAgICAgc2Vzc2lvbkRhdGEudXNlckRhdGEgPSB1c2VyRGF0YVxuICAgICAgICAgICAgICBjYWxsZXIuc3RvcmUuc2V0U2Vzc2lvbkRhdGEoc2Vzc2lvbkRhdGEpXG4gICAgICAgICAgICAgIHJldHVybiB1c2VyRGF0YVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlVGV4dCA9PiBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCkpXG4gICAgICAgICAgICAgICAgLnRoZW4od3JhcHBlZFByb2ZpbGUgPT4gZXh0cmFjdFByb2ZpbGUod3JhcHBlZFByb2ZpbGVbMF0udG9rZW4pKVxuICAgICAgICAgICAgICAgIC50aGVuKChwcm9maWxlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uRGF0YSA9IGNhbGxlci5zdG9yZS5nZXRTZXNzaW9uRGF0YSgpXG4gICAgICAgICAgICAgICAgICB1c2VyRGF0YS5wcm9maWxlID0gcHJvZmlsZVxuICAgICAgICAgICAgICAgICAgc2Vzc2lvbkRhdGEudXNlckRhdGEgPSB1c2VyRGF0YVxuICAgICAgICAgICAgICAgICAgY2FsbGVyLnN0b3JlLnNldFNlc3Npb25EYXRhKHNlc3Npb25EYXRhKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHVzZXJEYXRhXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2Vzc2lvbkRhdGEgPSBjYWxsZXIuc3RvcmUuZ2V0U2Vzc2lvbkRhdGEoKVxuICAgICAgICB1c2VyRGF0YS5wcm9maWxlID0gdG9rZW5QYXlsb2FkLnByb2ZpbGVcbiAgICAgICAgc2Vzc2lvbkRhdGEudXNlckRhdGEgPSB1c2VyRGF0YVxuICAgICAgICBjYWxsZXIuc3RvcmUuc2V0U2Vzc2lvbkRhdGEoc2Vzc2lvbkRhdGEpXG4gICAgICAgIHJldHVybiB1c2VyRGF0YVxuICAgICAgfVxuICAgIH0pXG59XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB1c2VyIGRhdGEgb2JqZWN0LiBUaGUgdXNlcidzIHByb2ZpbGUgaXMgc3RvcmVkIGluIHRoZSBrZXkgYHByb2ZpbGVgLlxuICpcbiAqICBAcGFyYW0ge1VzZXJTZXNzaW9ufSBjYWxsZXIgLSB0aGUgaW5zdGFuY2UgY2FsbGluZyB0aGlzIGZ1bmN0aW9uXG4gKiAgQHJldHVybiB7T2JqZWN0fSBVc2VyIGRhdGEgb2JqZWN0LlxuICogIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2FkVXNlckRhdGFJbXBsKGNhbGxlcjogVXNlclNlc3Npb24pIHtcbiAgY29uc3QgdXNlckRhdGEgPSBjYWxsZXIuc3RvcmUuZ2V0U2Vzc2lvbkRhdGEoKS51c2VyRGF0YVxuICBpZiAoIXVzZXJEYXRhKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRTdGF0ZUVycm9yKCdObyB1c2VyIGRhdGEgZm91bmQuIERpZCB0aGUgdXNlciBzaWduIGluPycpXG4gIH1cbiAgcmV0dXJuIHVzZXJEYXRhXG59XG5cbi8qKlxuICogUmVkaXJlY3RzIHRoZSB1c2VyIHRvIHRoZSBCbG9ja3N0YWNrIGJyb3dzZXIgdG8gYXBwcm92ZSB0aGUgc2lnbiBpbiByZXF1ZXN0XG4gKiBnaXZlbi5cbiAqXG4gKiBUaGUgdXNlciBpcyByZWRpcmVjdGVkIHRvIHRoZSBgYmxvY2tzdGFja0lESG9zdGAgaWYgdGhlIGBibG9ja3N0YWNrOmBcbiAqIHByb3RvY29sIGhhbmRsZXIgaXMgbm90IGRldGVjdGVkLiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBwcm90b2NvbCBoYW5kbGVyIGRldGVjdGlvblxuICogZG9lcyBub3Qgd29yayBvbiBhbGwgYnJvd3NlcnMuXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGF1dGhSZXF1ZXN0IC0gdGhlIGF1dGhlbnRpY2F0aW9uIHJlcXVlc3QgZ2VuZXJhdGVkIGJ5IGBtYWtlQXV0aFJlcXVlc3RgXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGJsb2Nrc3RhY2tJREhvc3QgLSB0aGUgVVJMIHRvIHJlZGlyZWN0IHRoZSB1c2VyIHRvIGlmIHRoZSBibG9ja3N0YWNrXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCBoYW5kbGVyIGlzIG5vdCBkZXRlY3RlZFxuICogQHJldHVybiB7dm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlZGlyZWN0VG9TaWduSW5XaXRoQXV0aFJlcXVlc3QoYXV0aFJlcXVlc3Q6IHN0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2Nrc3RhY2tJREhvc3Q6IHN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBERUZBVUxUX0JMT0NLU1RBQ0tfSE9TVCkge1xuICBjb25zb2xlLndhcm4oJ0RFUFJFQ0FUSU9OIFdBUk5JTkc6IFRoZSBzdGF0aWMgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdCgpIGZ1bmN0aW9uIHdpbGwgJ1xuICAgICsgJ2JlIGRlcHJlY2F0ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZSBvZiBibG9ja3N0YWNrLmpzLiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgVXNlclNlc3Npb24gJ1xuICAgICsgJ2FuZCBjYWxsIHRoZSBpbnN0YW5jZSBtZXRob2QgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdCgpLicpXG4gIGNvbnN0IHVzZXJTZXNzaW9uID0gbmV3IFVzZXJTZXNzaW9uKClcblxuICBjb25zdCBzZXNzaW9uQXV0aFJlcXVlc3QgPSAoYXV0aFJlcXVlc3QgPT0gbnVsbCkgXG4gICAgPyB1c2VyU2Vzc2lvbi5tYWtlQXV0aFJlcXVlc3QodXNlclNlc3Npb24uZ2VuZXJhdGVBbmRTdG9yZVRyYW5zaXRLZXkoKSkgOiBhdXRoUmVxdWVzdFxuICBcbiAgdXNlclNlc3Npb24uYXBwQ29uZmlnLmF1dGhlbnRpY2F0b3JVUkwgPSBibG9ja3N0YWNrSURIb3N0XG5cbiAgcmVkaXJlY3RUb1NpZ25JbldpdGhBdXRoUmVxdWVzdEltcGwodXNlclNlc3Npb24sIHNlc3Npb25BdXRoUmVxdWVzdClcbn1cbiJdfQ==