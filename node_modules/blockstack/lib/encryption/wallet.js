"use strict";

exports.__esModule = true;
exports.encryptMnemonic = encryptMnemonic;
exports.decryptMnemonic = decryptMnemonic;

var _crypto = _interopRequireDefault(require("crypto"));

var _bip = _interopRequireDefault(require("bip39"));

var _triplesec = _interopRequireDefault(require("triplesec"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Encrypt a raw mnemonic phrase to be password protected
 * @param {string} phrase - Raw mnemonic phrase
 * @param {string} password - Password to encrypt mnemonic with
 * @return {Promise<Buffer>} The encrypted phrase
 * @private
 */
function encryptMnemonic(phrase, password) {
  return Promise.resolve().then(() => {
    // must be bip39 mnemonic
    if (!_bip.default.validateMnemonic(phrase)) {
      throw new Error('Not a valid bip39 nmemonic');
    } // normalize plaintext to fixed length byte string


    const plaintextNormalized = Buffer.from(_bip.default.mnemonicToEntropy(phrase).toString('hex'), 'hex'); // AES-128-CBC with SHA256 HMAC

    const salt = _crypto.default.randomBytes(16);

    const keysAndIV = _crypto.default.pbkdf2Sync(password, salt, 100000, 48, 'sha512');

    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);

    const cipher = _crypto.default.createCipheriv('aes-128-cbc', encKey, iv);

    let cipherText = cipher.update(plaintextNormalized).toString('hex');
    cipherText += cipher.final().toString('hex');
    const hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')]);

    const hmac = _crypto.default.createHmac('sha256', macKey);

    hmac.write(hmacPayload);
    const hmacDigest = hmac.digest();
    const payload = Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')]);
    return payload;
  });
} // Used to distinguish bad password during decrypt vs invalid format


class PasswordError extends Error {}

function decryptMnemonicBuffer(dataBuffer, password) {
  return Promise.resolve().then(() => {
    const salt = dataBuffer.slice(0, 16);
    const hmacSig = dataBuffer.slice(16, 48); // 32 bytes

    const cipherText = dataBuffer.slice(48);
    const hmacPayload = Buffer.concat([salt, cipherText]);

    const keysAndIV = _crypto.default.pbkdf2Sync(password, salt, 100000, 48, 'sha512');

    const encKey = keysAndIV.slice(0, 16);
    const macKey = keysAndIV.slice(16, 32);
    const iv = keysAndIV.slice(32, 48);

    const decipher = _crypto.default.createDecipheriv('aes-128-cbc', encKey, iv);

    let plaintext = decipher.update(cipherText).toString('hex');
    plaintext += decipher.final().toString('hex');

    const hmac = _crypto.default.createHmac('sha256', macKey);

    hmac.write(hmacPayload);
    const hmacDigest = hmac.digest(); // hash both hmacSig and hmacDigest so string comparison time
    // is uncorrelated to the ciphertext

    const hmacSigHash = _crypto.default.createHash('sha256').update(hmacSig).digest().toString('hex');

    const hmacDigestHash = _crypto.default.createHash('sha256').update(hmacDigest).digest().toString('hex');

    if (hmacSigHash !== hmacDigestHash) {
      // not authentic
      throw new PasswordError('Wrong password (HMAC mismatch)');
    }

    const mnemonic = _bip.default.entropyToMnemonic(plaintext);

    if (!_bip.default.validateMnemonic(mnemonic)) {
      throw new PasswordError('Wrong password (invalid plaintext)');
    }

    return mnemonic;
  });
}
/**
 * Decrypt legacy triplesec keys
 * @param {Buffer} dataBuffer - The encrypted key
 * @param {String} password - Password for data
 * @return {Promise<Buffer>} Decrypted seed
 * @private
 */


function decryptLegacy(dataBuffer, password) {
  return new Promise((resolve, reject) => {
    _triplesec.default.decrypt({
      key: Buffer.from(password),
      data: dataBuffer
    }, (err, plaintextBuffer) => {
      if (!err) {
        resolve(plaintextBuffer);
      } else {
        reject(err);
      }
    });
  });
}
/**
 * Encrypt a raw mnemonic phrase with a password
 * @param {string | Buffer} data - Buffer or hex-encoded string of the encrypted mnemonic
 * @param {string} password - Password for data
 * @return {Promise<Buffer>} the raw mnemonic phrase
 * @private
 */


function decryptMnemonic(data, password) {
  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');
  return decryptMnemonicBuffer(dataBuffer, password).catch(err => {
    // If it was a password error, don't even bother with legacy
    if (err instanceof PasswordError) {
      throw err;
    }

    return decryptLegacy(dataBuffer, password);
  });
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lbmNyeXB0aW9uL3dhbGxldC5qcyJdLCJuYW1lcyI6WyJlbmNyeXB0TW5lbW9uaWMiLCJwaHJhc2UiLCJwYXNzd29yZCIsIlByb21pc2UiLCJyZXNvbHZlIiwidGhlbiIsImJpcDM5IiwidmFsaWRhdGVNbmVtb25pYyIsIkVycm9yIiwicGxhaW50ZXh0Tm9ybWFsaXplZCIsIkJ1ZmZlciIsImZyb20iLCJtbmVtb25pY1RvRW50cm9weSIsInRvU3RyaW5nIiwic2FsdCIsImNyeXB0byIsInJhbmRvbUJ5dGVzIiwia2V5c0FuZElWIiwicGJrZGYyU3luYyIsImVuY0tleSIsInNsaWNlIiwibWFjS2V5IiwiaXYiLCJjaXBoZXIiLCJjcmVhdGVDaXBoZXJpdiIsImNpcGhlclRleHQiLCJ1cGRhdGUiLCJmaW5hbCIsImhtYWNQYXlsb2FkIiwiY29uY2F0IiwiaG1hYyIsImNyZWF0ZUhtYWMiLCJ3cml0ZSIsImhtYWNEaWdlc3QiLCJkaWdlc3QiLCJwYXlsb2FkIiwiUGFzc3dvcmRFcnJvciIsImRlY3J5cHRNbmVtb25pY0J1ZmZlciIsImRhdGFCdWZmZXIiLCJobWFjU2lnIiwiZGVjaXBoZXIiLCJjcmVhdGVEZWNpcGhlcml2IiwicGxhaW50ZXh0IiwiaG1hY1NpZ0hhc2giLCJjcmVhdGVIYXNoIiwiaG1hY0RpZ2VzdEhhc2giLCJtbmVtb25pYyIsImVudHJvcHlUb01uZW1vbmljIiwiZGVjcnlwdExlZ2FjeSIsInJlamVjdCIsInRyaXBsZXNlYyIsImRlY3J5cHQiLCJrZXkiLCJkYXRhIiwiZXJyIiwicGxhaW50ZXh0QnVmZmVyIiwiZGVjcnlwdE1uZW1vbmljIiwiaXNCdWZmZXIiLCJjYXRjaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7Ozs7OztBQU9PLFNBQVNBLGVBQVQsQ0FBeUJDLE1BQXpCLEVBQXlDQyxRQUF6QyxFQUEyRDtBQUNoRSxTQUFPQyxPQUFPLENBQUNDLE9BQVIsR0FBa0JDLElBQWxC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RHdELEtBQW5ELENBQTBESixHQUFELElBQVM7QUFDdkU7QUFDQSxRQUFJQSxHQUFHLFlBQVlsQixhQUFuQixFQUFrQztBQUNoQyxZQUFNa0IsR0FBTjtBQUNEOztBQUNELFdBQU9OLGFBQWEsQ0FBRVYsVUFBRixFQUFvQnBDLFFBQXBCLENBQXBCO0FBQ0QsR0FOTSxDQUFQO0FBT0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3J5cHRvIGZyb20gJ2NyeXB0bydcbmltcG9ydCBiaXAzOSBmcm9tICdiaXAzOSdcbmltcG9ydCB0cmlwbGVzZWMgZnJvbSAndHJpcGxlc2VjJ1xuXG4vKipcbiAqIEVuY3J5cHQgYSByYXcgbW5lbW9uaWMgcGhyYXNlIHRvIGJlIHBhc3N3b3JkIHByb3RlY3RlZFxuICogQHBhcmFtIHtzdHJpbmd9IHBocmFzZSAtIFJhdyBtbmVtb25pYyBwaHJhc2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFBhc3N3b3JkIHRvIGVuY3J5cHQgbW5lbW9uaWMgd2l0aFxuICogQHJldHVybiB7UHJvbWlzZTxCdWZmZXI+fSBUaGUgZW5jcnlwdGVkIHBocmFzZVxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHRNbmVtb25pYyhwaHJhc2U6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZykge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgLy8gbXVzdCBiZSBiaXAzOSBtbmVtb25pY1xuICAgIGlmICghYmlwMzkudmFsaWRhdGVNbmVtb25pYyhwaHJhc2UpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIGJpcDM5IG5tZW1vbmljJylcbiAgICB9XG5cbiAgICAvLyBub3JtYWxpemUgcGxhaW50ZXh0IHRvIGZpeGVkIGxlbmd0aCBieXRlIHN0cmluZ1xuICAgIGNvbnN0IHBsYWludGV4dE5vcm1hbGl6ZWQgPSBCdWZmZXIuZnJvbShcbiAgICAgIGJpcDM5Lm1uZW1vbmljVG9FbnRyb3B5KHBocmFzZSkudG9TdHJpbmcoJ2hleCcpLCAnaGV4J1xuICAgIClcblxuICAgIC8vIEFFUy0xMjgtQ0JDIHdpdGggU0hBMjU2IEhNQUNcbiAgICBjb25zdCBzYWx0ID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDE2KVxuICAgIGNvbnN0IGtleXNBbmRJViA9IGNyeXB0by5wYmtkZjJTeW5jKHBhc3N3b3JkLCBzYWx0LCAxMDAwMDAsIDQ4LCAnc2hhNTEyJylcbiAgICBjb25zdCBlbmNLZXkgPSBrZXlzQW5kSVYuc2xpY2UoMCwgMTYpXG4gICAgY29uc3QgbWFjS2V5ID0ga2V5c0FuZElWLnNsaWNlKDE2LCAzMilcbiAgICBjb25zdCBpdiA9IGtleXNBbmRJVi5zbGljZSgzMiwgNDgpXG5cbiAgICBjb25zdCBjaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoJ2Flcy0xMjgtY2JjJywgZW5jS2V5LCBpdilcbiAgICBsZXQgY2lwaGVyVGV4dCA9IGNpcGhlci51cGRhdGUocGxhaW50ZXh0Tm9ybWFsaXplZCkudG9TdHJpbmcoJ2hleCcpXG4gICAgY2lwaGVyVGV4dCArPSBjaXBoZXIuZmluYWwoKS50b1N0cmluZygnaGV4JylcblxuICAgIGNvbnN0IGhtYWNQYXlsb2FkID0gQnVmZmVyLmNvbmNhdChbc2FsdCwgQnVmZmVyLmZyb20oY2lwaGVyVGV4dCwgJ2hleCcpXSlcblxuICAgIGNvbnN0IGhtYWMgPSBjcnlwdG8uY3JlYXRlSG1hYygnc2hhMjU2JywgbWFjS2V5KVxuICAgIGhtYWMud3JpdGUoaG1hY1BheWxvYWQpXG4gICAgY29uc3QgaG1hY0RpZ2VzdCA9IGhtYWMuZGlnZXN0KClcblxuICAgIGNvbnN0IHBheWxvYWQgPSBCdWZmZXIuY29uY2F0KFtzYWx0LCBobWFjRGlnZXN0LCBCdWZmZXIuZnJvbShjaXBoZXJUZXh0LCAnaGV4JyldKVxuICAgIHJldHVybiBwYXlsb2FkXG4gIH0pXG59XG5cbi8vIFVzZWQgdG8gZGlzdGluZ3Vpc2ggYmFkIHBhc3N3b3JkIGR1cmluZyBkZWNyeXB0IHZzIGludmFsaWQgZm9ybWF0XG5jbGFzcyBQYXNzd29yZEVycm9yIGV4dGVuZHMgRXJyb3IgeyB9XG5cbmZ1bmN0aW9uIGRlY3J5cHRNbmVtb25pY0J1ZmZlcihkYXRhQnVmZmVyOiBCdWZmZXIsIHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGNvbnN0IHNhbHQgPSBkYXRhQnVmZmVyLnNsaWNlKDAsIDE2KVxuICAgIGNvbnN0IGhtYWNTaWcgPSBkYXRhQnVmZmVyLnNsaWNlKDE2LCA0OCkgICAvLyAzMiBieXRlc1xuICAgIGNvbnN0IGNpcGhlclRleHQgPSBkYXRhQnVmZmVyLnNsaWNlKDQ4KVxuICAgIGNvbnN0IGhtYWNQYXlsb2FkID0gQnVmZmVyLmNvbmNhdChbc2FsdCwgY2lwaGVyVGV4dF0pXG5cbiAgICBjb25zdCBrZXlzQW5kSVYgPSBjcnlwdG8ucGJrZGYyU3luYyhwYXNzd29yZCwgc2FsdCwgMTAwMDAwLCA0OCwgJ3NoYTUxMicpXG4gICAgY29uc3QgZW5jS2V5ID0ga2V5c0FuZElWLnNsaWNlKDAsIDE2KVxuICAgIGNvbnN0IG1hY0tleSA9IGtleXNBbmRJVi5zbGljZSgxNiwgMzIpXG4gICAgY29uc3QgaXYgPSBrZXlzQW5kSVYuc2xpY2UoMzIsIDQ4KVxuXG4gICAgY29uc3QgZGVjaXBoZXIgPSBjcnlwdG8uY3JlYXRlRGVjaXBoZXJpdignYWVzLTEyOC1jYmMnLCBlbmNLZXksIGl2KVxuICAgIGxldCBwbGFpbnRleHQgPSBkZWNpcGhlci51cGRhdGUoY2lwaGVyVGV4dCkudG9TdHJpbmcoJ2hleCcpXG4gICAgcGxhaW50ZXh0ICs9IGRlY2lwaGVyLmZpbmFsKCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICBjb25zdCBobWFjID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIG1hY0tleSlcbiAgICBobWFjLndyaXRlKGhtYWNQYXlsb2FkKVxuICAgIGNvbnN0IGhtYWNEaWdlc3QgPSBobWFjLmRpZ2VzdCgpXG5cbiAgICAvLyBoYXNoIGJvdGggaG1hY1NpZyBhbmQgaG1hY0RpZ2VzdCBzbyBzdHJpbmcgY29tcGFyaXNvbiB0aW1lXG4gICAgLy8gaXMgdW5jb3JyZWxhdGVkIHRvIHRoZSBjaXBoZXJ0ZXh0XG4gICAgY29uc3QgaG1hY1NpZ0hhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoaG1hY1NpZylcbiAgICAgIC5kaWdlc3QoKVxuICAgICAgLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgY29uc3QgaG1hY0RpZ2VzdEhhc2ggPSBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMjU2JylcbiAgICAgIC51cGRhdGUoaG1hY0RpZ2VzdClcbiAgICAgIC5kaWdlc3QoKVxuICAgICAgLnRvU3RyaW5nKCdoZXgnKVxuXG4gICAgaWYgKGhtYWNTaWdIYXNoICE9PSBobWFjRGlnZXN0SGFzaCkge1xuICAgICAgLy8gbm90IGF1dGhlbnRpY1xuICAgICAgdGhyb3cgbmV3IFBhc3N3b3JkRXJyb3IoJ1dyb25nIHBhc3N3b3JkIChITUFDIG1pc21hdGNoKScpXG4gICAgfVxuXG4gICAgY29uc3QgbW5lbW9uaWMgPSBiaXAzOS5lbnRyb3B5VG9NbmVtb25pYyhwbGFpbnRleHQpXG4gICAgaWYgKCFiaXAzOS52YWxpZGF0ZU1uZW1vbmljKG1uZW1vbmljKSkge1xuICAgICAgdGhyb3cgbmV3IFBhc3N3b3JkRXJyb3IoJ1dyb25nIHBhc3N3b3JkIChpbnZhbGlkIHBsYWludGV4dCknKVxuICAgIH1cblxuICAgIHJldHVybiBtbmVtb25pY1xuICB9KVxufVxuXG5cbi8qKlxuICogRGVjcnlwdCBsZWdhY3kgdHJpcGxlc2VjIGtleXNcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhQnVmZmVyIC0gVGhlIGVuY3J5cHRlZCBrZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCAtIFBhc3N3b3JkIGZvciBkYXRhXG4gKiBAcmV0dXJuIHtQcm9taXNlPEJ1ZmZlcj59IERlY3J5cHRlZCBzZWVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNyeXB0TGVnYWN5KGRhdGFCdWZmZXI6IEJ1ZmZlciwgcGFzc3dvcmQ6IHN0cmluZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRyaXBsZXNlYy5kZWNyeXB0KFxuICAgICAge1xuICAgICAgICBrZXk6IEJ1ZmZlci5mcm9tKHBhc3N3b3JkKSxcbiAgICAgICAgZGF0YTogZGF0YUJ1ZmZlclxuICAgICAgfSxcbiAgICAgIChlcnIsIHBsYWludGV4dEJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHJlc29sdmUocGxhaW50ZXh0QnVmZmVyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG4gIH0pXG59XG5cbi8qKlxuICogRW5jcnlwdCBhIHJhdyBtbmVtb25pYyBwaHJhc2Ugd2l0aCBhIHBhc3N3b3JkXG4gKiBAcGFyYW0ge3N0cmluZyB8IEJ1ZmZlcn0gZGF0YSAtIEJ1ZmZlciBvciBoZXgtZW5jb2RlZCBzdHJpbmcgb2YgdGhlIGVuY3J5cHRlZCBtbmVtb25pY1xuICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gUGFzc3dvcmQgZm9yIGRhdGFcbiAqIEByZXR1cm4ge1Byb21pc2U8QnVmZmVyPn0gdGhlIHJhdyBtbmVtb25pYyBwaHJhc2VcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNyeXB0TW5lbW9uaWMoZGF0YTogKHN0cmluZyB8IEJ1ZmZlciksIHBhc3N3b3JkOiBzdHJpbmcpIHtcbiAgY29uc3QgZGF0YUJ1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSA/IGRhdGEgOiBCdWZmZXIuZnJvbSgoZGF0YTogYW55KSwgJ2hleCcpXG4gIHJldHVybiBkZWNyeXB0TW5lbW9uaWNCdWZmZXIoKGRhdGFCdWZmZXI6IGFueSksIHBhc3N3b3JkKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgLy8gSWYgaXQgd2FzIGEgcGFzc3dvcmQgZXJyb3IsIGRvbid0IGV2ZW4gYm90aGVyIHdpdGggbGVnYWN5XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFBhc3N3b3JkRXJyb3IpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgICByZXR1cm4gZGVjcnlwdExlZ2FjeSgoZGF0YUJ1ZmZlcjogYW55KSwgcGFzc3dvcmQpXG4gIH0pXG59XG4iXX0=